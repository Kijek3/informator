(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{453:function(module,exports,__webpack_require__){eval('var _asyncToGenerator = __webpack_require__(303);\n\nvar _typeof = __webpack_require__(265);\n\nvar _classCallCheck = __webpack_require__(454);\n\nvar _createClass = __webpack_require__(455);\n\nvar _defineProperty = __webpack_require__(456);\n\n__webpack_require__(64);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n__webpack_require__(8);\n\n__webpack_require__(5);\n\n__webpack_require__(28);\n\n__webpack_require__(41);\n\n__webpack_require__(35);\n\n__webpack_require__(71);\n\n__webpack_require__(162);\n\n__webpack_require__(302);\n\n__webpack_require__(30);\n\n__webpack_require__(15);\n\n__webpack_require__(24);\n\n__webpack_require__(40);\n\n__webpack_require__(29);\n\n__webpack_require__(4);\n\n__webpack_require__(38);\n\n__webpack_require__(48);\n\n__webpack_require__(33);\n\nvar pick = function pick(obj) {\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return Object.keys(obj).filter(function (key) {\n    return keys.includes(key);\n  }).reduce(function (newObj, key) {\n    return Object.assign(newObj, _defineProperty({}, key, obj[key]));\n  }, {});\n};\n\nvar omit = function omit(obj) {\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return Object.keys(obj).filter(function (key) {\n    return !keys.includes(key);\n  }).reduce(function (newObj, key) {\n    return Object.assign(newObj, _defineProperty({}, key, obj[key]));\n  }, {});\n};\n\nvar QueryBuilder = /*#__PURE__*/function () {\n  "use strict";\n\n  function QueryBuilder(_ref, options) {\n    var query = _ref.query,\n        path = _ref.path,\n        init = _ref.init,\n        text = _ref.text,\n        _ref$postprocess = _ref.postprocess,\n        postprocess = _ref$postprocess === void 0 ? [] : _ref$postprocess;\n\n    _classCallCheck(this, QueryBuilder);\n\n    this.query = query;\n    this.path = path;\n    this.init = init;\n    this.postprocess = postprocess;\n    this.options = options || {};\n    this.onlyKeys = null;\n    this.withoutKeys = null;\n    this.sortKeys = [];\n    this.limitN = null;\n    this.skipN = null;\n\n    if (!text) {\n      // Remove text field from response\n      this.postprocess.unshift(function (data) {\n        return data.map(function (item) {\n          return omit(item, [\'text\']);\n        });\n      });\n    }\n  }\n  /**\n   * Select a subset of fields\n   * @param {Array} keys - Array of fields to be picked.\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n\n\n  _createClass(QueryBuilder, [{\n    key: "only",\n    value: function only(keys) {\n      // Assign keys to this.onlyKeys to be processed in fetch\n      this.onlyKeys = Array.isArray(keys) ? keys : [keys]; // Return current instance\n\n      return this;\n    }\n    /**\n     * Remove a subset of fields\n     * @param {Array} keys - Array of fields to be picked.\n     * @returns {QueryBuilder} Returns current instance to be chained\n     */\n\n  }, {\n    key: "without",\n    value: function without(keys) {\n      // Assign keys to this.withoutKeys to be processed in fetch\n      this.withoutKeys = Array.isArray(keys) ? keys : [keys]; // Return current instance\n\n      return this;\n    }\n    /**\n     * Sort results\n     * @param {string} field - Field key to sort on.\n     * @param {string} direction - Direction of sort (asc / desc).\n     * @returns {QueryBuilder} Returns current instance to be chained\n     */\n\n  }, {\n    key: "sortBy",\n    value: function sortBy(field, direction) {\n      this.sortKeys.push([field, direction === \'desc\']);\n      return this;\n    }\n    /**\n     * Filter results\n     * @param {object} query - Where query.\n     * @returns {QueryBuilder} Returns current instance to be chained\n     */\n\n  }, {\n    key: "where",\n    value: function where(query) {\n      this.query = this.query.find(query);\n      return this;\n    }\n    /**\n     * Search results\n     * @param {(Object|string)} query - Search query object or field or search value.\n     * @param {string} value - Value of search (means query equals to field).\n     * @returns {QueryBuilder} Returns current instance to be chained\n     */\n\n  }, {\n    key: "search",\n    value: function search(query, value) {\n      // Passing an empty or falsey value as query will avoid triggering a search to allow optional chaining\n      if (!query) {\n        return this;\n      }\n\n      var $fts;\n\n      if (_typeof(query) === \'object\') {\n        $fts = query;\n      } else if (value) {\n        $fts = {\n          query: {\n            type: \'match\',\n            field: query,\n            value: value,\n            prefix_length: 1,\n            fuzziness: 1,\n            extended: true,\n            minimum_should_match: 1\n          }\n        };\n      } else {\n        $fts = {\n          query: {\n            type: \'bool\',\n            should: this.options.fullTextSearchFields.map(function (field) {\n              return {\n                type: \'match\',\n                field: field,\n                value: query,\n                prefix_length: 1,\n                operator: \'and\',\n                minimum_should_match: 1,\n                fuzziness: 1,\n                extended: true\n              };\n            })\n          }\n        };\n      }\n\n      this.query = this.query.find({\n        $fts: $fts\n      }).sortByScoring();\n      return this;\n    }\n    /**\n     * Surround results\n     * @param {string} slugOrPath - Slug or path of the file to surround.\n     * @param {Object} options - Options to surround (before / after).\n     * @returns {QueryBuilder} Returns current instance to be chained\n     */\n\n  }, {\n    key: "surround",\n    value: function surround(slugOrPath) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$before = _ref2.before,\n          before = _ref2$before === void 0 ? 1 : _ref2$before,\n          _ref2$after = _ref2.after,\n          after = _ref2$after === void 0 ? 1 : _ref2$after;\n\n      var _key = slugOrPath.indexOf(\'/\') === 0 ? \'path\' : \'slug\'; // Add slug or path to onlyKeys if only method has been called before\n\n\n      if (this.onlyKeys) {\n        this.onlyKeys.push(_key);\n      } // Remove slug or path from withoutKeys if without method has been called before\n\n\n      if (this.withoutKeys) {\n        this.withoutKeys = this.withoutKeys.filter(function (key) {\n          return key !== _key;\n        });\n      }\n\n      var fn = function fn(data) {\n        var index = data.findIndex(function (item) {\n          return item[_key] === slugOrPath;\n        });\n        var slice = new Array(before + after).fill(null, 0);\n\n        if (index === -1) {\n          return slice;\n        }\n\n        var prevSlice = data.slice(index - before, index);\n        var nextSlice = data.slice(index + 1, index + 1 + after);\n        var prevIndex = 0;\n\n        for (var i = before - 1; i >= 0; i--) {\n          slice[i] = prevSlice[prevIndex] || null;\n          prevIndex++;\n        }\n\n        var nextIndex = 0;\n\n        for (var _i = before; _i <= after; _i++) {\n          slice[_i] = nextSlice[nextIndex] || null;\n          nextIndex++;\n        }\n\n        return slice;\n      };\n\n      this.postprocess.push(fn);\n      return this;\n    }\n    /**\n     * Limit number of results\n     * @param {number} n - Limit number.\n     * @returns {QueryBuilder} Returns current instance to be chained\n     */\n\n  }, {\n    key: "limit",\n    value: function limit(n) {\n      if (typeof n === \'string\') {\n        n = parseInt(n);\n      }\n\n      this.limitN = n;\n      return this;\n    }\n    /**\n     * Skip number of results\n     * @param {number} n - Skip number.\n     * @returns {QueryBuilder} Returns current instance to be chained\n     */\n\n  }, {\n    key: "skip",\n    value: function skip(n) {\n      if (typeof n === \'string\') {\n        n = parseInt(n);\n      }\n\n      this.skipN = n;\n      return this;\n    }\n    /**\n     * Collect data and apply process filters\n     * @returns {(Object|Array)} Returns processed data\n     */\n    // eslint-disable-next-line require-await\n\n  }, {\n    key: "fetch",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var data, fn, _fn, _iterator, _step, _fn2;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.sortKeys && this.sortKeys.length) {\n                  this.query = this.query.compoundsort(this.sortKeys);\n                }\n\n                if (this.skipN) {\n                  this.query = this.query.offset(this.skipN);\n                }\n\n                if (this.limitN) {\n                  this.query = this.query.limit(this.limitN);\n                } // Collect data without meta fields\n\n\n                data = this.query.data({\n                  removeMeta: true\n                }); // Handle only keys\n\n                if (this.onlyKeys) {\n                  // Add `path` and `extension` to onlyKeys if watch to ensure live edit\n                  if (this.options.watch) {\n                    this.onlyKeys.push(\'path\', \'extension\');\n                  } // Map data and returns object picked by keys\n\n\n                  fn = function fn(data) {\n                    return data.map(function (item) {\n                      return pick(item, _this.onlyKeys);\n                    });\n                  }; // Apply pick during postprocess\n\n\n                  this.postprocess.unshift(fn);\n                } // Handle without keys\n\n\n                if (this.withoutKeys) {\n                  // Remove `path` and `extension` from withoutKeys if watch to ensure live edit\n                  if (this.options.watch) {\n                    this.withoutKeys = this.withoutKeys.filter(function (key) {\n                      return ![\'path\', \'extension\'].includes(key);\n                    });\n                  } // Map data and returns object picked by keys\n\n\n                  _fn = function _fn(data) {\n                    return data.map(function (item) {\n                      return omit(item, _this.withoutKeys);\n                    });\n                  }; // Apply pick during postprocess\n\n\n                  this.postprocess.unshift(_fn);\n                } // Apply postprocess fns to data\n\n\n                _iterator = _createForOfIteratorHelper(this.postprocess);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _fn2 = _step.value;\n                    data = _fn2(data);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                if (data) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new Error("".concat(this.path, " not found"));\n\n              case 10:\n                return _context.abrupt("return", JSON.parse(JSON.stringify(data)));\n\n              case 11:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetch() {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n  }]);\n\n  return QueryBuilder;\n}();\n\nmodule.exports = QueryBuilder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLmNhY2hlL251eHQvY29udGVudC9xdWVyeS1idWlsZGVyLmpzPzFhNTAiXSwibmFtZXMiOlsicGljayIsIm9iaiIsImtleXMiLCJPYmplY3QiLCJmaWx0ZXIiLCJrZXkiLCJpbmNsdWRlcyIsInJlZHVjZSIsIm5ld09iaiIsImFzc2lnbiIsIm9taXQiLCJRdWVyeUJ1aWxkZXIiLCJvcHRpb25zIiwicXVlcnkiLCJwYXRoIiwiaW5pdCIsInRleHQiLCJwb3N0cHJvY2VzcyIsIm9ubHlLZXlzIiwid2l0aG91dEtleXMiLCJzb3J0S2V5cyIsImxpbWl0TiIsInNraXBOIiwidW5zaGlmdCIsImRhdGEiLCJtYXAiLCJpdGVtIiwiQXJyYXkiLCJpc0FycmF5IiwiZmllbGQiLCJkaXJlY3Rpb24iLCJwdXNoIiwiZmluZCIsInZhbHVlIiwiJGZ0cyIsInR5cGUiLCJwcmVmaXhfbGVuZ3RoIiwiZnV6emluZXNzIiwiZXh0ZW5kZWQiLCJtaW5pbXVtX3Nob3VsZF9tYXRjaCIsInNob3VsZCIsImZ1bGxUZXh0U2VhcmNoRmllbGRzIiwib3BlcmF0b3IiLCJzb3J0QnlTY29yaW5nIiwic2x1Z09yUGF0aCIsImJlZm9yZSIsImFmdGVyIiwiX2tleSIsImluZGV4T2YiLCJmbiIsImluZGV4IiwiZmluZEluZGV4Iiwic2xpY2UiLCJmaWxsIiwicHJldlNsaWNlIiwibmV4dFNsaWNlIiwicHJldkluZGV4IiwiaSIsIm5leHRJbmRleCIsIm4iLCJwYXJzZUludCIsImxlbmd0aCIsImNvbXBvdW5kc29ydCIsIm9mZnNldCIsImxpbWl0IiwicmVtb3ZlTWV0YSIsIndhdGNoIiwiRXJyb3IiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBTUEsSUFBSSxHQUFHLFNBQVBB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QW1DO0FBQXhCZ0Msd0JBQXdCO0FBQ2pDekIsd0JBQUksR0FBR3lCLElBQUUsQ0FBQ3pCLElBQUQsQ0FBVDtBQUNEO0FBckNIO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsb0JBdUNPQSxJQXZDUDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxzQkF3Q1UsSUFBSTJDLEtBQUosV0FBYSxLQUFLckQsSUFBbEIsZ0JBeENWOztBQUFBO0FBQUEsaURBMkNTc0QsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ0UsU0FBTCxDQUFlOUMsSUFBZixDQUFYLENBM0NUOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7Ozs7QUErQ0YrQyxNQUFNLENBQUNDLE9BQVAsR0FBaUI3RCxZQUFqQiIsImZpbGUiOiI0NTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwaWNrID0gKG9iaiwga2V5cyA9IFtdKSA9PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgLmZpbHRlcihrZXkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgIC5yZWR1Y2UoKG5ld09iaiwga2V5KSA9PiBPYmplY3QuYXNzaWduKG5ld09iaiwgeyBba2V5XTogb2JqW2tleV0gfSksIHt9KVxufVxuXG5jb25zdCBvbWl0ID0gKG9iaiwga2V5cyA9IFtdKSA9PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgLmZpbHRlcihrZXkgPT4gIWtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAucmVkdWNlKChuZXdPYmosIGtleSkgPT4gT2JqZWN0LmFzc2lnbihuZXdPYmosIHsgW2tleV06IG9ialtrZXldIH0pLCB7fSlcbn1cblxuY2xhc3MgUXVlcnlCdWlsZGVyIHtcbiAgY29uc3RydWN0b3IgKHsgcXVlcnksIHBhdGgsIGluaXQsIHRleHQsIHBvc3Rwcm9jZXNzID0gW10gfSwgb3B0aW9ucykge1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgICB0aGlzLmluaXQgPSBpbml0XG4gICAgdGhpcy5wb3N0cHJvY2VzcyA9IHBvc3Rwcm9jZXNzXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHRoaXMub25seUtleXMgPSBudWxsXG4gICAgdGhpcy53aXRob3V0S2V5cyA9IG51bGxcbiAgICB0aGlzLnNvcnRLZXlzID0gW11cbiAgICB0aGlzLmxpbWl0TiA9IG51bGxcbiAgICB0aGlzLnNraXBOID0gbnVsbFxuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICAvLyBSZW1vdmUgdGV4dCBmaWVsZCBmcm9tIHJlc3BvbnNlXG4gICAgICB0aGlzLnBvc3Rwcm9jZXNzLnVuc2hpZnQoZGF0YSA9PiBkYXRhLm1hcChpdGVtID0+IG9taXQoaXRlbSwgWyd0ZXh0J10pKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc3Vic2V0IG9mIGZpZWxkc1xuICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gQXJyYXkgb2YgZmllbGRzIHRvIGJlIHBpY2tlZC5cbiAgICogQHJldHVybnMge1F1ZXJ5QnVpbGRlcn0gUmV0dXJucyBjdXJyZW50IGluc3RhbmNlIHRvIGJlIGNoYWluZWRcbiAgICovXG4gIG9ubHkgKGtleXMpIHtcbiAgICAvLyBBc3NpZ24ga2V5cyB0byB0aGlzLm9ubHlLZXlzIHRvIGJlIHByb2Nlc3NlZCBpbiBmZXRjaFxuICAgIHRoaXMub25seUtleXMgPSBBcnJheS5pc0FycmF5KGtleXMpID8ga2V5cyA6IFtrZXlzXVxuICAgIC8vIFJldHVybiBjdXJyZW50IGluc3RhbmNlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzdWJzZXQgb2YgZmllbGRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBBcnJheSBvZiBmaWVsZHMgdG8gYmUgcGlja2VkLlxuICAgKiBAcmV0dXJucyB7UXVlcnlCdWlsZGVyfSBSZXR1cm5zIGN1cnJlbnQgaW5zdGFuY2UgdG8gYmUgY2hhaW5lZFxuICAgKi9cbiAgd2l0aG91dCAoa2V5cykge1xuICAgIC8vIEFzc2lnbiBrZXlzIHRvIHRoaXMud2l0aG91dEtleXMgdG8gYmUgcHJvY2Vzc2VkIGluIGZldGNoXG4gICAgdGhpcy53aXRob3V0S2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5cykgPyBrZXlzIDogW2tleXNdXG4gICAgLy8gUmV0dXJuIGN1cnJlbnQgaW5zdGFuY2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnQgcmVzdWx0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgLSBGaWVsZCBrZXkgdG8gc29ydCBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAtIERpcmVjdGlvbiBvZiBzb3J0IChhc2MgLyBkZXNjKS5cbiAgICogQHJldHVybnMge1F1ZXJ5QnVpbGRlcn0gUmV0dXJucyBjdXJyZW50IGluc3RhbmNlIHRvIGJlIGNoYWluZWRcbiAgICovXG4gIHNvcnRCeSAoZmllbGQsIGRpcmVjdGlvbikge1xuICAgIHRoaXMuc29ydEtleXMucHVzaChbZmllbGQsIGRpcmVjdGlvbiA9PT0gJ2Rlc2MnXSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlciByZXN1bHRzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeSAtIFdoZXJlIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7UXVlcnlCdWlsZGVyfSBSZXR1cm5zIGN1cnJlbnQgaW5zdGFuY2UgdG8gYmUgY2hhaW5lZFxuICAgKi9cbiAgd2hlcmUgKHF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkuZmluZChxdWVyeSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCByZXN1bHRzXG4gICAqIEBwYXJhbSB7KE9iamVjdHxzdHJpbmcpfSBxdWVyeSAtIFNlYXJjaCBxdWVyeSBvYmplY3Qgb3IgZmllbGQgb3Igc2VhcmNoIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSBvZiBzZWFyY2ggKG1lYW5zIHF1ZXJ5IGVxdWFscyB0byBmaWVsZCkuXG4gICAqIEByZXR1cm5zIHtRdWVyeUJ1aWxkZXJ9IFJldHVybnMgY3VycmVudCBpbnN0YW5jZSB0byBiZSBjaGFpbmVkXG4gICAqL1xuICBzZWFyY2ggKHF1ZXJ5LCB2YWx1ZSkge1xuICAgIC8vIFBhc3NpbmcgYW4gZW1wdHkgb3IgZmFsc2V5IHZhbHVlIGFzIHF1ZXJ5IHdpbGwgYXZvaWQgdHJpZ2dlcmluZyBhIHNlYXJjaCB0byBhbGxvdyBvcHRpb25hbCBjaGFpbmluZ1xuICAgIGlmICghcXVlcnkpIHsgcmV0dXJuIHRoaXMgfVxuXG4gICAgbGV0ICRmdHNcblxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAkZnRzID0gcXVlcnlcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAkZnRzID0ge1xuICAgICAgICBxdWVyeToge1xuICAgICAgICAgIHR5cGU6ICdtYXRjaCcsXG4gICAgICAgICAgZmllbGQ6IHF1ZXJ5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHByZWZpeF9sZW5ndGg6IDEsXG4gICAgICAgICAgZnV6emluZXNzOiAxLFxuICAgICAgICAgIGV4dGVuZGVkOiB0cnVlLFxuICAgICAgICAgIG1pbmltdW1fc2hvdWxkX21hdGNoOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJGZ0cyA9IHtcbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgc2hvdWxkOiB0aGlzLm9wdGlvbnMuZnVsbFRleHRTZWFyY2hGaWVsZHMubWFwKGZpZWxkID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnbWF0Y2gnLFxuICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICB2YWx1ZTogcXVlcnksXG4gICAgICAgICAgICBwcmVmaXhfbGVuZ3RoOiAxLFxuICAgICAgICAgICAgb3BlcmF0b3I6ICdhbmQnLFxuICAgICAgICAgICAgbWluaW11bV9zaG91bGRfbWF0Y2g6IDEsXG4gICAgICAgICAgICBmdXp6aW5lc3M6IDEsXG4gICAgICAgICAgICBleHRlbmRlZDogdHJ1ZVxuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkuZmluZCh7ICRmdHMgfSkuc29ydEJ5U2NvcmluZygpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFN1cnJvdW5kIHJlc3VsdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNsdWdPclBhdGggLSBTbHVnIG9yIHBhdGggb2YgdGhlIGZpbGUgdG8gc3Vycm91bmQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBzdXJyb3VuZCAoYmVmb3JlIC8gYWZ0ZXIpLlxuICAgKiBAcmV0dXJucyB7UXVlcnlCdWlsZGVyfSBSZXR1cm5zIGN1cnJlbnQgaW5zdGFuY2UgdG8gYmUgY2hhaW5lZFxuICAgKi9cbiAgc3Vycm91bmQgKHNsdWdPclBhdGgsIHsgYmVmb3JlID0gMSwgYWZ0ZXIgPSAxIH0gPSB7fSkge1xuICAgIGNvbnN0IF9rZXkgPSBzbHVnT3JQYXRoLmluZGV4T2YoJy8nKSA9PT0gMCA/ICdwYXRoJyA6ICdzbHVnJ1xuXG4gICAgLy8gQWRkIHNsdWcgb3IgcGF0aCB0byBvbmx5S2V5cyBpZiBvbmx5IG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlXG4gICAgaWYgKHRoaXMub25seUtleXMpIHtcbiAgICAgIHRoaXMub25seUtleXMucHVzaChfa2V5KVxuICAgIH1cbiAgICAvLyBSZW1vdmUgc2x1ZyBvciBwYXRoIGZyb20gd2l0aG91dEtleXMgaWYgd2l0aG91dCBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZVxuICAgIGlmICh0aGlzLndpdGhvdXRLZXlzKSB7XG4gICAgICB0aGlzLndpdGhvdXRLZXlzID0gdGhpcy53aXRob3V0S2V5cy5maWx0ZXIoa2V5ID0+IGtleSAhPT0gX2tleSlcbiAgICB9XG5cbiAgICBjb25zdCBmbiA9IChkYXRhKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGRhdGEuZmluZEluZGV4KGl0ZW0gPT4gaXRlbVtfa2V5XSA9PT0gc2x1Z09yUGF0aClcbiAgICAgIGNvbnN0IHNsaWNlID0gbmV3IEFycmF5KGJlZm9yZSArIGFmdGVyKS5maWxsKG51bGwsIDApXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBzbGljZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmV2U2xpY2UgPSBkYXRhLnNsaWNlKGluZGV4IC0gYmVmb3JlLCBpbmRleClcbiAgICAgIGNvbnN0IG5leHRTbGljZSA9IGRhdGEuc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDEgKyBhZnRlcilcblxuICAgICAgbGV0IHByZXZJbmRleCA9IDBcbiAgICAgIGZvciAobGV0IGkgPSBiZWZvcmUgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzbGljZVtpXSA9IHByZXZTbGljZVtwcmV2SW5kZXhdIHx8IG51bGxcbiAgICAgICAgcHJldkluZGV4KytcbiAgICAgIH1cblxuICAgICAgbGV0IG5leHRJbmRleCA9IDBcbiAgICAgIGZvciAobGV0IGkgPSBiZWZvcmU7IGkgPD0gYWZ0ZXI7IGkrKykge1xuICAgICAgICBzbGljZVtpXSA9IG5leHRTbGljZVtuZXh0SW5kZXhdIHx8IG51bGxcbiAgICAgICAgbmV4dEluZGV4KytcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsaWNlXG4gICAgfVxuXG4gICAgdGhpcy5wb3N0cHJvY2Vzcy5wdXNoKGZuKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogTGltaXQgbnVtYmVyIG9mIHJlc3VsdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBMaW1pdCBudW1iZXIuXG4gICAqIEByZXR1cm5zIHtRdWVyeUJ1aWxkZXJ9IFJldHVybnMgY3VycmVudCBpbnN0YW5jZSB0byBiZSBjaGFpbmVkXG4gICAqL1xuICBsaW1pdCAobikge1xuICAgIGlmICh0eXBlb2YgbiA9PT0gJ3N0cmluZycpIHsgbiA9IHBhcnNlSW50KG4pIH1cblxuICAgIHRoaXMubGltaXROID0gblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2tpcCBudW1iZXIgb2YgcmVzdWx0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIFNraXAgbnVtYmVyLlxuICAgKiBAcmV0dXJucyB7UXVlcnlCdWlsZGVyfSBSZXR1cm5zIGN1cnJlbnQgaW5zdGFuY2UgdG8gYmUgY2hhaW5lZFxuICAgKi9cbiAgc2tpcCAobikge1xuICAgIGlmICh0eXBlb2YgbiA9PT0gJ3N0cmluZycpIHsgbiA9IHBhcnNlSW50KG4pIH1cblxuICAgIHRoaXMuc2tpcE4gPSBuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0IGRhdGEgYW5kIGFwcGx5IHByb2Nlc3MgZmlsdGVyc1xuICAgKiBAcmV0dXJucyB7KE9iamVjdHxBcnJheSl9IFJldHVybnMgcHJvY2Vzc2VkIGRhdGFcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIGZldGNoICgpIHtcbiAgICBpZiAodGhpcy5zb3J0S2V5cyAmJiB0aGlzLnNvcnRLZXlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkuY29tcG91bmRzb3J0KHRoaXMuc29ydEtleXMpXG4gICAgfVxuICAgIGlmICh0aGlzLnNraXBOKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeS5vZmZzZXQodGhpcy5za2lwTilcbiAgICB9XG4gICAgaWYgKHRoaXMubGltaXROKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeS5saW1pdCh0aGlzLmxpbWl0TilcbiAgICB9XG4gICAgLy8gQ29sbGVjdCBkYXRhIHdpdGhvdXQgbWV0YSBmaWVsZHNcbiAgICBsZXQgZGF0YSA9IHRoaXMucXVlcnkuZGF0YSh7IHJlbW92ZU1ldGE6IHRydWUgfSlcbiAgICAvLyBIYW5kbGUgb25seSBrZXlzXG4gICAgaWYgKHRoaXMub25seUtleXMpIHtcbiAgICAgIC8vIEFkZCBgcGF0aGAgYW5kIGBleHRlbnNpb25gIHRvIG9ubHlLZXlzIGlmIHdhdGNoIHRvIGVuc3VyZSBsaXZlIGVkaXRcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2F0Y2gpIHtcbiAgICAgICAgdGhpcy5vbmx5S2V5cy5wdXNoKCdwYXRoJywgJ2V4dGVuc2lvbicpXG4gICAgICB9XG4gICAgICAvLyBNYXAgZGF0YSBhbmQgcmV0dXJucyBvYmplY3QgcGlja2VkIGJ5IGtleXNcbiAgICAgIGNvbnN0IGZuID0gZGF0YSA9PiBkYXRhLm1hcChpdGVtID0+IHBpY2soaXRlbSwgdGhpcy5vbmx5S2V5cykpXG4gICAgICAvLyBBcHBseSBwaWNrIGR1cmluZyBwb3N0cHJvY2Vzc1xuICAgICAgdGhpcy5wb3N0cHJvY2Vzcy51bnNoaWZ0KGZuKVxuICAgIH1cbiAgICAvLyBIYW5kbGUgd2l0aG91dCBrZXlzXG4gICAgaWYgKHRoaXMud2l0aG91dEtleXMpIHtcbiAgICAgIC8vIFJlbW92ZSBgcGF0aGAgYW5kIGBleHRlbnNpb25gIGZyb20gd2l0aG91dEtleXMgaWYgd2F0Y2ggdG8gZW5zdXJlIGxpdmUgZWRpdFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy53YXRjaCkge1xuICAgICAgICB0aGlzLndpdGhvdXRLZXlzID0gdGhpcy53aXRob3V0S2V5cy5maWx0ZXIoa2V5ID0+ICFbJ3BhdGgnLCAnZXh0ZW5zaW9uJ10uaW5jbHVkZXMoa2V5KSlcbiAgICAgIH1cbiAgICAgIC8vIE1hcCBkYXRhIGFuZCByZXR1cm5zIG9iamVjdCBwaWNrZWQgYnkga2V5c1xuICAgICAgY29uc3QgZm4gPSBkYXRhID0+IGRhdGEubWFwKGl0ZW0gPT4gb21pdChpdGVtLCB0aGlzLndpdGhvdXRLZXlzKSlcbiAgICAgIC8vIEFwcGx5IHBpY2sgZHVyaW5nIHBvc3Rwcm9jZXNzXG4gICAgICB0aGlzLnBvc3Rwcm9jZXNzLnVuc2hpZnQoZm4pXG4gICAgfVxuICAgIC8vIEFwcGx5IHBvc3Rwcm9jZXNzIGZucyB0byBkYXRhXG4gICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLnBvc3Rwcm9jZXNzKSB7XG4gICAgICBkYXRhID0gZm4oZGF0YSlcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLnBhdGh9IG5vdCBmb3VuZGApXG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUJ1aWxkZXJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///453\n')},454:function(module,exports){eval('function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nmodule.exports = _classCallCheck;\nmodule.exports["default"] = module.exports, module.exports.__esModule = true;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcz85NzBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI0NTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///454\n')},455:function(module,exports){eval('function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;\nmodule.exports["default"] = module.exports, module.exports.__esModule = true;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcz81YmMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNDU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///455\n')},456:function(module,exports){eval('function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\nmodule.exports["default"] = module.exports, module.exports.__esModule = true;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcz85NTIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI0NTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///456\n')},457:function(module,exports,__webpack_require__){eval('(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== \'undefined\' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === \'object\' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, \'default\', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != \'string\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ComparatorMap; });\n/* unused harmony export CreateJavascriptComparator */\n/* unused harmony export CreateAbstractJavascriptComparator */\n/* unused harmony export CreateAbstractDateJavascriptComparator */\n/* unused harmony export CreateLokiComparator */\n/* harmony import */ var _operator_packages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/**\n * This file contains LokiOperatorPackages, RangedIndex and Comparator interfaces, as well as\n * global map object instances for registered LokiOperatorPackages, RangedIndex implementations, and Comparator functions\n */\n\n/** Map/Register of named ILokiComparer functions returning -1, 0, 1 for lt/eq/gt assertions for two passed parameters */\nlet ComparatorMap = {\n    "js": CreateJavascriptComparator(),\n    "abstract-js": CreateAbstractJavascriptComparator(),\n    "abstract-date": CreateAbstractDateJavascriptComparator(),\n    "loki": CreateLokiComparator()\n};\n/** Typescript-friendly factory for strongly typed \'js\' comparators */\nfunction CreateJavascriptComparator() {\n    return (val, val2) => {\n        if (val === val2)\n            return 0;\n        if (val < val2)\n            return -1;\n        return 1;\n    };\n}\n/** Typescript-friendly factory for strongly typed \'abstract js\' comparators */\nfunction CreateAbstractJavascriptComparator() {\n    return (val, val2) => {\n        if (val == val2)\n            return 0;\n        if (val < val2)\n            return -1;\n        return 1;\n    };\n}\n/**\n * Comparator which attempts to deal with deal with dates at comparator level.\n * Should work for dates in any of the object, string, and number formats\n */\nfunction CreateAbstractDateJavascriptComparator() {\n    return (val, val2) => {\n        let v1 = (new Date(val).toISOString());\n        let v2 = (new Date(val2).toISOString());\n        if (v1 == v2)\n            return 0;\n        if (v1 < v2)\n            return -1;\n        return 1;\n    };\n}\n/** Typescript-friendly factory for strongly typed \'loki\' comparators */\nfunction CreateLokiComparator() {\n    return (val, val2) => {\n        if (Object(_operator_packages__WEBPACK_IMPORTED_MODULE_0__[/* aeqHelper */ "b"])(val, val2))\n            return 0;\n        if (Object(_operator_packages__WEBPACK_IMPORTED_MODULE_0__[/* ltHelper */ "c"])(val, val2, false))\n            return -1;\n        return 1;\n    };\n}\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PLUGINS; });\nfunction getGlobal() {\n    let glob;\n    (function (global) {\n        glob = global;\n    })(global !== undefined && global || this);\n    return glob;\n}\nfunction create() {\n    const global = getGlobal();\n    const sym = Symbol.for("LOKI");\n    if (global[sym] === undefined) {\n        global[sym] = {};\n    }\n    return global[sym];\n}\n/**\n * @hidden\n */\nconst PLUGINS = create();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return aeqHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ltHelper; });\n/* unused harmony export gtHelper */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return sortHelper; });\n/* unused harmony export LokiOperatorPackage */\n/* unused harmony export LokiAbstractOperatorPackage */\n/* unused harmony export ComparatorOperatorPackage */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LokiOperatorPackageMap; });\n/**\n * Helper function for determining \'loki\' abstract equality which is a little more abstract than ==\n *     aeqHelper(5, \'5\') === true\n *     aeqHelper(5.0, \'5\') === true\n *     aeqHelper(new Date("1/1/2011"), new Date("1/1/2011")) === true\n *     aeqHelper({a:1}, {z:4}) === true (all objects sorted equally)\n *     aeqHelper([1, 2, 3], [1, 3]) === false\n *     aeqHelper([1, 2, 3], [1, 2, 3]) === true\n *     aeqHelper(undefined, null) === true\n * @param {any} prop1\n * @param {any} prop2\n * @returns {boolean}\n * @hidden\n */\nfunction aeqHelper(prop1, prop2) {\n    if (prop1 === prop2)\n        return true;\n    // \'falsy\' and Boolean handling\n    if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        let t1;\n        let t2;\n        // dates and NaN conditions (typed dates before serialization)\n        switch (prop1) {\n            case undefined:\n                t1 = 1;\n                break;\n            case null:\n                t1 = 1;\n                break;\n            case false:\n                t1 = 3;\n                break;\n            case true:\n                t1 = 4;\n                break;\n            case "":\n                t1 = 5;\n                break;\n            default:\n                t1 = (prop1 === prop1) ? 9 : 0;\n                break;\n        }\n        switch (prop2) {\n            case undefined:\n                t2 = 1;\n                break;\n            case null:\n                t2 = 1;\n                break;\n            case false:\n                t2 = 3;\n                break;\n            case true:\n                t2 = 4;\n                break;\n            case "":\n                t2 = 5;\n                break;\n            default:\n                t2 = (prop2 === prop2) ? 9 : 0;\n                break;\n        }\n        // one or both is edge case\n        if (t1 !== 9 || t2 !== 9) {\n            return (t1 === t2);\n        }\n    }\n    // Handle \'Number-like\' comparisons\n    let cv1 = Number(prop1);\n    let cv2 = Number(prop2);\n    // if one or both are \'number-like\'...\n    if (cv1 === cv1 || cv2 === cv2) {\n        return (cv1 === cv2);\n    }\n    // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n    cv1 = prop1.toString();\n    cv2 = prop2.toString();\n    return (cv1 == cv2);\n}\n/**\n * Helper function for determining \'less-than\' conditions for ops, sorting, and binary indices.\n *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n * @hidden\n */\nfunction ltHelper(prop1, prop2, equal) {\n    // if one of the params is falsy or strictly true or not equal to itself\n    // 0, 0.0, "", NaN, null, undefined, not defined, false, true\n    if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        let t1;\n        let t2;\n        switch (prop1) {\n            case undefined:\n                t1 = 1;\n                break;\n            case null:\n                t1 = 1;\n                break;\n            case false:\n                t1 = 3;\n                break;\n            case true:\n                t1 = 4;\n                break;\n            case "":\n                t1 = 5;\n                break;\n            // if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null\n            default:\n                t1 = (prop1 === prop1) ? 9 : 0;\n                break;\n        }\n        switch (prop2) {\n            case undefined:\n                t2 = 1;\n                break;\n            case null:\n                t2 = 1;\n                break;\n            case false:\n                t2 = 3;\n                break;\n            case true:\n                t2 = 4;\n                break;\n            case "":\n                t2 = 5;\n                break;\n            default:\n                t2 = (prop2 === prop2) ? 9 : 0;\n                break;\n        }\n        // one or both is edge case\n        if (t1 !== 9 || t2 !== 9) {\n            return (t1 === t2) ? equal : (t1 < t2);\n        }\n    }\n    // if both are numbers (string encoded or not), compare as numbers\n    let cv1 = Number(prop1);\n    let cv2 = Number(prop2);\n    if (cv1 === cv1 && cv2 === cv2) {\n        if (cv1 < cv2)\n            return true;\n        if (cv1 > cv2)\n            return false;\n        return equal;\n    }\n    if (cv1 === cv1 && cv2 !== cv2) {\n        return true;\n    }\n    if (cv2 === cv2 && cv1 !== cv1) {\n        return false;\n    }\n    if (prop1 < prop2)\n        return true;\n    if (prop1 > prop2)\n        return false;\n    if (prop1 == prop2)\n        return equal;\n    // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n    cv1 = prop1.toString();\n    cv2 = prop2.toString();\n    if (cv1 < cv2) {\n        return true;\n    }\n    if (cv1 == cv2) {\n        return equal;\n    }\n    return false;\n}\n/**\n * @hidden\n * @param {any} prop1\n * @param {any} prop2\n * @param {boolean} equal\n * @returns {boolean}\n */\nfunction gtHelper(prop1, prop2, equal) {\n    // \'falsy\' and Boolean handling\n    if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        let t1;\n        let t2;\n        switch (prop1) {\n            case undefined:\n                t1 = 1;\n                break;\n            case null:\n                t1 = 1;\n                break;\n            case false:\n                t1 = 3;\n                break;\n            case true:\n                t1 = 4;\n                break;\n            case "":\n                t1 = 5;\n                break;\n            // NaN 0\n            default:\n                t1 = (prop1 === prop1) ? 9 : 0;\n                break;\n        }\n        switch (prop2) {\n            case undefined:\n                t2 = 1;\n                break;\n            case null:\n                t2 = 1;\n                break;\n            case false:\n                t2 = 3;\n                break;\n            case true:\n                t2 = 4;\n                break;\n            case "":\n                t2 = 5;\n                break;\n            default:\n                t2 = (prop2 === prop2) ? 9 : 0;\n                break;\n        }\n        // one or both is edge case\n        if (t1 !== 9 || t2 !== 9) {\n            return (t1 === t2) ? equal : (t1 > t2);\n        }\n    }\n    // if both are numbers (string encoded or not), compare as numbers\n    let cv1 = Number(prop1);\n    let cv2 = Number(prop2);\n    if (cv1 === cv1 && cv2 === cv2) {\n        if (cv1 > cv2)\n            return true;\n        if (cv1 < cv2)\n            return false;\n        return equal;\n    }\n    if (cv1 === cv1 && cv2 !== cv2) {\n        return false;\n    }\n    if (cv2 === cv2 && cv1 !== cv1) {\n        return true;\n    }\n    if (prop1 > prop2)\n        return true;\n    if (prop1 < prop2)\n        return false;\n    if (prop1 == prop2)\n        return equal;\n    // not strict equal nor less than nor gt so must be dates or mixed types\n    // convert to string and use that to compare\n    cv1 = prop1.toString();\n    cv2 = prop2.toString();\n    if (cv1 > cv2) {\n        return true;\n    }\n    if (cv1 == cv2) {\n        return equal;\n    }\n    return false;\n}\n/**\n * @param {any} prop1\n * @param {any} prop2\n * @param {boolean} descending\n * @returns {number}\n * @hidden\n */\nfunction sortHelper(prop1, prop2, descending) {\n    if (aeqHelper(prop1, prop2)) {\n        return 0;\n    }\n    if (ltHelper(prop1, prop2, false)) {\n        return descending ? 1 : -1;\n    }\n    if (gtHelper(prop1, prop2, false)) {\n        return descending ? -1 : 1;\n    }\n    // not lt, not gt so implied equality-- date compatible\n    return 0;\n}\n/**\n * Default implementation of LokiOperatorPackage, using fastest javascript comparison operators.\n */\nclass LokiOperatorPackage {\n    // comparison operators\n    // a is the value in the collection\n    // b is the query value\n    $eq(a, b) {\n        return a === b;\n    }\n    $ne(a, b) {\n        return a !== b;\n    }\n    $gt(a, b) {\n        return a > b;\n    }\n    $gte(a, b) {\n        return a >= b;\n    }\n    $lt(a, b) {\n        return a < b;\n    }\n    $lte(a, b) {\n        return a <= b;\n    }\n    $between(a, range) {\n        if (a === undefined || a === null)\n            return false;\n        return a >= range[0] && a <= range[1];\n    }\n    $in(a, b) {\n        return b.indexOf(a) !== -1;\n    }\n    $nin(a, b) {\n        return b.indexOf(a) === -1;\n    }\n    $keyin(a, b) {\n        return a in b;\n    }\n    $nkeyin(a, b) {\n        return !(a in b);\n    }\n    $definedin(a, b) {\n        return b[a] !== undefined;\n    }\n    $undefinedin(a, b) {\n        return b[a] === undefined;\n    }\n    $regex(a, b) {\n        return b.test(a);\n    }\n    $containsNone(a, b) {\n        return !this.$containsAny(a, b);\n    }\n    $containsAny(a, b) {\n        const checkFn = this.containsCheckFn(a);\n        if (checkFn !== null) {\n            return (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n        }\n        return false;\n    }\n    $contains(a, b) {\n        const checkFn = this.containsCheckFn(a);\n        if (checkFn !== null) {\n            return (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n        }\n        return false;\n    }\n    $type(a, b) {\n        let type = typeof a;\n        if (type === "object") {\n            if (Array.isArray(a)) {\n                type = "array";\n            }\n            else if (a instanceof Date) {\n                type = "date";\n            }\n        }\n        return (typeof b !== "object") ? (type === b) : this.doQueryOp(type, b);\n    }\n    $finite(a, b) {\n        return (b === isFinite(a));\n    }\n    $size(a, b) {\n        if (Array.isArray(a)) {\n            return (typeof b !== "object") ? (a.length === b) : this.doQueryOp(a.length, b);\n        }\n        return false;\n    }\n    $len(a, b) {\n        if (typeof a === "string") {\n            return (typeof b !== "object") ? (a.length === b) : this.doQueryOp(a.length, b);\n        }\n        return false;\n    }\n    $where(a, b) {\n        return b(a) === true;\n    }\n    // field-level logical operators\n    // a is the value in the collection\n    // b is the nested query operation (for \'$not\')\n    //   or an array of nested query operations (for \'$and\' and \'$or\')\n    $not(a, b) {\n        return !this.doQueryOp(a, b);\n    }\n    $and(a, b) {\n        for (let idx = 0, len = b.length; idx < len; idx++) {\n            if (!this.doQueryOp(a, b[idx])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    $or(a, b) {\n        for (let idx = 0, len = b.length; idx < len; idx++) {\n            if (this.doQueryOp(a, b[idx])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    doQueryOp(val, op) {\n        for (let p in op) {\n            if (Object.hasOwnProperty.call(op, p)) {\n                return this[p](val, op[p]);\n            }\n        }\n        return false;\n    }\n    containsCheckFn(a) {\n        if (typeof a === "string" || Array.isArray(a)) {\n            return (b) => a.indexOf(b) !== -1;\n        }\n        else if (typeof a === "object" && a !== null) {\n            return (b) => Object.hasOwnProperty.call(a, b);\n        }\n        return null;\n    }\n}\n/**\n * LokiOperatorPackage which utilizes abstract \'loki\' comparisons for basic relational equality op implementations.\n */\nclass LokiAbstractOperatorPackage extends LokiOperatorPackage {\n    constructor() {\n        super();\n    }\n    $eq(a, b) {\n        return aeqHelper(a, b);\n    }\n    $ne(a, b) {\n        return !aeqHelper(a, b);\n    }\n    $gt(a, b) {\n        return gtHelper(a, b, false);\n    }\n    $gte(a, b) {\n        return gtHelper(a, b, true);\n    }\n    $lt(a, b) {\n        return ltHelper(a, b, false);\n    }\n    $lte(a, b) {\n        return ltHelper(a, b, true);\n    }\n    $between(a, range) {\n        if (a === undefined || a === null)\n            return false;\n        return gtHelper(a, range[0], true) && ltHelper(a, range[1], true);\n    }\n}\n/**\n * LokiOperatorPackage which utilizes provided comparator for basic relational equality op implementations.\n */\nclass ComparatorOperatorPackage extends LokiOperatorPackage {\n    constructor(comparator) {\n        super();\n        this.comparator = comparator;\n    }\n    $eq(a, b) {\n        return this.comparator(a, b) === 0;\n    }\n    $ne(a, b) {\n        return this.comparator(a, b) !== 0;\n    }\n    $gt(a, b) {\n        return this.comparator(a, b) === 1;\n    }\n    $gte(a, b) {\n        return this.comparator(a, b) > -1;\n    }\n    $lt(a, b) {\n        return this.comparator(a, b) === -1;\n    }\n    $lte(a, b) {\n        return this.comparator(a, b) < 1;\n    }\n    $between(a, range) {\n        if (a === undefined || a === null)\n            return false;\n        return this.comparator(a, range[0]) > -1 && this.comparator(a, range[1]) < 1;\n    }\n}\n/**\n * Map/Register of named LokiOperatorPackages which implement all unindexed query ops within \'find\' query objects\n */\nlet LokiOperatorPackageMap = {\n    "js": new LokiOperatorPackage(),\n    "loki": new LokiAbstractOperatorPackage()\n};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n\n// EXTERNAL MODULE: ./packages/loki/src/event_emitter.ts\nvar event_emitter = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./packages/loki/src/unique_index.ts\nclass UniqueIndex {\n    /**\n     * Constructs an unique index object.\n     * @param {string} propertyField - the property field to index\n     */\n    constructor(propertyField) {\n        this._field = propertyField;\n        this._lokiMap = {};\n        this._valMap = {};\n    }\n    /**\n     * Sets a document\'s unique index.\n     * @param {number} id loki id to associate with value\n     * @param {*} value  value to associate with id\n     */\n    set(id, value) {\n        // unique index should not include null/undefined values\n        if (value !== null && value !== undefined) {\n            if (value in this._lokiMap) {\n                throw new Error("Duplicate key for property " + this._field + ": " + value);\n            }\n            if (id in this._valMap) {\n                throw new Error("Duplicate key for property $loki : " + id);\n            }\n            this._lokiMap[value] = id;\n            this._valMap[id] = value;\n        }\n    }\n    /**\n     * Returns the $loki id of an unique value.\n     * @param {*} value the value to retrieve a loki id match for\n     */\n    get(value) {\n        return this._lokiMap[value];\n    }\n    /**\n     * Updates a document\'s unique index.\n     * @param {number} id (loki) id of document to update the value to\n     * @param {*} value value to associate with loki id\n     */\n    update(id, value) {\n        // if the value has not changed, do nothing\n        if (value === this._valMap[id]) {\n            return;\n        }\n        // the value must have changed, so check if new value already exists\n        if (value in this._lokiMap) {\n            throw new Error("Duplicate key for property " + this._field + ": " + value);\n        }\n        this.remove(id);\n        this.set(id, value);\n    }\n    /**\n     * Removes an unique index.\n     * @param {number} id (loki) id to remove from index\n     */\n    remove(id) {\n        if (!(id in this._valMap)) {\n            throw new Error("Key is not in unique index: " + this._field);\n        }\n        let oldValue = this._valMap[id];\n        delete this._lokiMap[oldValue];\n        delete this._valMap[id];\n    }\n    /**\n     * Clears the unique index.\n     */\n    clear() {\n        this._lokiMap = {};\n        this._valMap = {};\n    }\n}\n\n// CONCATENATED MODULE: ./packages/loki/src/clone.ts\nfunction add(copy, key, value) {\n    if (copy instanceof Array) {\n        copy.push(value);\n        return copy[copy.length - 1];\n    }\n    else if (copy instanceof Object) {\n        copy[key] = value;\n        return copy[key];\n    }\n}\nfunction walk(target, copy) {\n    for (let key in target) {\n        let obj = target[key];\n        if (obj instanceof Date) {\n            let value = new Date(obj.getTime());\n            add(copy, key, value);\n        }\n        else if (obj instanceof Function) {\n            let value = obj;\n            add(copy, key, value);\n        }\n        else if (obj instanceof Array) {\n            let value = [];\n            let last = add(copy, key, value);\n            walk(obj, last);\n        }\n        else if (obj instanceof Object) {\n            let value = {};\n            let last = add(copy, key, value);\n            walk(obj, last);\n        }\n        else {\n            let value = obj;\n            add(copy, key, value);\n        }\n    }\n}\n// Deep copy from Simeon Velichkov.\n/**\n * @param target\n * @returns {any}\n */\nfunction deepCopy(target) {\n    if (/number|string|boolean/.test(typeof target)) {\n        return target;\n    }\n    else if (target instanceof Date) {\n        return new Date(target.getTime());\n    }\n    const copy = (target instanceof Array) ? [] : {};\n    walk(target, copy);\n    return copy;\n}\n/**\n * @hidden\n */\nfunction clone(data, method = "parse-stringify") {\n    if (data === null || data === undefined) {\n        return null;\n    }\n    let cloned;\n    switch (method) {\n        case "parse-stringify":\n            cloned = JSON.parse(JSON.stringify(data));\n            break;\n        case "deep":\n            cloned = deepCopy(data);\n            break;\n        case "shallow":\n            cloned = Object.create(data.constructor.prototype);\n            Object.assign(cloned, data);\n            break;\n        case "shallow-recurse":\n            // shallow clone top level properties\n            cloned = clone(data, "shallow");\n            const keys = Object.keys(data);\n            // for each of the top level properties which are object literals, recursively shallow copy\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                if (typeof data[key] === "object" && data[key].constructor.name === "Object") {\n                    cloned[key] = clone(data[key], "shallow-recurse");\n                }\n            }\n            break;\n        default:\n            break;\n    }\n    return cloned;\n}\n\n// EXTERNAL MODULE: ./packages/loki/src/operator_packages.ts\nvar operator_packages = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./packages/loki/src/comparators.ts\nvar comparators = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/loki/src/result_set.ts\n\n\n\n\n// used to recursively scan hierarchical transform step object for param substitution\nfunction resolveTransformObject(subObj, params, depth = 0) {\n    if (++depth >= 10) {\n        return subObj;\n    }\n    for (const prop in subObj) {\n        if (typeof subObj[prop] === "string" && subObj[prop].indexOf("[%lktxp]") === 0) {\n            const pname = subObj[prop].substring(8);\n            if (params[pname] !== undefined) {\n                subObj[prop] = params[pname];\n            }\n        }\n        else if (typeof subObj[prop] === "object") {\n            subObj[prop] = resolveTransformObject(subObj[prop], params, depth);\n        }\n    }\n    return subObj;\n}\n// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\nfunction resolveTransformParams(transform, params) {\n    if (params === undefined) {\n        return transform;\n    }\n    // iterate all steps in the transform array\n    const resolvedTransform = [];\n    for (let idx = 0; idx < transform.length; idx++) {\n        // clone transform so our scan/replace can operate directly on cloned transform\n        const clonedStep = clone(transform[idx], "shallow-recurse");\n        resolvedTransform.push(resolveTransformObject(clonedStep, params));\n    }\n    return resolvedTransform;\n}\n/**\n * @hidden\n */\n// if an op is registered in this object, our \'calculateRange\' can use it with our binary indices.\n// if the op is registered to a function, we will run that function/op as a 2nd pass filter on results.\n// those 2nd pass filter functions should be similar to LokiOps functions, accepting 2 vals to compare.\nconst indexedOps = {\n    $eq: true,\n    $dteq: true,\n    $gt: true,\n    $gte: true,\n    $lt: true,\n    $lte: true,\n    $in: true,\n    $between: true\n};\n/**\n * ResultSet class allowing chainable queries.  Intended to be instanced internally.\n *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n *\n * @example\n *    mycollection.chain()\n *      .find({ \'doors\' : 4 })\n *      .where(function(obj) { return obj.name === \'Toyota\' })\n *      .data();\n *\n * @param <TData> - the data type\n * @param <TNested> - nested properties of data type\n */\nclass result_set_ResultSet {\n    /**\n     * Constructor.\n     * @param {Collection} collection - the collection which this ResultSet will query against\n     */\n    constructor(collection) {\n        this._filteredRows = [];\n        this._filterInitialized = false;\n        // Holds the scoring result of the last full-text search.\n        this._scoring = null;\n        // retain reference to collection we are querying against\n        this._collection = collection;\n    }\n    /**\n     * Reset the ResultSet to its initial state.\n     * @returns {ResultSet} Reference to this ResultSet, for future chain operations.\n     */\n    reset() {\n        if (this._filteredRows.length > 0) {\n            this._filteredRows = [];\n        }\n        this._filterInitialized = false;\n        return this;\n    }\n    /**\n     * Override of toJSON to avoid circular references\n     */\n    toJSON() {\n        const copy = this.copy();\n        copy._collection = null;\n        return copy;\n    }\n    /**\n     * Allows you to limit the number of documents passed to next chain operation.\n     * A ResultSet copy() is made to avoid altering original ResultSet.\n     * @param {int} qty - The number of documents to return.\n     * @returns {ResultSet} Returns a copy of the ResultSet, limited by qty, for subsequent chain ops.\n     */\n    limit(qty) {\n        // if this has no filters applied, we need to populate filteredRows first\n        if (!this._filterInitialized && this._filteredRows.length === 0) {\n            this._filteredRows = this._collection._prepareFullDocIndex();\n        }\n        this._filteredRows = this._filteredRows.slice(0, qty);\n        this._filterInitialized = true;\n        return this;\n    }\n    /**\n     * Used for skipping \'pos\' number of documents in the ResultSet.\n     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n     * @returns {ResultSet} Returns a copy of the ResultSet, containing docs starting at \'pos\' for subsequent chain ops.\n     */\n    offset(pos) {\n        // if this has no filters applied, we need to populate filteredRows first\n        if (!this._filterInitialized && this._filteredRows.length === 0) {\n            this._filteredRows = this._collection._prepareFullDocIndex();\n        }\n        this._filteredRows = this._filteredRows.slice(pos);\n        this._filterInitialized = true;\n        return this;\n    }\n    /**\n     * To support reuse of ResultSet in branched query situations.\n     * @returns {ResultSet} Returns a copy of the ResultSet (set) but the underlying document references will be the same.\n     */\n    copy() {\n        const result = new result_set_ResultSet(this._collection);\n        result._filteredRows = this._filteredRows.slice();\n        result._filterInitialized = this._filterInitialized;\n        return result;\n    }\n    /**\n     * Executes a named collection transform or raw array of transform steps against the ResultSet.\n     * @param {(string|array)} transform - name of collection transform or raw transform array\n     * @param {object} [parameters=] - object property hash of parameters, if the transform requires them.\n     * @returns {ResultSet} either (this) ResultSet or a clone of of this ResultSet (depending on steps)\n     */\n    transform(transform, parameters) {\n        // if transform is name, then do lookup first\n        if (typeof transform === "string") {\n            transform = this._collection._transforms[transform];\n        }\n        if (parameters !== undefined) {\n            transform = resolveTransformParams(transform, parameters);\n        }\n        let rs = this;\n        for (let idx = 0; idx < transform.length; idx++) {\n            const step = transform[idx];\n            switch (step.type) {\n                case "find":\n                    rs.find(step.value);\n                    break;\n                case "where":\n                    rs.where(step.value);\n                    break;\n                case "simplesort":\n                    rs.simplesort(step.property, step.options);\n                    break;\n                case "compoundsort":\n                    rs.compoundsort(step.value);\n                    break;\n                case "sort":\n                    rs.sort(step.value);\n                    break;\n                case "sortByScoring":\n                    rs.sortByScoring(step.desc);\n                    break;\n                case "limit":\n                    rs = rs.limit(step.value);\n                    break; // limit makes copy so update reference\n                case "offset":\n                    rs = rs.offset(step.value);\n                    break; // offset makes copy so update reference\n                case "map":\n                    rs = rs.map(step.value, step.dataOptions);\n                    break;\n                case "eqJoin":\n                    rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun, step.dataOptions);\n                    break;\n                // following cases break chain by returning array data so make any of these last in transform steps\n                case "mapReduce":\n                    rs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n                    break;\n                // following cases update documents in current filtered ResultSet (use carefully)\n                case "update":\n                    rs.update(step.value);\n                    break;\n                case "remove":\n                    rs.remove();\n                    break;\n                default:\n                    break;\n            }\n        }\n        return rs;\n    }\n    /**\n     * User supplied compare function is provided two documents to compare. (chainable)\n     * @example\n     *    rslt.sort(function(obj1, obj2) {\n       *      if (obj1.name === obj2.name) return 0;\n       *      if (obj1.name > obj2.name) return 1;\n       *      if (obj1.name < obj2.name) return -1;\n       *    });\n     * @param {function} comparefun - A javascript compare function used for sorting.\n     * @returns {ResultSet} Reference to this ResultSet, sorted, for future chain operations.\n     */\n    sort(comparefun) {\n        // if this has no filters applied, just we need to populate filteredRows first\n        if (!this._filterInitialized && this._filteredRows.length === 0) {\n            this._filteredRows = this._collection._prepareFullDocIndex();\n        }\n        const data = this._collection._data;\n        const wrappedComparer = (a, b) => comparefun(data[a], data[b]);\n        this._filteredRows.sort(wrappedComparer);\n        return this;\n    }\n    /**\n     * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n     * Sorting based on the same lt/gt helper functions used for binary indices.\n     * @param {string} propname - name of property to sort by.\n     * @param {boolean|object=} options - boolean for sort descending or options object\n     * @param {boolean} [options.desc=false] - whether to sort descending\n     * @param {string} [options.sortComparator] override default with name of comparator registered in ComparatorMap\n     * @returns {ResultSet} Reference to this ResultSet, sorted, for future chain operations.\n     */\n    simplesort(propname, options = { desc: false }) {\n        if (typeof options === "boolean") {\n            options = {\n                desc: options\n            };\n        }\n        if (!this._filterInitialized && this._collection._rangedIndexes.hasOwnProperty(propname)) {\n            let sortedIds = this._collection._rangedIndexes[propname].index.rangeRequest();\n            let dataPositions = [];\n            // until we refactor resultset to store $loki ids in filteredrows,\n            // we need to convert $loki ids to data array positions\n            for (let id of sortedIds) {\n                dataPositions.push(this._collection.get(id, true)[1]);\n            }\n            this._filteredRows = options.desc ? dataPositions.reverse() : dataPositions;\n            this._filterInitialized = true;\n            return this;\n        }\n        // if this has no filters applied, just we need to populate filteredRows first\n        if (!this._filterInitialized && this._filteredRows.length === 0) {\n            this._filteredRows = this._collection._prepareFullDocIndex();\n        }\n        const data = this._collection._data;\n        let comparator = (options.sortComparator) ?\n            comparators["a" /* ComparatorMap */][options.sortComparator] :\n            comparators["a" /* ComparatorMap */][this._collection._unindexedSortComparator];\n        const wrappedComparer = (a, b) => {\n            return comparator(data[a][propname], data[b][propname]);\n        };\n        this._filteredRows.sort(wrappedComparer);\n        if (options.desc) {\n            this._filteredRows.reverse();\n        }\n        return this;\n    }\n    /**\n     * Allows sorting a ResultSet based on multiple columns.\n     * @example\n     * // to sort by age and then name (both ascending)\n     * rs.compoundsort([\'age\', \'name\']);\n     * // to sort by age (ascending) and then by name (descending)\n     * rs.compoundsort([\'age\', [\'name\', true]);\n     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n     * @returns {ResultSet} Reference to this ResultSet, sorted, for future chain operations.\n     */\n    compoundsort(properties) {\n        if (properties.length === 0) {\n            throw new Error("Invalid call to compoundsort, need at least one property");\n        }\n        if (properties.length === 1) {\n            const prop = properties[0];\n            if (typeof prop === "string") {\n                return this.simplesort(prop, false);\n            }\n            else {\n                return this.simplesort(prop[0], prop[1]);\n            }\n        }\n        // unify the structure of \'properties\' to avoid checking it repeatedly while sorting\n        for (let i = 0, len = properties.length; i < len; i++) {\n            const prop = properties[i];\n            if (typeof prop === "string") {\n                properties[i] = [prop, false];\n            }\n        }\n        // if this has no filters applied, just we need to populate filteredRows first\n        if (!this._filterInitialized && this._filteredRows.length === 0) {\n            this._filteredRows = this._collection._prepareFullDocIndex();\n        }\n        const data = this._collection._data;\n        const wrappedComparer = (a, b) => this._compoundeval(properties, data[a], data[b]);\n        this._filteredRows.sort(wrappedComparer);\n        return this;\n    }\n    /**\n     * Helper function for compoundsort(), performing individual object comparisons\n     * @param {Array} properties - array of property names, in order, by which to evaluate sort order\n     * @param {object} obj1 - first object to compare\n     * @param {object} obj2 - second object to compare\n     * @returns {number} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n     */\n    _compoundeval(properties, obj1, obj2) {\n        for (let i = 0, len = properties.length; i < len; i++) {\n            const prop = properties[i];\n            const field = prop[0];\n            const res = Object(operator_packages["d" /* sortHelper */])(obj1[field], obj2[field], prop[1]);\n            if (res !== 0) {\n                return res;\n            }\n        }\n        return 0;\n    }\n    /**\n     * Sorts the ResultSet based on the last full-text-search scoring.\n     * @param {boolean} [ascending=false] - sort ascending\n     * @returns {ResultSet}\n     */\n    sortByScoring(ascending = false) {\n        if (this._scoring === null) {\n            throw new Error("No scoring available");\n        }\n        if (ascending) {\n            this._filteredRows.sort((a, b) => this._scoring[a].score - this._scoring[b].score);\n        }\n        else {\n            this._filteredRows.sort((a, b) => this._scoring[b].score - this._scoring[a].score);\n        }\n        return this;\n    }\n    /**\n     * Returns the scoring of the last full-text-search.\n     * @returns {ScoreResult[]}\n     */\n    getScoring() {\n        if (this._scoring === null) {\n            throw new Error("No scoring available");\n        }\n        const scoring = [];\n        for (let i = 0; i < this._filteredRows.length; i++) {\n            scoring.push(this._scoring[this._filteredRows[i]]);\n        }\n        return scoring;\n    }\n    /**\n     * Oversee the operation of OR\'ed query expressions.\n     * OR\'ed expression evaluation runs each expression individually against the full collection,\n     * and finally does a set OR on each expression\'s results.\n     * Each evaluation can utilize a binary index to prevent multiple linear array scans.\n     * @param {array} expressionArray - array of expressions\n     * @returns {ResultSet} this ResultSet for further chain ops.\n     */\n    findOr(expressionArray) {\n        const docset = [];\n        const idxset = [];\n        const origCount = this.count();\n        // If filter is already initialized, then we query against only those items already in filter.\n        // This means no index utilization for fields, so hopefully its filtered to a smallish filteredRows.\n        for (let ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n            // we need to branch existing query to run each filter separately and combine results\n            const fr = this.copy().find(expressionArray[ei])._filteredRows;\n            const frlen = fr.length;\n            // if the find operation did not reduce the initial set, then the initial set is the actual result\n            if (frlen === origCount) {\n                return this;\n            }\n            // add any document \'hits\'\n            for (let fri = 0; fri < frlen; fri++) {\n                const idx = fr[fri];\n                if (idxset[idx] === undefined) {\n                    idxset[idx] = true;\n                    docset.push(idx);\n                }\n            }\n        }\n        this._filteredRows = docset;\n        this._filterInitialized = true;\n        return this;\n    }\n    $or(expressionArray) {\n        return this.findOr(expressionArray);\n    }\n    /**\n     * Oversee the operation of AND\'ed query expressions.\n     * AND\'ed expression evaluation runs each expression progressively against the full collection,\n     * internally utilizing existing chained ResultSet functionality.\n     * Only the first filter can utilize a binary index.\n     * @param {array} expressionArray - array of expressions\n     * @returns {ResultSet} this ResultSet for further chain ops.\n     */\n    findAnd(expressionArray) {\n        // we have already implementing method chaining in this (our ResultSet class)\n        // so lets just progressively apply user supplied and filters\n        for (let i = 0, len = expressionArray.length; i < len; i++) {\n            if (this.count() === 0) {\n                return this;\n            }\n            this.find(expressionArray[i]);\n        }\n        return this;\n    }\n    $and(expressionArray) {\n        return this.findAnd(expressionArray);\n    }\n    /**\n     * Used for querying via a mongo-style query object.\n     *\n     * @param {object} query - A mongo-style query object used for filtering current results.\n     * @param {boolean} firstOnly - (Optional) Used by collection.findOne() - flag if this was invoked via findOne()\n     * @returns {ResultSet} this ResultSet for further chain ops.\n     */\n    find(query, firstOnly = false) {\n        if (this._collection._data.length === 0) {\n            this._filteredRows = [];\n            this._filterInitialized = true;\n            return this;\n        }\n        const queryObject = query || "getAll";\n        let property;\n        let queryObjectOp;\n        let value;\n        if (typeof queryObject === "object") {\n            let filters = [];\n            for (let p in queryObject) {\n                let obj = {};\n                obj[p] = queryObject[p];\n                filters.push(obj);\n                if (queryObject[p] !== undefined) {\n                    property = p;\n                    queryObjectOp = queryObject[p];\n                }\n            }\n            // if more than one expression in single query object,\n            // convert implicit $and to explicit $and\n            if (filters.length > 1) {\n                return this.find({ "$and": filters }, firstOnly);\n            }\n        }\n        // apply no filters if they want all\n        if (!property || queryObject === "getAll") {\n            if (firstOnly) {\n                this._filteredRows = (this._collection._data.length > 0) ? [0] : [];\n                this._filterInitialized = true;\n            }\n            return this;\n        }\n        // injecting $and and $or expression tree evaluation here.\n        if (property === "$and" || property === "$or") {\n            this[property](queryObjectOp);\n            // for chained find with firstOnly,\n            if (firstOnly && this._filteredRows.length > 1) {\n                this._filteredRows = this._filteredRows.slice(0, 1);\n            }\n            return this;\n        }\n        // see if query object is in shorthand mode (assuming eq operator)\n        let operator = "";\n        if (queryObjectOp === null || (typeof queryObjectOp !== "object" || queryObjectOp instanceof Date)) {\n            operator = "$eq";\n            value = queryObjectOp;\n        }\n        else if (typeof queryObjectOp === "object") {\n            for (let key in queryObjectOp) {\n                if (queryObjectOp[key] !== undefined) {\n                    operator = key;\n                    value = queryObjectOp[key];\n                    break;\n                }\n            }\n        }\n        else {\n            throw new Error("Do not know what you want to do.");\n        }\n        // for regex ops, precompile\n        if (operator === "$regex") {\n            if (Array.isArray(value)) {\n                value = new RegExp(value[0], value[1]);\n            }\n            else if (!(value instanceof RegExp)) {\n                value = new RegExp(value);\n            }\n        }\n        // if an index exists for the property being queried against, use it\n        // for now only enabling where it is the first filter applied and prop is indexed\n        const doIndexCheck = !this._filterInitialized;\n        let searchByIndex = false;\n        if (doIndexCheck && this._collection._rangedIndexes[property] && indexedOps[operator]) {\n            searchByIndex = true;\n        }\n        // the comparison function\n        const operatorPackage = operator_packages["a" /* LokiOperatorPackageMap */][this._collection._defaultLokiOperatorPackage];\n        // "shortcut" for collection data\n        const data = this._collection._data;\n        // Query executed differently depending on :\n        //    - whether the property being queried has an index defined\n        //    - if chained, we handle first pass differently for initial filteredRows[] population\n        //\n        // For performance reasons, each case has its own if block to minimize in-loop calculations\n        let result = [];\n        // If the filteredRows[] is already initialized, use it\n        if (this._filterInitialized) {\n            let filter = this._filteredRows;\n            if (property === "$fts") {\n                this._scoring = this._collection._fullTextSearch.search(queryObject.$fts);\n                let keys = Object.keys(this._scoring);\n                for (let i = 0; i < keys.length; i++) {\n                    if (filter.indexOf(+keys[i]) !== -1) {\n                        result.push(+keys[i]);\n                    }\n                }\n            }\n            else if (this._collection._constraints.unique[property] !== undefined && operator === "$eq") {\n                // convert back to position for filtered rows (until we refactor filteredrows to store $loki instead of data pos)\n                const id = this._collection._constraints.unique[property].get(value);\n                if (id !== undefined) {\n                    const row = this._collection.get(id, true)[1];\n                    if (filter.indexOf(row) !== -1) {\n                        result.push(row);\n                    }\n                }\n            }\n            else {\n                for (let i = 0; i < filter.length; i++) {\n                    let rowIdx = filter[i];\n                    // calling operator as method property of operator package preserves \'this\'\n                    if (operatorPackage[operator](data[rowIdx][property], value)) {\n                        result.push(rowIdx);\n                    }\n                }\n            }\n            this._filteredRows = result;\n            this._filterInitialized = true; // next time work against filteredRows[]\n            return this;\n        }\n        this._filteredRows = result;\n        this._filterInitialized = true; // next time work against filteredRows[]\n        if (property === "$fts") {\n            this._scoring = this._collection._fullTextSearch.search(queryObject.$fts);\n            let keys = Object.keys(this._scoring);\n            for (let i = 0; i < keys.length; i++) {\n                result.push(+keys[i]);\n            }\n            return this;\n        }\n        // Use unique constraint for search.\n        if (this._collection._constraints.unique[property] !== undefined && operator === "$eq") {\n            // convert back to position for filtered rows (until we refactor filteredrows to store $loki instead of data pos)\n            const id = this._collection._constraints.unique[property].get(value);\n            if (id !== undefined) {\n                result.push(this._collection.get(id, true)[1]);\n            }\n            return this;\n        }\n        // if not searching by index\n        if (!searchByIndex) {\n            // determine comparator to use for ops\n            for (let i = 0; i < data.length; i++) {\n                // calling operator as method property of operator package preserves \'this\'\n                if (operatorPackage[operator](data[i][property], value)) {\n                    result.push(i);\n                    if (firstOnly) {\n                        return this;\n                    }\n                }\n            }\n            return this;\n        }\n        // If we have a rangedIndex defined, use that and bail\n        if (this._collection._rangedIndexes[property]) {\n            if (operator === "$in") {\n                let ri = this._collection._rangedIndexes[property];\n                // iterate each $in array value\n                for (let val of value) {\n                    // request matches where val eq current iterated val\n                    let idResult = ri.index.rangeRequest({ op: "$eq", val: val });\n                    // for each result in match\n                    for (let id of idResult) {\n                        // convert $loki id to data position and add to result (filteredrows)\n                        result.push(this._collection.get(id, true)[1]);\n                    }\n                }\n                return this;\n            }\n            if (operator === "$between") {\n                let idResult = this._collection._rangedIndexes[property].index.rangeRequest({\n                    op: operator,\n                    val: value[0],\n                    high: value[1]\n                });\n                // for now we will have to \'shim\' the binary tree index\'s $loki ids back\n                // into data array indices, ideally i would like to repurpose filteredrows to use loki ids\n                for (let id of idResult) {\n                    result.push(this._collection.get(id, true)[1]);\n                }\n                return this;\n            }\n            let idResult = this._collection._rangedIndexes[property].index.rangeRequest({\n                op: operator,\n                val: value\n            });\n            // if our op requires \'second pass\'\n            if (indexedOps[operator] !== true) {\n                for (let id of idResult) {\n                    let pos = this._collection.get(id, true)[1];\n                    if (indexedOps[operator](data[pos][property], value)) {\n                        result.push(pos);\n                    }\n                }\n            }\n            else {\n                // for now we will have to \'shim\' the binary tree index\'s $loki ids back\n                // into data array indices, ideally i would like to repurpose filteredrows to use loki ids\n                for (let id of idResult) {\n                    result.push(this._collection.get(id, true)[1]);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Used for filtering via a javascript filter function.\n     * @param {function} fun - A javascript function used for filtering current results by.\n     * @returns {ResultSet} this ResultSet for further chain ops.\n     */\n    where(fun) {\n        let viewFunction;\n        let result = [];\n        if ("function" === typeof fun) {\n            viewFunction = fun;\n        }\n        else {\n            throw new TypeError("Argument is not a stored view or a function");\n        }\n        // If the filteredRows[] is already initialized, use it\n        if (this._filterInitialized) {\n            let j = this._filteredRows.length;\n            while (j--) {\n                if (viewFunction(this._collection._data[this._filteredRows[j]]) === true) {\n                    result.push(this._filteredRows[j]);\n                }\n            }\n            this._filteredRows = result;\n            return this;\n        }\n        // otherwise this is initial chained op, work against data, push into filteredRows[]\n        else {\n            let k = this._collection._data.length;\n            while (k--) {\n                if (viewFunction(this._collection._data[k]) === true) {\n                    result.push(k);\n                }\n            }\n            this._filteredRows = result;\n            this._filterInitialized = true;\n            return this;\n        }\n    }\n    /**\n     * Returns the number of documents in the ResultSet.\n     * @returns {number} The number of documents in the ResultSet.\n     */\n    count() {\n        if (this._filterInitialized) {\n            return this._filteredRows.length;\n        }\n        return this._collection.count();\n    }\n    /**\n     * Terminates the chain and returns array of filtered documents\n     * @param {object} options\n     * @param {boolean} [options.forceClones] - Allows forcing the return of cloned objects even when\n     *        the collection is not configured for clone object.\n     * @param {string} [options.forceCloneMethod] - Allows overriding the default or collection specified cloning method.\n     *        Possible values \'parse-stringify\', \'deep\', and \'shallow\' and\n     * @param {boolean} [options.removeMeta] - will force clones and strip $loki and meta properties from documents\n     *\n     * @returns {Array} Array of documents in the ResultSet\n     */\n    data(options = {}) {\n        let forceClones;\n        let forceCloneMethod;\n        let removeMeta;\n        ({\n            forceClones = false,\n            forceCloneMethod = this._collection._cloneMethod,\n            removeMeta = false\n        } = options);\n        let result = [];\n        let data = this._collection._data;\n        let obj;\n        let method;\n        // if user opts to strip meta, then force clones and use \'shallow\' if \'force\' options are not present\n        if (removeMeta && !forceClones) {\n            forceClones = true;\n            forceCloneMethod = "shallow";\n        }\n        // if collection has delta changes active, then force clones and use CloneMethod.DEEP for effective change tracking of nested objects\n        if (!this._collection._disableDeltaChangesApi) {\n            forceClones = true;\n            forceCloneMethod = "deep";\n        }\n        // if this has no filters applied, just return collection.data\n        if (!this._filterInitialized) {\n            if (this._filteredRows.length === 0) {\n                // determine whether we need to clone objects or not\n                if (this._collection._cloneObjects || forceClones) {\n                    method = forceCloneMethod;\n                    for (let i = 0; i < data.length; i++) {\n                        obj = this._collection._defineNestedProperties(clone(data[i], method));\n                        if (removeMeta) {\n                            delete obj.$loki;\n                            delete obj.meta;\n                        }\n                        result.push(obj);\n                    }\n                    return result;\n                }\n                // otherwise we are not cloning so return sliced array with same object references\n                else {\n                    return data.slice();\n                }\n            }\n            else {\n                // filteredRows must have been set manually, so use it\n                this._filterInitialized = true;\n            }\n        }\n        const fr = this._filteredRows;\n        if (this._collection._cloneObjects || forceClones) {\n            method = forceCloneMethod;\n            for (let i = 0; i < fr.length; i++) {\n                obj = this._collection._defineNestedProperties(clone(data[fr[i]], method));\n                if (removeMeta) {\n                    delete obj.$loki;\n                    delete obj.meta;\n                }\n                result.push(obj);\n            }\n        }\n        else {\n            for (let i = 0; i < fr.length; i++) {\n                result.push(data[fr[i]]);\n            }\n        }\n        return result;\n    }\n    /**\n     * Used to run an update operation on all documents currently in the ResultSet.\n     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n     * @returns {ResultSet} this ResultSet for further chain ops.\n     */\n    update(updateFunction) {\n        // if this has no filters applied, we need to populate filteredRows first\n        if (!this._filterInitialized && this._filteredRows.length === 0) {\n            this._filteredRows = this._collection._prepareFullDocIndex();\n        }\n        const len = this._filteredRows.length;\n        const rcd = this._collection._data;\n        // pass in each document object currently in ResultSet to user supplied updateFunction\n        for (let idx = 0; idx < len; idx++) {\n            // if we have cloning option specified or are doing differential delta changes, clone object first\n            if (this._collection._cloneObjects || !this._collection._disableDeltaChangesApi) {\n                const obj = clone(rcd[this._filteredRows[idx]], this._collection._cloneMethod);\n                updateFunction(obj);\n                this._collection.update(obj);\n            }\n            else {\n                // no need to clone, so just perform update on collection data object instance\n                updateFunction(rcd[this._filteredRows[idx]]);\n                this._collection.update(rcd[this._filteredRows[idx]]);\n            }\n        }\n        return this;\n    }\n    /**\n     * Removes all document objects which are currently in ResultSet from collection (as well as ResultSet)\n     * @returns {ResultSet} this (empty) ResultSet for further chain ops.\n     */\n    remove() {\n        // if this has no filters applied, we need to populate filteredRows first\n        if (!this._filterInitialized && this._filteredRows.length === 0) {\n            this._filteredRows = this._collection._prepareFullDocIndex();\n        }\n        this._collection.remove(this.data());\n        this._filteredRows = [];\n        return this;\n    }\n    /**\n     * data transformation via user supplied functions\n     *\n     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n     * @returns {value} The output of your reduceFunction\n     */\n    mapReduce(mapFunction, reduceFunction) {\n        try {\n            return reduceFunction(this.data().map(mapFunction));\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n    /**\n     * Left joining two sets of data. Join keys can be defined or calculated properties\n     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n     * @param {Array|ResultSet|Collection} joinData - Data array to join to.\n     * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n     * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n     * @param {function} [mapFun=] - a function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n     * @param {object} [dataOptions=] - optional options to apply to data() calls for left and right sides\n     * @param {boolean} dataOptions.removeMeta - allows removing meta before calling mapFun\n     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n     * @param {string} dataOptions.forceCloneMethod - allows overriding the default or collection specified cloning method\n     * @returns {ResultSet} A ResultSet with data in the format [{left: leftObj, right: rightObj}]\n     */\n    eqJoin(joinData, leftJoinKey, rightJoinKey, mapFun, dataOptions) {\n        let rightData = [];\n        let rightDataLength;\n        let key;\n        let result = [];\n        let leftKeyisFunction = typeof leftJoinKey === "function";\n        let rightKeyisFunction = typeof rightJoinKey === "function";\n        let joinMap = {};\n        //get the left data\n        let leftData = this.data(dataOptions);\n        let leftDataLength = leftData.length;\n        //get the right data\n        if (joinData instanceof collection_Collection) {\n            rightData = joinData.chain().data(dataOptions);\n        }\n        else if (joinData instanceof result_set_ResultSet) {\n            rightData = joinData.data(dataOptions);\n        }\n        else if (Array.isArray(joinData)) {\n            rightData = joinData;\n        }\n        else {\n            throw new TypeError("joinData needs to be an array or result set");\n        }\n        rightDataLength = rightData.length;\n        //construct a lookup table\n        for (let i = 0; i < rightDataLength; i++) {\n            key = rightKeyisFunction\n                ? rightJoinKey(rightData[i])\n                : rightData[i][rightJoinKey];\n            joinMap[key] = rightData[i];\n        }\n        if (!mapFun) {\n            mapFun = (left, right) => ({\n                left,\n                right\n            });\n        }\n        //Run map function over each object in the ResultSet\n        for (let j = 0; j < leftDataLength; j++) {\n            key = leftKeyisFunction\n                ? leftJoinKey(leftData[j])\n                : leftData[j][leftJoinKey];\n            result.push(mapFun(leftData[j], joinMap[key] || {}));\n        }\n        //return a new ResultSet with no filters\n        this._collection = new collection_Collection("joinData");\n        this._collection.insert(result);\n        this._filteredRows = [];\n        this._filterInitialized = false;\n        return this;\n    }\n    /**\n     * Applies a map function into a new collection for further chaining.\n     * @param {function} mapFun - javascript map function\n     * @param {object} [dataOptions=] - options to data() before input to your map function\n     * @param {boolean} dataOptions.removeMeta - allows removing meta before calling mapFun\n     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method\n     * @return {ResultSet}\n     */\n    map(mapFun, dataOptions) {\n        const data = this.data(dataOptions).map(mapFun);\n        //return return a new ResultSet with no filters\n        this._collection = new collection_Collection("mappedData");\n        this._collection.insert(data);\n        this._filteredRows = [];\n        this._filterInitialized = false;\n        return this;\n    }\n}\n\n// CONCATENATED MODULE: ./packages/loki/src/dynamic_view.ts\n\n\n/**\n * DynamicView class is a versatile \'live\' view class which can have filters and sorts applied.\n *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n *\n * @example\n * let mydv = mycollection.addDynamicView(\'test\');  // default is non-persistent\n * mydv.applyFind({ \'doors\' : 4 });\n * mydv.applyWhere(function(obj) { return obj.name === \'Toyota\'; });\n * let results = mydv.data();\n *\n * @extends LokiEventEmitter\n\n * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n *\n * @param <TData> - the data type\n * @param <TNested> - nested properties of data type\n */\nclass dynamic_view_DynamicView extends event_emitter["a" /* LokiEventEmitter */] {\n    /**\n     * Constructor.\n     * @param {Collection} collection - a reference to the collection to work agains\n     * @param {string} name - the name of this dynamic view\n     * @param {object} options - the options\n     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in \'resultdata\'\n     * @param {string} [options.sortPriority="passive"] - the sort priority\n     * @param {number} [options.minRebuildInterval=1] - minimum rebuild interval (need clarification to docs here)\n     */\n    constructor(collection, name, options = {}) {\n        super();\n        this._rebuildPending = false;\n        this._resultData = [];\n        this._resultDirty = false;\n        this._cachedResultSet = null;\n        // keep ordered filter pipeline\n        this._filterPipeline = [];\n        // sorting member variables\n        // we only support one active search, applied using applySort() or applySimpleSort()\n        this._sortFunction = null;\n        this._sortCriteria = null;\n        this._sortCriteriaSimple = null;\n        this._sortByScoring = null;\n        this._sortDirty = false;\n        ({\n            persistent: this._persistent = false,\n            // \'passive\' will defer the sort phase until they call data(). (most efficient overall)\n            // \'active\' will sort async whenever next idle. (prioritizes read speeds)\n            sortPriority: this._sortPriority = "passive",\n            minRebuildInterval: this._minRebuildInterval = 1\n        } = options);\n        this._collection = collection;\n        this.name = name;\n        this._resultSet = new result_set_ResultSet(collection);\n        // for now just have 1 event for when we finally rebuilt lazy view\n        // once we refactor transactions, i will tie in certain transactional events\n        this._events = {\n            "rebuild": []\n        };\n    }\n    /**\n     * Internally used immediately after deserialization (loading)\n     *    This will clear out and reapply filterPipeline ops, recreating the view.\n     *    Since where filters do not persist correctly, this method allows\n     *    restoring the view to state where user can re-apply those where filters.\n     *\n     * @param removeWhereFilters\n     * @returns {DynamicView} This dynamic view for further chained ops.\n     * @fires DynamicView.rebuild\n     */\n    _rematerialize({ removeWhereFilters = false }) {\n        this._resultData = [];\n        this._resultDirty = true;\n        this._resultSet = new result_set_ResultSet(this._collection);\n        if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple || this._sortByScoring !== null) {\n            this._sortDirty = true;\n        }\n        if (removeWhereFilters) {\n            // for each view see if it had any where filters applied... since they don\'t\n            // serialize those functions lets remove those invalid filters\n            let fpi = this._filterPipeline.length;\n            while (fpi--) {\n                if (this._filterPipeline[fpi].type === "where") {\n                    if (fpi !== this._filterPipeline.length - 1) {\n                        this._filterPipeline[fpi] = this._filterPipeline[this._filterPipeline.length - 1];\n                    }\n                    this._filterPipeline.length--;\n                }\n            }\n        }\n        // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n        const ofp = this._filterPipeline;\n        this._filterPipeline = [];\n        // now re-apply \'find\' filterPipeline ops\n        for (let idx = 0; idx < ofp.length; idx++) {\n            this.applyFind(ofp[idx].val);\n        }\n        // during creation of unit tests, i will remove this forced refresh and leave lazy\n        this.data();\n        // emit rebuild event in case user wants to be notified\n        this.emit("rebuild", this);\n        return this;\n    }\n    /**\n     * Makes a copy of the internal ResultSet for branched queries.\n     * Unlike this dynamic view, the branched ResultSet will not be \'live\' updated,\n     * so your branched query should be immediately resolved and not held for future evaluation.\n     * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n     * @param {object} parameters - optional parameters (if optional transform requires them)\n     * @returns {ResultSet} A copy of the internal ResultSet for branched queries.\n     */\n    branchResultSet(transform, parameters) {\n        const rs = this._resultSet.copy();\n        if (transform === undefined) {\n            return rs;\n        }\n        return rs.transform(transform, parameters);\n    }\n    /**\n     * Override of toJSON to avoid circular references.\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            _persistent: this._persistent,\n            _sortPriority: this._sortPriority,\n            _minRebuildInterval: this._minRebuildInterval,\n            _resultSet: this._resultSet,\n            _filterPipeline: this._filterPipeline,\n            _sortCriteria: this._sortCriteria,\n            _sortCriteriaSimple: this._sortCriteriaSimple,\n            _sortByScoring: this._sortByScoring,\n            _sortDirty: this._sortDirty,\n        };\n    }\n    static fromJSONObject(collection, obj) {\n        let dv = new dynamic_view_DynamicView(collection, obj.name);\n        dv._resultDirty = true;\n        dv._filterPipeline = obj._filterPipeline;\n        dv._resultData = [];\n        dv._sortCriteria = obj._sortCriteria;\n        dv._sortCriteriaSimple = obj._sortCriteriaSimple;\n        dv._sortByScoring = obj._sortByScoring;\n        dv._sortDirty = obj._sortDirty;\n        dv._resultSet._filteredRows = obj._resultSet._filteredRows;\n        dv._resultSet._filterInitialized = obj._resultSet._filterInitialized;\n        dv._rematerialize({\n            removeWhereFilters: true\n        });\n        return dv;\n    }\n    /**\n     * Used to clear pipeline and reset dynamic view to initial state.\n     * Existing options should be retained.\n     * @param {boolean} queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n     */\n    removeFilters({ queueSortPhase = false } = {}) {\n        this._rebuildPending = false;\n        this._resultSet.reset();\n        this._resultData = [];\n        this._resultDirty = true;\n        this._cachedResultSet = null;\n        // keep ordered filter pipeline\n        this._filterPipeline = [];\n        // sorting member variables\n        // we only support one active search, applied using applySort() or applySimpleSort()\n        this._sortFunction = null;\n        this._sortCriteria = null;\n        this._sortCriteriaSimple = null;\n        this._sortByScoring = null;\n        this._sortDirty = false;\n        if (queueSortPhase === true) {\n            this._queueSortPhase();\n        }\n    }\n    /**\n     * Used to apply a sort to the dynamic view\n     * @example\n     * dv.applySort(function(obj1, obj2) {\n       *   if (obj1.name === obj2.name) return 0;\n       *   if (obj1.name > obj2.name) return 1;\n       *   if (obj1.name < obj2.name) return -1;\n       * });\n     * @param {function} comparefun - a javascript compare function used for sorting\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    applySort(comparefun) {\n        this._sortFunction = comparefun;\n        this._sortCriteria = null;\n        this._sortCriteriaSimple = null;\n        this._sortByScoring = null;\n        this._queueSortPhase();\n        return this;\n    }\n    /**\n     * Used to specify a property used for view translation.\n     * @param {string} field - the field name\n     * @param {boolean|object=} options - boolean for sort descending or options object\n     * @param {boolean} [options.desc=false] - whether we should sort descending.\n     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.\n     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).\n     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @example\n     * dv.applySimpleSort("name");\n     */\n    applySimpleSort(field, options = false) {\n        this._sortCriteriaSimple = { field, options };\n        this._sortFunction = null;\n        this._sortCriteria = null;\n        this._sortByScoring = null;\n        this._queueSortPhase();\n        return this;\n    }\n    /**\n     * Allows sorting a ResultSet based on multiple columns.\n     * @param {Array} criteria - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n     * @example\n     * // to sort by age and then name (both ascending)\n     * dv.applySortCriteria([\'age\', \'name\']);\n     * // to sort by age (ascending) and then by name (descending)\n     * dv.applySortCriteria([\'age\', [\'name\', true]]);\n     * // to sort by age (descending) and then by name (descending)\n     * dv.applySortCriteria([[\'age\', true], [\'name\', true]]);\n     */\n    applySortCriteria(criteria) {\n        this._sortCriteria = criteria;\n        this._sortCriteriaSimple = null;\n        this._sortFunction = null;\n        this._sortByScoring = null;\n        this._queueSortPhase();\n        return this;\n    }\n    /**\n     * Used to apply a sort by the latest full-text-search scoring.\n     * @param {boolean} [ascending=false] - sort ascending\n     */\n    applySortByScoring(ascending = false) {\n        this._sortFunction = null;\n        this._sortCriteria = null;\n        this._sortCriteriaSimple = null;\n        this._sortByScoring = ascending;\n        this._queueSortPhase();\n        return this;\n    }\n    /**\n     * Returns the scoring of the last full-text-search.\n     * @returns {ScoreResult[]}\n     */\n    getScoring() {\n        return this._resultSet.getScoring();\n    }\n    /**\n     * Marks the beginning of a transaction.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    startTransaction() {\n        this._cachedResultSet = this._resultSet.copy();\n        return this;\n    }\n    /**\n     * Commits a transaction.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    commit() {\n        this._cachedResultSet = null;\n        return this;\n    }\n    /**\n     * Rolls back a transaction.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    rollback() {\n        this._resultSet = this._cachedResultSet;\n        if (this._persistent) {\n            // for now just rebuild the persistent dynamic view data in this worst case scenario\n            // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n            this._resultData = this._resultSet.data();\n            this.emit("rebuild", this);\n        }\n        return this;\n    }\n    /**\n     * Find the index of a filter in the pipeline, by that filter\'s ID.\n     * @param {(string|number)} uid - The unique ID of the filter.\n     * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n     */\n    _indexOfFilterWithId(uid) {\n        if (typeof uid === "string" || typeof uid === "number") {\n            for (let idx = 0, len = this._filterPipeline.length; idx < len; idx++) {\n                if (uid === this._filterPipeline[idx].uid) {\n                    return idx;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * Add the filter object to the end of view\'s filter pipeline and apply the filter to the ResultSet.\n     * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n     */\n    _addFilter(filter) {\n        this._filterPipeline.push(filter);\n        this._resultSet[filter.type](filter.val);\n    }\n    /**\n     * Reapply all the filters in the current pipeline.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    reapplyFilters() {\n        this._resultSet.reset();\n        this._cachedResultSet = null;\n        if (this._persistent) {\n            this._resultData = [];\n            this._resultDirty = true;\n        }\n        const filters = this._filterPipeline;\n        this._filterPipeline = [];\n        for (let idx = 0, len = filters.length; idx < len; idx++) {\n            this._addFilter(filters[idx]);\n        }\n        if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple || this._sortByScoring !== null) {\n            this._queueSortPhase();\n        }\n        else {\n            this._queueRebuildEvent();\n        }\n        return this;\n    }\n    /**\n     * Adds or updates a filter in the DynamicView filter pipeline\n     * @param {object} filter - A filter object to add to the pipeline.\n     *    The object is in the format { \'type\': filter_type, \'val\', filter_param, \'uid\', optional_filter_id }\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    applyFilter(filter) {\n        const idx = this._indexOfFilterWithId(filter.uid);\n        if (idx >= 0) {\n            this._filterPipeline[idx] = filter;\n            return this.reapplyFilters();\n        }\n        this._cachedResultSet = null;\n        if (this._persistent) {\n            this._resultData = [];\n            this._resultDirty = true;\n        }\n        this._addFilter(filter);\n        if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple || this._sortByScoring !== null) {\n            this._queueSortPhase();\n        }\n        else {\n            this._queueRebuildEvent();\n        }\n        return this;\n    }\n    /**\n     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n     *\n     * @param {object} query - A mongo-style query object to apply to pipeline\n     * @param {(string|number)} uid - Optional: The unique ID of this filter, to reference it in the future.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    applyFind(query, uid = "") {\n        this.applyFilter({\n            type: "find",\n            val: query,\n            uid\n        });\n        return this;\n    }\n    /**\n     * Adds or updates a javascript filter function in the DynamicView filter pipeline\n     * @param {function} fun - A javascript filter function to apply to pipeline\n     * @param {(string|number)} uid - Optional: The unique ID of this filter, to reference it in the future.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    applyWhere(fun, uid) {\n        this.applyFilter({\n            type: "where",\n            val: fun,\n            uid\n        });\n        return this;\n    }\n    /**\n     * Remove the specified filter from the DynamicView filter pipeline\n     * @param {(string|number)} uid - The unique ID of the filter to be removed.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    removeFilter(uid) {\n        const idx = this._indexOfFilterWithId(uid);\n        if (idx < 0) {\n            throw new Error("Dynamic view does not contain a filter with ID: " + uid);\n        }\n        this._filterPipeline.splice(idx, 1);\n        this.reapplyFilters();\n        return this;\n    }\n    /**\n     * Returns the number of documents representing the current DynamicView contents.\n     * @returns {number} The number of documents representing the current DynamicView contents.\n     */\n    count() {\n        // in order to be accurate we will pay the minimum cost (and not alter dv state management)\n        // recurring ResultSet data resolutions should know internally its already up to date.\n        // for persistent data this will not update resultdata nor fire rebuild event.\n        if (this._resultDirty) {\n            this._resultData = this._resultSet.data();\n        }\n        return this._resultSet.count();\n    }\n    /**\n     * Resolves and pending filtering and sorting, then returns document array as result.\n     * @param {object} options - optional parameters to pass to ResultSet.data() if non-persistent\n     * @param {boolean} [options.forceClones] - Allows forcing the return of cloned objects even when\n     *        the collection is not configured for clone object.\n     * @param {string} [options.forceCloneMethod] - Allows overriding the default or collection specified cloning method.\n     *        Possible values include \'parse-stringify\', \'jquery-extend-deep\', \'shallow\', \'shallow-assign\'\n     * @param {boolean} [options.removeMeta] - will force clones and strip $loki and meta properties from documents\n     *\n     * @returns {Array} An array of documents representing the current DynamicView contents.\n     */\n    data(options = {}) {\n        // using final sort phase as \'catch all\' for a few use cases which require full rebuild\n        if (this._sortDirty || this._resultDirty) {\n            this._performSortPhase({\n                suppressRebuildEvent: true\n            });\n        }\n        return (this._persistent) ? (this._resultData) : (this._resultSet.data(options));\n    }\n    /**\n     * When the view is not sorted we may still wish to be notified of rebuild events.\n     * This event will throttle and queue a single rebuild event when batches of updates affect the view.\n     */\n    _queueRebuildEvent() {\n        if (this._rebuildPending) {\n            return;\n        }\n        this._rebuildPending = true;\n        setTimeout(() => {\n            if (this._rebuildPending) {\n                this._rebuildPending = false;\n                this.emit("rebuild", this);\n            }\n        }, this._minRebuildInterval);\n    }\n    /**\n     * If the view is sorted we will throttle sorting to either :\n     * (1) passive - when the user calls data(), or\n     * (2) active - once they stop updating and yield js thread control\n     */\n    _queueSortPhase() {\n        // already queued? exit without queuing again\n        if (this._sortDirty) {\n            return;\n        }\n        this._sortDirty = true;\n        if (this._sortPriority === "active") {\n            // active sorting... once they are done and yield js thread, run async performSortPhase()\n            setTimeout(() => {\n                this._performSortPhase();\n            }, this._minRebuildInterval);\n        }\n        else {\n            // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n            // potentially notify user that data has changed.\n            this._queueRebuildEvent();\n        }\n    }\n    /**\n     * Invoked synchronously or asynchronously to perform final sort phase (if needed)\n     */\n    _performSortPhase(options = {}) {\n        // async call to this may have been pre-empted by synchronous call to data before async could fire\n        if (!this._sortDirty && !this._resultDirty) {\n            return;\n        }\n        if (this._sortDirty) {\n            if (this._sortFunction) {\n                this._resultSet.sort(this._sortFunction);\n            }\n            else if (this._sortCriteria) {\n                this._resultSet.compoundsort(this._sortCriteria);\n            }\n            else if (this._sortCriteriaSimple) {\n                this._resultSet.simplesort(this._sortCriteriaSimple.field, this._sortCriteriaSimple.options);\n            }\n            else if (this._sortByScoring !== null) {\n                this._resultSet.sortByScoring(this._sortByScoring);\n            }\n            this._sortDirty = false;\n        }\n        if (this._persistent) {\n            // persistent view, rebuild local resultdata array\n            this._resultData = this._resultSet.data();\n            this._resultDirty = false;\n        }\n        if (!options.suppressRebuildEvent) {\n            this.emit("rebuild", this);\n        }\n    }\n    /**\n     * (Re)evaluating document inclusion.\n     * Called by : collection.insert() and collection.update().\n     * @param {int} objIndex - index of document to (re)run through filter pipeline.\n     * @param {boolean} isNew - true if the document was just added to the collection.\n     * @hidden\n     */\n    _evaluateDocument(objIndex, isNew) {\n        // if no filter applied yet, the result \'set\' should remain \'everything\'\n        if (!this._resultSet._filterInitialized) {\n            if (this._persistent) {\n                this._resultData = this._resultSet.data();\n            }\n            // need to re-sort to sort new document\n            if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple) {\n                this._queueSortPhase();\n            }\n            else {\n                this._queueRebuildEvent();\n            }\n            return;\n        }\n        const ofr = this._resultSet._filteredRows;\n        const oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n        const oldlen = ofr.length;\n        // creating a 1-element ResultSet to run filter chain ops on to see if that doc passes filters;\n        // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n        const evalResultSet = new result_set_ResultSet(this._collection);\n        evalResultSet._filteredRows = [objIndex];\n        evalResultSet._filterInitialized = true;\n        let filter;\n        for (let idx = 0, len = this._filterPipeline.length; idx < len; idx++) {\n            filter = this._filterPipeline[idx];\n            evalResultSet[filter.type](filter.val);\n        }\n        // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n        const newPos = (evalResultSet._filteredRows.length === 0) ? -1 : 0;\n        // wasn\'t in old, shouldn\'t be now... do nothing\n        if (oldPos === -1 && newPos === -1)\n            return;\n        // wasn\'t in ResultSet, should be now... add\n        if (oldPos === -1 && newPos !== -1) {\n            ofr.push(objIndex);\n            if (this._persistent) {\n                this._resultData.push(this._collection._data[objIndex]);\n            }\n            // need to re-sort to sort new document\n            if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple) {\n                this._queueSortPhase();\n            }\n            else {\n                this._queueRebuildEvent();\n            }\n            return;\n        }\n        // was in ResultSet, shouldn\'t be now... delete\n        if (oldPos !== -1 && newPos === -1) {\n            if (oldPos < oldlen - 1) {\n                ofr.splice(oldPos, 1);\n                if (this._persistent) {\n                    this._resultData.splice(oldPos, 1);\n                }\n            }\n            else {\n                ofr.length = oldlen - 1;\n                if (this._persistent) {\n                    this._resultData.length = oldlen - 1;\n                }\n            }\n            // in case changes to data altered a sort column\n            if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple) {\n                this._queueSortPhase();\n            }\n            else {\n                this._queueRebuildEvent();\n            }\n            return;\n        }\n        // was in ResultSet, should still be now... (update persistent only?)\n        if (oldPos !== -1 && newPos !== -1) {\n            if (this._persistent) {\n                // in case document changed, replace persistent view data with the latest collection._data document\n                this._resultData[oldPos] = this._collection._data[objIndex];\n            }\n            // in case changes to data altered a sort column\n            if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple) {\n                this._queueSortPhase();\n            }\n            else {\n                this._queueRebuildEvent();\n            }\n        }\n    }\n    /**\n     * Internal function called on collection.delete().\n     * @hidden\n     */\n    _removeDocument(objIndex) {\n        // if no filter applied yet, the result \'set\' should remain \'everything\'\n        if (!this._resultSet._filterInitialized) {\n            if (this._persistent) {\n                this._resultData = this._resultSet.data();\n            }\n            // in case changes to data altered a sort column\n            if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple) {\n                this._queueSortPhase();\n            }\n            else {\n                this._queueRebuildEvent();\n            }\n            return;\n        }\n        const ofr = this._resultSet._filteredRows;\n        const oldPos = ofr.indexOf(+objIndex);\n        let oldlen = ofr.length;\n        if (oldPos !== -1) {\n            // if not last row in resultdata, swap last to hole and truncate last row\n            if (oldPos < oldlen - 1) {\n                ofr[oldPos] = ofr[oldlen - 1];\n                ofr.length = oldlen - 1;\n                if (this._persistent) {\n                    this._resultData[oldPos] = this._resultData[oldlen - 1];\n                    this._resultData.length = oldlen - 1;\n                }\n            }\n            // last row, so just truncate last row\n            else {\n                ofr.length = oldlen - 1;\n                if (this._persistent) {\n                    this._resultData.length = oldlen - 1;\n                }\n            }\n            // in case changes to data altered a sort column\n            if (this._sortFunction || this._sortCriteria || this._sortCriteriaSimple) {\n                this._queueSortPhase();\n            }\n            else {\n                this._queueRebuildEvent();\n            }\n        }\n        // since we are using filteredRows to store data array positions\n        // if they remove a document (whether in our view or not),\n        // we need to adjust array positions -1 for all document array references after that position\n        oldlen = ofr.length;\n        for (let idx = 0; idx < oldlen; idx++) {\n            if (ofr[idx] > objIndex) {\n                ofr[idx]--;\n            }\n        }\n    }\n    /**\n     * Data transformation via user supplied functions\n     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n     * @returns The output of your reduceFunction\n     */\n    mapReduce(mapFunction, reduceFunction) {\n        try {\n            return reduceFunction(this.data().map(mapFunction));\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./packages/loki/src/ranged_indexes.ts + 1 modules\nvar ranged_indexes = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./packages/common/plugin.ts\nvar common_plugin = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./packages/loki/src/collection.ts\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return collection_Collection; });\n\n\n\n\n\n\n\n\nfunction average(array) {\n    return (array.reduce((a, b) => a + b, 0)) / array.length;\n}\nfunction standardDeviation(values) {\n    const avg = average(values);\n    const squareDiffs = values.map((value) => {\n        const diff = value - avg;\n        return diff * diff;\n    });\n    const avgSquareDiff = average(squareDiffs);\n    return Math.sqrt(avgSquareDiff);\n}\n/**\n * Returns an array with the value of a nested property of an object.\n * Returns an array of values if the nested property is across child arrays.\n * @param {object} obj - the object\n * @param {string[]} path - the path of the nested property\n * @param {any[]} array - the result array\n * @param {number} pathIdx - the current path idx\n * @returns {boolean} true if nested property is across child arrays, otherwise false\n */\nfunction getNestedPropertyValue(obj, path, array, pathIdx = 0) {\n    if (obj === undefined) {\n        return false;\n    }\n    if (pathIdx + 1 === path.length) {\n        array.push(obj[path[pathIdx]]);\n        return false;\n    }\n    const curr = obj[path[pathIdx]];\n    if (Array.isArray(curr)) {\n        for (let i = 0; i < curr.length; i++) {\n            getNestedPropertyValue(curr[i], path, array, pathIdx + 1);\n        }\n        return true;\n    }\n    else {\n        return getNestedPropertyValue(curr, path, array, pathIdx + 1);\n    }\n}\n/**\n * Collection class that handles documents of same type\n * @extends LokiEventEmitter\n * @param <TData> - the data type\n * @param <TNested> - nested properties of data type\n */\nclass collection_Collection extends event_emitter["a" /* LokiEventEmitter */] {\n    /**\n     * @param {string} name - collection name\n     * @param {(object)} [options={}] - a configuration object\n     * @param {string[]} [options.unique=[]] - array of property names to define unique constraints for\n     * @param {string[]} [options.exact=[]] - array of property names to define exact constraints for\n     * @param {RangedIndexOptions} [options.rangedIndexes] - configuration object for ranged indexes\n     * @param {boolean} [options.asyncListeners=false] - whether listeners are invoked asynchronously\n     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents\n     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes API\n     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)\n     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user\n     * @param {boolean} [options.serializableIndexes=true] - converts date values on binary indexed property values are serializable\n     * @param {string} [options.cloneMethod="deep"] - the clone method\n     * @param {number} [options.transactional=false] - ?\n     * @param {number} [options.ttl=] - age of document (in ms.) before document is considered aged/stale.\n     * @param {number} [options.ttlInterval=] - time interval for clearing out \'aged\' documents; not set by default\n     * @param {string} [options.unindexedSortComparator="js"] "js", "abstract", "abstract-date", "loki" or other registered comparator name\n     * @param {string} [options.defaultLokiOperatorPackage="js"] "js", "loki", "comparator" (or user defined) query ops package\n     * @param {FullTextSearch.FieldOptions} [options.fullTextSearch=] - the full-text search options\n     * @see {@link Loki#addCollection} for normal creation of collections\n     */\n    constructor(name, options = {}) {\n        super();\n        // the data held by the collection\n        this._data = [];\n        // index of id\n        this._idIndex = [];\n        // user defined indexes\n        this._rangedIndexes = {};\n        // loki obj map\n        this._lokimap = {};\n        // default comparator name to use for unindexed sorting\n        this._unindexedSortComparator = "js";\n        // default LokiOperatorPackage (\'default\' uses fastest \'javascript\' comparisons)\n        this._defaultLokiOperatorPackage = "js";\n        /**\n         * Unique constraints contain duplicate object references, so they are not persisted.\n         * We will keep track of properties which have unique constraints applied here, and regenerate on load.\n         */\n        this._constraints = { unique: {} };\n        /**\n         * Transforms will be used to store frequently used query chains as a series of steps which itself can be stored along\n         * with the database.\n         */\n        this._transforms = {};\n        /**\n         * In autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n         * currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n         * Defaulting to true since this is called from addCollection and adding a collection should trigger save.\n         */\n        this._dirty = true;\n        // private holder for cached data\n        this._cached = null;\n        /**\n         * Name of path of used nested properties.\n         */\n        this._nestedProperties = [];\n        /**\n         * Option to activate a cleaner daemon - clears "aged" documents at set intervals.\n         */\n        this._ttl = {\n            age: null,\n            ttlInterval: null,\n            daemon: null\n        };\n        // currentMaxId - change manually at your own peril!\n        this._maxId = 0;\n        this._dynamicViews = [];\n        /**\n         * Changes are tracked by collection and aggregated by the db.\n         */\n        this._changes = [];\n        /**\n         * stages: a map of uniquely identified \'stages\', which hold copies of objects to be\n         * manipulated without affecting the data in the original collection\n         */\n        this._stages = {};\n        this._commitLog = [];\n        // Consistency checks.\n        if (options && options.disableMeta === true) {\n            if (options.disableChangesApi === false) {\n                throw new Error("disableMeta option cannot be passed as true when disableChangesApi is passed as false");\n            }\n            if (options.disableDeltaChangesApi === false) {\n                throw new Error("disableMeta option cannot be passed as true when disableDeltaChangesApi is passed as false");\n            }\n            if (typeof options.ttl === "number" && options.ttl > 0) {\n                throw new Error("disableMeta option cannot be passed as true when ttl is enabled");\n            }\n        }\n        // the name of the collection\n        this.name = name;\n        /* OPTIONS */\n        this._unindexedSortComparator = options.unindexedSortComparator || "js";\n        this._defaultLokiOperatorPackage = options.defaultLokiOperatorPackage || "js";\n        // exact match and unique constraints\n        if (options.unique !== undefined) {\n            if (!Array.isArray(options.unique)) {\n                options.unique = [options.unique];\n            }\n            options.unique.forEach((prop) => {\n                this._constraints.unique[prop] = new UniqueIndex(prop);\n            });\n        }\n        // Full text search\n        if (common_plugin["a" /* PLUGINS */]["FullTextSearch"] !== undefined) {\n            this._fullTextSearch = options.fullTextSearch !== undefined\n                ? new (common_plugin["a" /* PLUGINS */]["FullTextSearch"])(options.fullTextSearch) : null;\n        }\n        else {\n            this._fullTextSearch = null;\n        }\n        // .\n        this._transactional = options.transactional !== undefined ? options.transactional : false;\n        // .\n        this._cloneObjects = options.clone !== undefined ? options.clone : false;\n        // .\n        this._asyncListeners = options.asyncListeners !== undefined ? options.asyncListeners : false;\n        // .\n        this._disableMeta = options.disableMeta !== undefined ? options.disableMeta : false;\n        // .\n        this._disableChangesApi = options.disableChangesApi !== undefined ? options.disableChangesApi : true;\n        // .\n        this._disableDeltaChangesApi = options.disableDeltaChangesApi !== undefined ? options.disableDeltaChangesApi : true;\n        // .\n        this._cloneMethod = options.cloneMethod !== undefined ? options.cloneMethod : "deep";\n        if (this._disableChangesApi) {\n            this._disableDeltaChangesApi = true;\n        }\n        // .\n        this._serializableIndexes = options.serializableIndexes !== undefined ? options.serializableIndexes : true;\n        // .\n        if (options.nestedProperties != undefined) {\n            for (let i = 0; i < options.nestedProperties.length; i++) {\n                const nestedProperty = options.nestedProperties[i];\n                if (typeof nestedProperty === "string") {\n                    this._nestedProperties.push({ name: nestedProperty, path: nestedProperty.split(".") });\n                }\n                else {\n                    this._nestedProperties.push(nestedProperty);\n                }\n            }\n        }\n        this.setTTL(options.ttl || -1, options.ttlInterval);\n        // events\n        this._events = {\n            "insert": [],\n            "update": [],\n            "pre-insert": [],\n            "pre-update": [],\n            "close": [],\n            "flushbuffer": [],\n            "error": [],\n            "delete": [],\n            "warning": []\n        };\n        // initialize the id index\n        this._ensureId();\n        let rangedIndexes = options.rangedIndexes || {};\n        for (let ri in rangedIndexes) {\n            // Todo: any way to type annotate this as typesafe generic?\n            this.ensureRangedIndex(ri, rangedIndexes[ri].indexTypeName, rangedIndexes[ri].comparatorName);\n        }\n        this.setChangesApi(this._disableChangesApi, this._disableDeltaChangesApi);\n        // for de-serialization purposes\n        this.flushChanges();\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            unindexedSortComparator: this._unindexedSortComparator,\n            defaultLokiOperatorPackage: this._defaultLokiOperatorPackage,\n            _dynamicViews: this._dynamicViews,\n            uniqueNames: Object.keys(this._constraints.unique),\n            transforms: this._transforms,\n            rangedIndexes: this._rangedIndexes,\n            _data: this._data,\n            idIndex: this._idIndex,\n            maxId: this._maxId,\n            _dirty: this._dirty,\n            _nestedProperties: this._nestedProperties,\n            transactional: this._transactional,\n            asyncListeners: this._asyncListeners,\n            disableMeta: this._disableMeta,\n            disableChangesApi: this._disableChangesApi,\n            disableDeltaChangesApi: this._disableDeltaChangesApi,\n            cloneObjects: this._cloneObjects,\n            cloneMethod: this._cloneMethod,\n            changes: this._changes,\n            _fullTextSearch: this._fullTextSearch\n        };\n    }\n    static fromJSONObject(obj, options) {\n        // instantiate collection with options needed by constructor\n        let coll = new collection_Collection(obj.name, {\n            disableChangesApi: obj.disableChangesApi,\n            disableDeltaChangesApi: obj.disableDeltaChangesApi,\n            unindexedSortComparator: obj.unindexedSortComparator,\n            defaultLokiOperatorPackage: obj.defaultLokiOperatorPackage\n        });\n        coll._transactional = obj.transactional;\n        coll._asyncListeners = obj.asyncListeners;\n        coll._disableMeta = obj.disableMeta;\n        coll._disableChangesApi = obj.disableChangesApi;\n        coll._cloneObjects = obj.cloneObjects;\n        coll._cloneMethod = obj.cloneMethod || "deep";\n        coll._changes = obj.changes;\n        coll._nestedProperties = obj._nestedProperties;\n        coll._rangedIndexes = obj.rangedIndexes || {};\n        coll._dirty = (options && options.retainDirtyFlags === true) ? obj._dirty : false;\n        function makeLoader(coll) {\n            const collOptions = options[coll.name];\n            if (collOptions.proto) {\n                const inflater = collOptions.inflate || ((src, dest) => {\n                    for (let prop in src) {\n                        dest[prop] = src[prop];\n                    }\n                });\n                return (data) => {\n                    const collObj = new (collOptions.proto)();\n                    inflater(data, collObj);\n                    return collObj;\n                };\n            }\n            return collOptions.inflate;\n        }\n        // load each element individually\n        if (options && options[obj.name] !== undefined) {\n            let loader = makeLoader(obj);\n            for (let j = 0; j < obj._data.length; j++) {\n                coll._data[j] = coll._defineNestedProperties(loader(obj._data[j]));\n                // regenerate lokimap\n                coll._lokimap[coll._data[j].$loki] = coll._data[j];\n            }\n        }\n        else {\n            for (let j = 0; j < obj._data.length; j++) {\n                coll._data[j] = coll._defineNestedProperties(obj._data[j]);\n                // regenerate lokimap\n                coll._lokimap[coll._data[j].$loki] = coll._data[j];\n            }\n        }\n        coll._maxId = (obj.maxId === undefined) ? 0 : obj.maxId;\n        coll._idIndex = obj.idIndex;\n        if (obj.transforms !== undefined) {\n            coll._transforms = obj.transforms;\n        }\n        // inflate rangedindexes\n        for (let ri in obj.rangedIndexes) {\n            // shortcut reference to serialized meta\n            let sri = obj.rangedIndexes[ri];\n            // lookup index factory function in map based on index type name\n            let rif = ranged_indexes["a" /* RangedIndexFactoryMap */][sri.indexTypeName];\n            // lookup comparator function in map based on comparator name\n            let ricmp = comparators["a" /* ComparatorMap */][sri.comparatorName];\n            // using index type (from meta), index factory and comparator... create instance of ranged index\n            let rii = rif(ri, ricmp);\n            // now ask new index instance to inflate from plain object\n            rii.restore(sri.index);\n            // attach class instance to our collection\'s ranged index\'s (index) instance property\n            coll._rangedIndexes[ri].index = rii;\n        }\n        coll._ensureId();\n        // regenerate unique indexes\n        if (obj.uniqueNames !== undefined) {\n            for (let j = 0; j < obj.uniqueNames.length; j++) {\n                coll.ensureUniqueIndex(obj.uniqueNames[j]);\n            }\n        }\n        // in case they are loading a database created before we added dynamic views, handle undefined\n        if (obj._dynamicViews !== undefined) {\n            // reinflate DynamicViews and attached ResultSets\n            for (let idx = 0; idx < obj._dynamicViews.length; idx++) {\n                coll._dynamicViews.push(dynamic_view_DynamicView.fromJSONObject(coll, obj._dynamicViews[idx]));\n            }\n        }\n        if (obj._fullTextSearch) {\n            coll._fullTextSearch = common_plugin["a" /* PLUGINS */]["FullTextSearch"].fromJSONObject(obj._fullTextSearch, options.fullTextSearch);\n        }\n        return coll;\n    }\n    /**\n     * Adds a named collection transform to the collection\n     * @param {string} name - name to associate with transform\n     * @param {array} transform - an array of transformation \'step\' objects to save into the collection\n     */\n    addTransform(name, transform) {\n        if (this._transforms[name] !== undefined) {\n            throw new Error("a transform by that name already exists");\n        }\n        this._transforms[name] = transform;\n    }\n    /**\n     * Retrieves a named transform from the collection.\n     * @param {string} name - name of the transform to lookup.\n     */\n    getTransform(name) {\n        return this._transforms[name];\n    }\n    /**\n     * Updates a named collection transform to the collection\n     * @param {string} name - name to associate with transform\n     * @param {object} transform - a transformation object to save into collection\n     */\n    setTransform(name, transform) {\n        this._transforms[name] = transform;\n    }\n    /**\n     * Removes a named collection transform from the collection\n     * @param {string} name - name of collection transform to remove\n     */\n    removeTransform(name) {\n        delete this._transforms[name];\n    }\n    /*----------------------------+\n     | TTL                        |\n     +----------------------------*/\n    setTTL(age, interval) {\n        if (age < 0) {\n            clearInterval(this._ttl.daemon);\n        }\n        else {\n            this._ttl.age = age;\n            this._ttl.ttlInterval = interval;\n            this._ttl.daemon = setInterval(() => {\n                const now = Date.now();\n                const toRemove = this.chain().where((member) => {\n                    const timestamp = member.meta.updated || member.meta.created;\n                    const diff = now - timestamp;\n                    return this._ttl.age < diff;\n                });\n                toRemove.remove();\n            }, interval);\n        }\n    }\n    /*----------------------------+\n     | INDEXING                   |\n     +----------------------------*/\n    /**\n     * Create a row filter that covers all documents in the collection.\n     */\n    _prepareFullDocIndex() {\n        const indexes = new Array(this._data.length);\n        for (let i = 0; i < indexes.length; i++) {\n            indexes[i] = i;\n        }\n        return indexes;\n    }\n    /**\n     * Ensure rangedIndex of a field.\n     * @param field\n     * @param indexTypeName\n     * @param comparatorName\n     */\n    ensureIndex(field, indexTypeName, comparatorName) {\n        this.ensureRangedIndex(field, indexTypeName, comparatorName);\n    }\n    /**\n     * Ensure rangedIndex of a field.\n     * @param field Property to create an index on (need to look into contraining on keyof T)\n     * @param indexTypeName Name of IndexType factory within (global?) hashmap to create IRangedIndex from\n     * @param comparatorName Name of Comparator within (global?) hashmap\n     */\n    ensureRangedIndex(field, indexTypeName, comparatorName) {\n        indexTypeName = indexTypeName || "avl";\n        comparatorName = comparatorName || "loki";\n        if (!ranged_indexes["a" /* RangedIndexFactoryMap */][indexTypeName]) {\n            throw new Error("ensureRangedIndex: Unknown range index type");\n        }\n        if (!comparators["a" /* ComparatorMap */][comparatorName]) {\n            throw new Error("ensureRangedIndex: Unknown comparator");\n        }\n        let rif = ranged_indexes["a" /* RangedIndexFactoryMap */][indexTypeName];\n        let comparator = comparators["a" /* ComparatorMap */][comparatorName];\n        this._rangedIndexes[field] = {\n            index: rif(field, comparator),\n            indexTypeName: indexTypeName,\n            comparatorName: comparatorName\n        };\n        let rii = this._rangedIndexes[field].index;\n        for (let i = 0; i < this._data.length; i++) {\n            rii.insert(this._data[i].$loki, this._data[i][field]);\n        }\n    }\n    ensureUniqueIndex(field) {\n        let index = new UniqueIndex(field);\n        // if index already existed, (re)loading it will likely cause collisions, rebuild always\n        this._constraints.unique[field] = index;\n        for (let i = 0; i < this._data.length; i++) {\n            index.set(this._data[i].$loki, this._data[i][field]);\n        }\n        return index;\n    }\n    /**\n     * Quickly determine number of documents in collection (or query)\n     * @param {object} query - (optional) query object to count results of\n     * @returns {number} number of documents in the collection\n     */\n    count(query) {\n        if (!query) {\n            return this._data.length;\n        }\n        return this.chain().find(query)._filteredRows.length;\n    }\n    /**\n     * Rebuild idIndex\n     */\n    _ensureId() {\n        this._idIndex = [];\n        for (let i = 0; i < this._data.length; i++) {\n            this._idIndex.push(this._data[i].$loki);\n        }\n    }\n    /**\n     * Add a dynamic view to the collection\n     * @param {string} name - name of dynamic view to add\n     * @param {object} options - (optional) options to configure dynamic view with\n     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in \'resultdata\'\n     * @param {string} [options.sortPriority=SortPriority.PASSIVE] - the sort priority\n     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n     * @returns {DynamicView} reference to the dynamic view added\n     **/\n    addDynamicView(name, options) {\n        const dv = new dynamic_view_DynamicView(this, name, options);\n        this._dynamicViews.push(dv);\n        return dv;\n    }\n    /**\n     * Remove a dynamic view from the collection\n     * @param {string} name - name of dynamic view to remove\n     **/\n    removeDynamicView(name) {\n        for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n            if (this._dynamicViews[idx].name === name) {\n                this._dynamicViews.splice(idx, 1);\n            }\n        }\n    }\n    /**\n     * Look up dynamic view reference from within the collection\n     * @param {string} name - name of dynamic view to retrieve reference of\n     * @returns {DynamicView} A reference to the dynamic view with that name\n     **/\n    getDynamicView(name) {\n        for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n            if (this._dynamicViews[idx].name === name) {\n                return this._dynamicViews[idx];\n            }\n        }\n        return null;\n    }\n    /**\n     * Applies a \'mongo-like\' find query object and passes all results to an update function.\n     * @param {object} filterObject - the \'mongo-like\' query object\n     * @param {function} updateFunction - the update function\n     */\n    findAndUpdate(filterObject, updateFunction) {\n        this.chain().find(filterObject).update(updateFunction);\n    }\n    /**\n     * Applies a \'mongo-like\' find query object removes all documents which match that filter.\n     * @param {object} filterObject - \'mongo-like\' query object\n     */\n    findAndRemove(filterObject) {\n        this.chain().find(filterObject).remove();\n    }\n    insert(doc) {\n        if (!Array.isArray(doc)) {\n            return this.insertOne(doc);\n        }\n        // holder to the clone of the object inserted if collections is set to clone objects\n        let obj;\n        let results = [];\n        this.emit("pre-insert", doc);\n        for (let i = 0; i < doc.length; i++) {\n            obj = this.insertOne(doc[i], true);\n            if (!obj) {\n                return undefined;\n            }\n            results.push(obj);\n        }\n        // at the \'batch\' level, if clone option is true then emitted docs are clones\n        this.emit("insert", results);\n        // if clone option is set, clone return values\n        results = this._cloneObjects ? clone(results, this._cloneMethod) : results;\n        return results.length === 1 ? results[0] : results;\n    }\n    /**\n     * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n     * @param {object} doc - the document to be inserted\n     * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n     * @returns {object} document or \'undefined\' if there was a problem inserting it\n     */\n    insertOne(doc, bulkInsert = false) {\n        let err = null;\n        let returnObj;\n        if (typeof doc !== "object") {\n            err = new TypeError("Document needs to be an object");\n        }\n        else if (doc === null) {\n            err = new TypeError("Object cannot be null");\n        }\n        if (err !== null) {\n            this.emit("error", err);\n            throw err;\n        }\n        // if configured to clone, do so now... otherwise just use same obj reference\n        const obj = this._defineNestedProperties(this._cloneObjects ? clone(doc, this._cloneMethod) : doc);\n        if (!this._disableMeta && obj.meta === undefined) {\n            obj.meta = {\n                version: 0,\n                revision: 0,\n                created: 0\n            };\n        }\n        // both \'pre-insert\' and \'insert\' events are passed internal data reference even when cloning\n        // insert needs internal reference because that is where loki itself listens to add meta\n        if (!bulkInsert) {\n            this.emit("pre-insert", obj);\n        }\n        if (!this._add(obj)) {\n            return undefined;\n        }\n        // update meta and store changes if ChangesAPI is enabled\n        // (moved from "insert" event listener to allow internal reference to be used)\n        if (this._disableChangesApi) {\n            this._insertMeta(obj);\n        }\n        else {\n            this._insertMetaWithChange(obj);\n        }\n        // if cloning is enabled, emit insert event with clone of new object\n        returnObj = this._cloneObjects ? clone(obj, this._cloneMethod) : obj;\n        if (!bulkInsert) {\n            this.emit("insert", returnObj);\n        }\n        return returnObj;\n    }\n    /**\n     * Refers nested properties of an object to the root of it.\n     * @param {T} data - the object\n     * @returns {T & TNested} the object with nested properties\n     * @hidden\n     */\n    _defineNestedProperties(data) {\n        for (let i = 0; i < this._nestedProperties.length; i++) {\n            const name = this._nestedProperties[i].name;\n            const path = this._nestedProperties[i].path;\n            Object.defineProperty(data, name, {\n                get() {\n                    // Get the value of the nested property.\n                    const array = [];\n                    if (getNestedPropertyValue(this, path, array)) {\n                        return array;\n                    }\n                    else {\n                        return array[0];\n                    }\n                },\n                set(val) {\n                    // Set the value of the nested property.\n                    path.slice(0, path.length - 1).reduce((obj, part) => (obj && obj[part]) ? obj[part] : null, this)[path[path.length - 1]] = val;\n                },\n                enumerable: false,\n                configurable: true\n            });\n        }\n        return data;\n    }\n    /**\n     * Empties the collection.\n     * @param {boolean} [removeIndices=false] - remove indices\n     */\n    clear({ removeIndices: removeIndices = false } = {}) {\n        this._data = [];\n        this._idIndex = [];\n        this._cached = null;\n        this._maxId = 0;\n        this._dynamicViews = [];\n        this._dirty = true;\n        // if removing indices entirely\n        if (removeIndices === true) {\n            this._rangedIndexes = {};\n            this._constraints = {\n                unique: {}\n            };\n        }\n        // clear indices but leave definitions in place\n        else {\n            // re-instance ranged indexes\n            for (let ri in this._rangedIndexes) {\n                this.ensureRangedIndex(ri, this._rangedIndexes[ri].indexTypeName, this._rangedIndexes[ri].comparatorName);\n            }\n            // clear entire unique indices definition\n            const uniqueNames = Object.keys(this._constraints.unique);\n            for (let i = 0; i < uniqueNames.length; i++) {\n                this._constraints.unique[uniqueNames[i]].clear();\n            }\n        }\n        if (this._fullTextSearch !== null) {\n            this._fullTextSearch.clear();\n        }\n    }\n    /**\n     * Updates an object and notifies collection that the document has changed.\n     * @param {object} doc - document to update within the collection\n     */\n    update(doc) {\n        if (Array.isArray(doc)) {\n            for (let i = 0; i < doc.length; i++) {\n                this.update(doc[i]);\n            }\n            return;\n        }\n        // Verify object is a properly formed document.\n        if (doc.$loki === undefined) {\n            throw new Error("Trying to update unsynced document. Please save the document first by using insert() or addMany()");\n        }\n        try {\n            this.startTransaction();\n            const arr = this.get(doc.$loki, true);\n            if (!arr) {\n                throw new Error("Trying to update a document not in collection.");\n            }\n            // ref to existing obj\n            let oldInternal = arr[0]; // -internal- obj ref\n            let position = arr[1]; // position in data array\n            // ref to new internal obj\n            // if configured to clone, do so now... otherwise just use same obj reference\n            let newInternal = this._defineNestedProperties(this._cloneObjects || !this._disableDeltaChangesApi ? clone(doc, this._cloneMethod) : doc);\n            this.emit("pre-update", doc);\n            Object.keys(this._constraints.unique).forEach((key) => {\n                this._constraints.unique[key].update(newInternal.$loki, newInternal[key]);\n            });\n            // operate the update\n            this._data[position] = newInternal;\n            this._lokimap[doc.$loki] = newInternal;\n            // now that we can efficiently determine the data[] position of newly added document,\n            // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n            for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n                this._dynamicViews[idx]._evaluateDocument(position, false);\n            }\n            // Notify all ranged indexes of (possible) value update\n            for (let ri in this._rangedIndexes) {\n                this._rangedIndexes[ri].index.update(doc.$loki, doc[ri]);\n            }\n            this._idIndex[position] = newInternal.$loki;\n            // FullTextSearch.\n            if (this._fullTextSearch !== null) {\n                this._fullTextSearch.updateDocument(doc, position);\n            }\n            this.commit();\n            this._dirty = true; // for autosave scenarios\n            // update meta and store changes if ChangesAPI is enabled\n            if (this._disableChangesApi) {\n                this._updateMeta(newInternal);\n            }\n            else {\n                this._updateMetaWithChange(newInternal, oldInternal);\n            }\n            let returnObj = newInternal;\n            // if cloning is enabled, emit \'update\' event and return with clone of new object\n            if (this._cloneObjects) {\n                returnObj = clone(newInternal, this._cloneMethod);\n            }\n            this.emit("update", returnObj, oldInternal);\n        }\n        catch (err) {\n            this.rollback();\n            this.emit("error", err);\n            throw (err); // re-throw error so user does not think it succeeded\n        }\n    }\n    /**\n     * Add object to collection\n     */\n    _add(obj) {\n        // if parameter isn\'t object exit with throw\n        if ("object" !== typeof obj) {\n            throw new TypeError("Object being added needs to be an object");\n        }\n        // if object you are adding already has id column it is either already in the collection\n        // or the object is carrying its own \'id\' property.  If it also has a meta property,\n        // then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n        if (obj["$loki"] !== undefined) {\n            throw new Error("Document is already in collection, please use update()");\n        }\n        /*\n         * try adding object to collection\n         */\n        try {\n            this.startTransaction();\n            this._maxId++;\n            if (isNaN(this._maxId)) {\n                this._maxId = (this._data[this._data.length - 1].$loki + 1);\n            }\n            const newDoc = obj;\n            newDoc.$loki = this._maxId;\n            if (!this._disableMeta) {\n                newDoc.meta.version = 0;\n            }\n            const constrUnique = this._constraints.unique;\n            for (const key in constrUnique) {\n                if (constrUnique[key] !== undefined) {\n                    constrUnique[key].set(newDoc.$loki, newDoc[key]);\n                }\n            }\n            // add new obj id to idIndex\n            this._idIndex.push(newDoc.$loki);\n            // update lokimap\n            this._lokimap[newDoc.$loki] = newDoc;\n            // add the object\n            this._data.push(newDoc);\n            const addedPos = this._data.length - 1;\n            // now that we can efficiently determine the data[] position of newly added document,\n            // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n            const dvlen = this._dynamicViews.length;\n            for (let i = 0; i < dvlen; i++) {\n                this._dynamicViews[i]._evaluateDocument(addedPos, true);\n            }\n            // add id/val kvp to ranged index\n            for (let ri in this._rangedIndexes) {\n                // ensure Dates are converted to unix epoch time if serializableIndexes is true\n                if (this._serializableIndexes && newDoc[ri] instanceof Date) {\n                    newDoc[ri] = newDoc[ri].getTime();\n                }\n                this._rangedIndexes[ri].index.insert(obj["$loki"], obj[ri]);\n            }\n            // FullTextSearch.\n            if (this._fullTextSearch !== null) {\n                this._fullTextSearch.addDocument(newDoc, addedPos);\n            }\n            this.commit();\n            this._dirty = true; // for autosave scenarios\n            return (this._cloneObjects) ? (clone(newDoc, this._cloneMethod)) : (newDoc);\n        }\n        catch (err) {\n            this.rollback();\n            this.emit("error", err);\n            throw (err); // re-throw error so user does not think it succeeded\n        }\n    }\n    /**\n     * Applies a filter function and passes all results to an update function.\n     * @param {function} filterFunction - the filter function\n     * @param {function} updateFunction - the update function\n     */\n    updateWhere(filterFunction, updateFunction) {\n        const results = this.where(filterFunction);\n        try {\n            for (let i = 0; i < results.length; i++) {\n                this.update(updateFunction(results[i]));\n            }\n        }\n        catch (err) {\n            this.rollback();\n            throw err;\n        }\n    }\n    /**\n     * Remove all documents matching supplied filter function.\n     * @param {function} filterFunction - the filter function\n     */\n    removeWhere(filterFunction) {\n        this.remove(this._data.filter(filterFunction));\n    }\n    removeDataOnly() {\n        this.remove(this._data.slice());\n    }\n    /**\n     * Remove a document from the collection\n     * @param {number|object} doc - document to remove from collection\n     */\n    remove(doc) {\n        if (typeof doc === "number") {\n            doc = this.get(doc);\n        }\n        if (Array.isArray(doc)) {\n            let k = 0;\n            const len = doc.length;\n            for (k; k < len; k++) {\n                this.remove(doc[k]);\n            }\n            return;\n        }\n        if (doc.$loki === undefined) {\n            throw new Error("Object is not a document stored in the collection");\n        }\n        try {\n            this.startTransaction();\n            const arr = this.get(doc.$loki, true);\n            const position = arr[1];\n            // already converted but let\'s narrow to make typescript happy\n            let aDoc = (typeof doc === "number") ? this.get(doc) : doc;\n            Object.keys(this._constraints.unique).forEach((key) => {\n                if (key in aDoc) {\n                    this._constraints.unique[key].remove(aDoc.$loki);\n                }\n            });\n            // now that we can efficiently determine the data[] position of newly added document,\n            // submit it for all registered DynamicViews to remove\n            for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n                this._dynamicViews[idx]._removeDocument(position);\n            }\n            this._data.splice(position, 1);\n            // remove id from idIndex\n            this._idIndex.splice(position, 1);\n            // remove from lokimap\n            delete this._lokimap[doc.$loki];\n            // remove id/val kvp from binary tree index\n            for (let ri in this._rangedIndexes) {\n                this._rangedIndexes[ri].index.remove(doc.$loki);\n            }\n            // FullTextSearch.\n            if (this._fullTextSearch !== null) {\n                this._fullTextSearch.removeDocument(doc, position);\n            }\n            this.commit();\n            this._dirty = true; // for autosave scenarios\n            if (!this._disableChangesApi) {\n                this._createChange(this.name, "R", arr[0]);\n            }\n            this.emit("delete", arr[0]);\n            delete doc.$loki;\n            delete doc.meta;\n        }\n        catch (err) {\n            this.rollback();\n            this.emit("error", err);\n            throw err;\n        }\n    }\n    /*------------+\n     | Change API |\n     +------------*/\n    /**\n     * Returns all changes.\n     * @returns {Collection.Change[]}\n     */\n    getChanges() {\n        return this._changes;\n    }\n    /**\n     * Enables/disables changes api.\n     * @param {boolean} disableChangesApi\n     * @param {boolean} disableDeltaChangesApi\n     */\n    setChangesApi(disableChangesApi, disableDeltaChangesApi = true) {\n        this._disableChangesApi = disableChangesApi;\n        this._disableDeltaChangesApi = disableChangesApi ? true : disableDeltaChangesApi;\n    }\n    /**\n     * Clears all the changes.\n     */\n    flushChanges() {\n        this._changes = [];\n    }\n    _getObjectDelta(oldObject, newObject) {\n        const propertyNames = newObject !== null && typeof newObject === "object" ? Object.keys(newObject) : null;\n        if (propertyNames && propertyNames.length && ["string", "boolean", "number"].indexOf(typeof (newObject)) < 0) {\n            const delta = {};\n            for (let i = 0; i < propertyNames.length; i++) {\n                const propertyName = propertyNames[i];\n                if (newObject.hasOwnProperty(propertyName)) {\n                    if (!oldObject.hasOwnProperty(propertyName) || this._constraints.unique[propertyName] !== undefined\n                        || propertyName === "$loki" || propertyName === "meta") {\n                        delta[propertyName] = newObject[propertyName];\n                    }\n                    else {\n                        const propertyDelta = this._getObjectDelta(oldObject[propertyName], newObject[propertyName]);\n                        if (propertyDelta !== undefined && propertyDelta !== {}) {\n                            delta[propertyName] = propertyDelta;\n                        }\n                    }\n                }\n            }\n            return Object.keys(delta).length === 0 ? undefined : delta;\n        }\n        else {\n            return oldObject === newObject ? undefined : newObject;\n        }\n    }\n    /**\n     * Compare changed object (which is a forced clone) with existing object and return the delta\n     */\n    _getChangeDelta(obj, old) {\n        if (old) {\n            return this._getObjectDelta(old, obj);\n        }\n        else {\n            return JSON.parse(JSON.stringify(obj));\n        }\n    }\n    /**\n     * Creates a clone of the current status of an object and associates operation and collection name,\n     * so the parent db can aggregate and generate a changes object for the entire db\n     */\n    _createChange(name, op, obj, old) {\n        this._changes.push({\n            name,\n            operation: op,\n            obj: op === "U" && !this._disableDeltaChangesApi\n                ? this._getChangeDelta(obj, old)\n                : JSON.parse(JSON.stringify(obj))\n        });\n    }\n    _createInsertChange(obj) {\n        this._createChange(this.name, "I", obj);\n    }\n    _createUpdateChange(obj, old) {\n        this._createChange(this.name, "U", obj, old);\n    }\n    _insertMetaWithChange(obj) {\n        this._insertMeta(obj);\n        this._createInsertChange(obj);\n    }\n    _updateMetaWithChange(obj, old) {\n        this._updateMeta(obj);\n        this._createUpdateChange(obj, old);\n    }\n    _insertMeta(obj) {\n        if (this._disableMeta) {\n            return;\n        }\n        if (!obj.meta) {\n            obj.meta = {\n                version: 0,\n                revision: 0,\n                created: 0\n            };\n        }\n        obj.meta.created = (new Date()).getTime();\n        obj.meta.revision = 0;\n    }\n    _updateMeta(obj) {\n        if (this._disableMeta) {\n            return;\n        }\n        obj.meta.updated = (new Date()).getTime();\n        obj.meta.revision += 1;\n    }\n    get(id, returnPosition = false) {\n        if (!returnPosition) {\n            let doc = this._lokimap[id];\n            if (doc === undefined)\n                return null;\n            return doc;\n        }\n        const data = this._idIndex;\n        let max = data.length - 1;\n        let min = 0;\n        let mid = (min + max) >> 1;\n        id = typeof id === "number" ? id : parseInt(id, 10);\n        if (isNaN(id)) {\n            throw new TypeError("Passed id is not an integer");\n        }\n        while (data[min] < data[max]) {\n            mid = (min + max) >> 1;\n            if (data[mid] < id) {\n                min = mid + 1;\n            }\n            else {\n                max = mid;\n            }\n        }\n        if (max === min && data[min] === id) {\n            if (returnPosition) {\n                return [this._data[min], min];\n            }\n            return this._data[min];\n        }\n        return null;\n    }\n    /**\n     * Retrieve doc by Unique index\n     * @param {string} field - name of uniquely indexed property to use when doing lookup\n     * @param {any} value - unique value to search for\n     * @returns {object} document matching the value passed\n     */\n    by(field, value) {\n        // for least amount of overhead, we will directly\n        // access index rather than use find codepath\n        let lokiId = this._constraints.unique[field].get(value);\n        if (!this._cloneObjects) {\n            return this._lokimap[lokiId];\n        }\n        else {\n            return clone(this._lokimap[lokiId], this._cloneMethod);\n        }\n    }\n    /**\n     * Find one object by index property, by property equal to value\n     * @param {object} query - query object used to perform search with\n     * @returns {(object|null)} First matching document, or null if none\n     */\n    findOne(query) {\n        query = query || {};\n        // Instantiate ResultSet and exec find op passing firstOnly = true param\n        const result = this.chain().find(query, true).data();\n        if (Array.isArray(result) && result.length === 0) {\n            return null;\n        }\n        else {\n            if (!this._cloneObjects) {\n                return result[0];\n            }\n            else {\n                return clone(result[0], this._cloneMethod);\n            }\n        }\n    }\n    /**\n     * Chain method, used for beginning a series of chained find() and/or view() operations\n     * on a collection.\n     *\n     * @param {array} transform - Ordered array of transform step objects similar to chain\n     * @param {object} parameters - Object containing properties representing parameters to substitute\n     * @returns {ResultSet} (this) ResultSet, or data array if any map or join functions where called\n     */\n    chain(transform, parameters) {\n        const rs = new result_set_ResultSet(this);\n        if (transform === undefined) {\n            return rs;\n        }\n        return rs.transform(transform, parameters);\n    }\n    /**\n     * Find method, api is similar to mongodb.\n     * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n     * @example {@tutorial Query Examples}\n     * @param {object} query - \'mongo-like\' query object\n     * @returns {array} Array of matching documents\n     */\n    find(query) {\n        return this.chain().find(query).data();\n    }\n    /**\n     * Find object by unindexed field by property equal to value,\n     * simply iterates and returns the first element matching the query\n     */\n    findOneUnindexed(prop, value) {\n        let i = this._data.length;\n        let doc;\n        while (i--) {\n            if (this._data[i][prop] === value) {\n                doc = this._data[i];\n                return doc;\n            }\n        }\n        return null;\n    }\n    /**\n     * Transaction methods\n     */\n    /**\n     * start the transation\n     */\n    startTransaction() {\n        if (this._transactional) {\n            // backup any ranged indexes\n            let rib = {};\n            for (let ri in this._rangedIndexes) {\n                rib[ri].indexTypeName = this._rangedIndexes[ri].indexTypeName;\n                rib[ri].comparatorName = this._rangedIndexes[ri].comparatorName;\n                rib[ri].index = this._rangedIndexes[ri].index.backup();\n            }\n            this._cached = {\n                index: this._idIndex,\n                data: clone(this._data, this._cloneMethod),\n                rangedIndexes: rib,\n            };\n            // propagate startTransaction to dynamic views\n            for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n                this._dynamicViews[idx].startTransaction();\n            }\n        }\n    }\n    /**\n     * Commit the transaction.\n     */\n    commit() {\n        if (this._transactional) {\n            this._cached = null;\n            // propagate commit to dynamic views\n            for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n                this._dynamicViews[idx].commit();\n            }\n        }\n    }\n    /**\n     * Rollback the transaction.\n     */\n    rollback() {\n        if (this._transactional) {\n            if (this._cached !== null) {\n                this._idIndex = this._cached.index;\n                this._data = this._cached.data;\n                for (let i = 0; i < this._data.length; i++) {\n                    this._data[i] = this._defineNestedProperties(this._data[i]);\n                }\n                // restore ranged indexes\n                for (let ri in this._cached.rangedIndexes) {\n                    // shortcut reference to serialized meta\n                    let sri = this._cached.rangedIndexes[ri];\n                    // lookup index factory function in map based on index type name\n                    let rif = ranged_indexes["a" /* RangedIndexFactoryMap */][sri.indexTypeName];\n                    // lookup comparator function in map based on comparator name\n                    let ricmp = comparators["a" /* ComparatorMap */][sri.comparatorName];\n                    // using index type (from meta), index factory and comparator... create instance of ranged index\n                    let rii = rif(ri, ricmp);\n                    // now ask new index instance to inflate from plain object\n                    rii.restore(sri.index);\n                    // attach class instance to our collection\'s ranged index\'s (index) instance property\n                    this._rangedIndexes[ri].index = rii;\n                }\n                // propagate rollback to dynamic views\n                for (let idx = 0; idx < this._dynamicViews.length; idx++) {\n                    this._dynamicViews[idx].rollback();\n                }\n            }\n        }\n    }\n    /**\n     * Query the collection by supplying a javascript filter function.\n     * @example\n     * let results = coll.where(function(obj) {\n       *   return obj.legs === 8;\n       * });\n     * @param {function} fun - filter function to run against all collection docs\n     * @returns {array} all documents which pass your filter function\n     */\n    where(fun) {\n        return this.chain().where(fun).data();\n    }\n    /**\n     * Map Reduce operation\n     * @param {function} mapFunction - function to use as map function\n     * @param {function} reduceFunction - function to use as reduce function\n     * @returns {data} The result of your mapReduce operation\n     */\n    mapReduce(mapFunction, reduceFunction) {\n        return reduceFunction(this._data.map(mapFunction));\n    }\n    /**\n     * Join two collections on specified properties\n     * @param {array} joinData - array of documents to \'join\' to this collection\n     * @param {string} leftJoinProp - property name in collection\n     * @param {string} rightJoinProp - property name in joinData\n     * @param {function} mapFun - (Optional) map function to use\n     * @param dataOptions - options to data() before input to your map function\n     * @param [dataOptions.removeMeta] - allows removing meta before calling mapFun\n     * @param [dataOptions.forceClones] - forcing the return of cloned objects to your map object\n     * @param [dataOptions.forceCloneMethod] - allows overriding the default or collection specified cloning method\n     * @returns {ResultSet} Result of the mapping operation\n     */\n    eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions) {\n        return new result_set_ResultSet(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions);\n    }\n    /* ------ STAGING API -------- */\n    /**\n     * (Staging API) create a stage and/or retrieve it\n     */\n    getStage(name) {\n        if (!this._stages[name]) {\n            this._stages[name] = {};\n        }\n        return this._stages[name];\n    }\n    /**\n     * a collection of objects recording the changes applied through a commmitStage\n     */\n    /**\n     * (Staging API) create a copy of an object and insert it into a stage\n     */\n    stage(stageName, obj) {\n        const copy = JSON.parse(JSON.stringify(obj));\n        this.getStage(stageName)[obj.$loki] = copy;\n        return copy;\n    }\n    /**\n     * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n     * then create a message to be inserted in the commitlog\n     * @param {string} stageName - name of stage\n     * @param {string} message\n     */\n    commitStage(stageName, message) {\n        const stage = this.getStage(stageName);\n        const timestamp = new Date().getTime();\n        for (const prop in stage) {\n            this.update(stage[prop]);\n            this._commitLog.push({\n                timestamp,\n                message,\n                data: JSON.parse(JSON.stringify(stage[prop]))\n            });\n        }\n        this._stages[stageName] = {};\n    }\n    /**\n     * Returns all values of a field.\n     * @param {string} field - the field name\n     * @return {any}: the array of values\n     */\n    extract(field) {\n        const result = [];\n        for (let i = 0; i < this._data.length; i++) {\n            result.push(this._data[i][field]);\n        }\n        return result;\n    }\n    /**\n     * Finds the minimum value of a field.\n     * @param {string} field - the field name\n     * @return {number} the minimum value\n     */\n    min(field) {\n        return Math.min.apply(null, this.extractNumerical(field));\n    }\n    /**\n     * Finds the maximum value of a field.\n     * @param {string} field - the field name\n     * @return {number} the maximum value\n     */\n    max(field) {\n        return Math.max.apply(null, this.extractNumerical(field));\n    }\n    /**\n     * Finds the minimum value and its index of a field.\n     * @param {string} field - the field name\n     * @return {object} - index and value\n     */\n    minRecord(field) {\n        const result = {\n            index: 0,\n            value: 0\n        };\n        if (this._data.length === 0) {\n            result.index = null;\n            result.value = null;\n            return result;\n        }\n        result.index = this._data[0].$loki;\n        result.value = parseFloat(this._data[0][field]);\n        for (let i = 1; i < this._data.length; i++) {\n            const val = parseFloat(this._data[i][field]);\n            if (result.value > val) {\n                result.value = val;\n                result.index = this._data[i].$loki;\n            }\n        }\n        return result;\n    }\n    /**\n     * Finds the maximum value and its index of a field.\n     * @param {string} field - the field name\n     * @return {object} - index and value\n     */\n    maxRecord(field) {\n        const result = {\n            index: 0,\n            value: 0\n        };\n        if (this._data.length === 0) {\n            result.index = null;\n            result.value = null;\n            return result;\n        }\n        result.index = this._data[0].$loki;\n        result.value = parseFloat(this._data[0][field]);\n        for (let i = 1; i < this._data.length; i++) {\n            const val = parseFloat(this._data[i][field]);\n            if (result.value < val) {\n                result.value = val;\n                result.index = this._data[i].$loki;\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns all values of a field as numbers (if possible).\n     * @param {string} field - the field name\n     * @return {number[]} - the number array\n     */\n    extractNumerical(field) {\n        return this.extract(field).map(parseFloat).filter(Number).filter((n) => !(isNaN(n)));\n    }\n    /**\n     * Calculates the average numerical value of a field\n     * @param {string} field - the field name\n     * @returns {number} average of property in all docs in the collection\n     */\n    avg(field) {\n        return average(this.extractNumerical(field));\n    }\n    /**\n     * Calculate the standard deviation of a field.\n     * @param {string} field - the field name\n     * @return {number} the standard deviation\n     */\n    stdDev(field) {\n        return standardDeviation(this.extractNumerical(field));\n    }\n    /**\n     * Calculates the mode of a field.\n     * @param {string} field - the field name\n     * @return {number} the mode\n     */\n    mode(field) {\n        const dict = {};\n        const data = this.extractNumerical(field);\n        let mode = data[0];\n        let maxCount = -Infinity;\n        for (let i = 0; i < data.length; i++) {\n            const el = data[i];\n            if (dict[el]) {\n                dict[el]++;\n            }\n            else {\n                dict[el] = 1;\n            }\n            if (dict[el] > maxCount) {\n                mode = el;\n                maxCount = dict[el];\n            }\n        }\n        return mode;\n    }\n    /**\n     * Calculates the median of a field.\n     * @param {string} field - the field name\n     * @return {number} the median\n     */\n    median(field) {\n        const values = this.extractNumerical(field);\n        values.sort((a, b) => a - b);\n        const half = Math.floor(values.length / 2);\n        if (values.length % 2) {\n            return values[half];\n        }\n        else {\n            return (values[half - 1] + values[half]) / 2.0;\n        }\n    }\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n\n// CONCATENATED MODULE: ./packages/loki/src/avl_index.ts\n/**\n * LokiDB AVL Balanced Binary Tree Index implementation.\n * To support duplicates, we use siblings (array) in tree nodes.\n * Basic AVL components guided by William Fiset tutorials at :\n * https://github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/AVLTreeRecursive.java\n * https://www.youtube.com/watch?v=g4y2h70D6Nk&list=PLDV1Zeh2NRsD06x59fxczdWLhDDszUHKt\n */\nclass AvlTreeIndex {\n    /**\n     * Initializes index with property name and a comparer function.\n     */\n    constructor(name, comparator) {\n        this.nodes = {};\n        this.apex = null;\n        this.name = name;\n        this.comparator = comparator;\n    }\n    backup() {\n        let result = new AvlTreeIndex(this.name, this.comparator);\n        result.nodes = JSON.parse(JSON.stringify(this.nodes));\n        result.apex = this.apex;\n        return result;\n    }\n    restore(tree) {\n        this.name = tree.name;\n        this.comparator = tree.comparator;\n        this.nodes = JSON.parse(JSON.stringify(tree.nodes));\n        this.apex = tree.apex;\n    }\n    /**\n     * Used for inserting a new value into the BinaryTreeIndex\n     * @param id Unique Id (such as $loki) to associate with value\n     * @param val Value to be indexed and inserted into binary tree\n     */\n    insert(id, val) {\n        if (id <= 0) {\n            throw new Error("avl index ids are required to be numbers greater than zero");\n        }\n        let node = this.nodes[id] = {\n            id: id,\n            value: val,\n            parent: null,\n            balance: 0,\n            height: 0,\n            left: null,\n            right: null,\n            siblings: []\n        };\n        if (!this.apex) {\n            this.apex = id;\n            return;\n        }\n        this.insertNode(this.nodes[this.apex], node);\n    }\n    /**\n     * Recursively inserts a treenode and re-balances if needed.\n     * @param current\n     * @param node\n     */\n    insertNode(current, node) {\n        switch (this.comparator(node.value, current.value)) {\n            case 0:\n                // eq\n                current.siblings.push(node.id);\n                node.parent = current.id;\n                break;\n            case 1:\n                // gt\n                if (current.right) {\n                    this.insertNode(this.nodes[current.right], node);\n                    this.updateBalance(current);\n                }\n                else {\n                    current.right = node.id;\n                    node.parent = current.id;\n                    this.updateBalance(current);\n                }\n                break;\n            case -1:\n                // lt\n                if (current.left) {\n                    this.insertNode(this.nodes[current.left], node);\n                    this.updateBalance(current);\n                }\n                else {\n                    current.left = node.id;\n                    node.parent = current.id;\n                    this.updateBalance(current);\n                }\n                break;\n            default: throw new Error("Invalid comparator result");\n        }\n        if (current.balance < -1) {\n            if (current.left === null) {\n                throw new Error("insertNode.balance() : left child should not be null");\n            }\n            if (this.nodes[current.left].balance <= 0) {\n                this.leftLeftCase(current);\n            }\n            else {\n                this.leftRightCase(current);\n            }\n        }\n        if (current.balance > 1) {\n            if (current.right === null) {\n                throw new Error("insertNode.balance() : right child should not be null");\n            }\n            if (this.nodes[current.right].balance >= 0) {\n                this.rightRightCase(current);\n            }\n            else {\n                this.rightLeftCase(current);\n            }\n        }\n        return current.height;\n    }\n    /**\n     * Updates height and balance (calculation) for tree node\n     * @param node\n     */\n    updateBalance(node) {\n        let hl = node.left ? this.nodes[node.left].height : -1;\n        let hr = node.right ? this.nodes[node.right].height : -1;\n        //node.height = 1 + Math.max(hl, hr);\n        node.height = (hl > hr) ? 1 + hl : 1 + hr;\n        node.balance = hr - hl;\n    }\n    /**\n     * Balance the \'double left-heavy\' condition\n     * @param node\n     */\n    leftLeftCase(node) {\n        return this.rotateRight(node);\n    }\n    /**\n     * Balance the \'(parent) left heavy, (child) right heavy\' condition\n     * @param node\n     */\n    leftRightCase(node) {\n        if (!node.left) {\n            throw new Error("leftRightCase: left child not set");\n        }\n        node.left = this.rotateLeft(this.nodes[node.left]).id;\n        return this.rotateRight(node);\n    }\n    /**\n     * Balance the \'double right-heavy\' condition\n     * @param node\n     */\n    rightRightCase(node) {\n        return this.rotateLeft(node);\n    }\n    /**\n     * Balance the \'(parent) right heavy, (child) left heavy\' condition\n     * @param node\n     */\n    rightLeftCase(node) {\n        if (!node.right) {\n            throw new Error("rightLeftCase: right child not set");\n        }\n        node.right = this.rotateRight(this.nodes[node.right]).id;\n        return this.rotateLeft(node);\n    }\n    /**\n     * Left rotation of node. Swaps right child into current location.\n     * @param node\n     */\n    rotateLeft(node) {\n        if (!node.right) {\n            throw new Error("rotateLeft: right child was unavailable.");\n        }\n        let parent = (node.parent) ? this.nodes[node.parent] : null;\n        let right = this.nodes[node.right];\n        // assume rights (old) left branch as our (new) right branch\n        node.right = right.left;\n        if (node.right) {\n            this.nodes[node.right].parent = node.id;\n        }\n        // right will be new parent to node and assume old node\'s parent\n        right.left = node.id;\n        right.parent = node.parent;\n        node.parent = right.id;\n        // remap parent child pointer to right\n        if (parent) {\n            if (parent.left === node.id) {\n                parent.left = right.id;\n            }\n            else if (parent.right === node.id) {\n                parent.right = right.id;\n            }\n            else {\n                throw new Error("rotateLeft() : attempt to remap parent back to child failed... not found");\n            }\n        }\n        else {\n            if (this.apex !== node.id) {\n                throw new Error("rightRotate expecting parentless node to be apex");\n            }\n            this.apex = right.id;\n        }\n        // recalculate height and balance for swapped nodes\n        this.updateBalance(node);\n        this.updateBalance(right);\n        return right;\n    }\n    /**\n     * Right rotation of node. Swaps left child into current location.\n     * @param node\n     */\n    rotateRight(node) {\n        if (!node.left) {\n            throw new Error("rotateRight : left child unavailable");\n        }\n        let parent = (node.parent) ? this.nodes[node.parent] : null;\n        let left = this.nodes[node.left];\n        // assume left\'s (old) right branch as our (new) left branch\n        node.left = left.right;\n        if (left.right) {\n            this.nodes[left.right].parent = node.id;\n        }\n        // \'node\' will be right child of left\n        left.right = node.id;\n        left.parent = node.parent;\n        node.parent = left.id;\n        if (parent) {\n            if (parent.left === node.id) {\n                parent.left = left.id;\n            }\n            else {\n                parent.right = left.id;\n            }\n        }\n        else {\n            if (this.apex !== node.id) {\n                throw new Error("rightRotate expecting parentless node to be apex");\n            }\n            this.apex = left.id;\n        }\n        // recalculate height and balance for swapped nodes\n        this.updateBalance(node);\n        this.updateBalance(left);\n        return left;\n    }\n    /**\n     * Diagnostic method for examining tree contents and structure\n     * @param node\n     */\n    getValuesAsTree(node) {\n        if (this.apex === null)\n            return null;\n        node = node || this.nodes[this.apex];\n        return {\n            id: node.id,\n            val: node.value,\n            siblings: node.siblings,\n            balance: node.balance,\n            height: node.height,\n            left: node.left ? this.getValuesAsTree(this.nodes[node.left]) : null,\n            right: node.right ? this.getValuesAsTree(this.nodes[node.right]) : null,\n        };\n    }\n    /**\n     * Updates a value, possibly relocating it, within binary tree\n     * @param id Unique Id (such as $loki) to associate with value\n     * @param val New value to be indexed within binary tree\n     */\n    update(id, val) {\n        let node = this.nodes[id];\n        let cmp = this.comparator(node.value, val);\n        // if the value did not change, or changed to value considered equal to itself, return.\n        if (cmp === 0)\n            return;\n        this.remove(id);\n        this.insert(id, val);\n    }\n    /**\n     * Removes a value from the binary tree index\n     * @param id\n     */\n    remove(id) {\n        if (!this.apex) {\n            throw new Error("remove() : attempting remove when tree has no apex");\n        }\n        this.removeNode(this.nodes[this.apex], id);\n    }\n    /**\n     * Recursive node removal and rebalancer\n     * @param node\n     * @param val\n     */\n    removeNode(node, id) {\n        if (!this.nodes[id]) {\n            throw new Error("removeNode: attempting to remove a node which is not in hashmap");\n        }\n        let val = this.nodes[id].value;\n        switch (this.comparator(val, node.value)) {\n            case 0:\n                // eq - handle siblings if present\n                if (node.siblings.length > 0) {\n                    // if node to remove is alpha sibling...\n                    if (node.id === id) {\n                        // get first sibling as replacement\n                        let alphaSiblingId = node.siblings.shift();\n                        let alphaSibling = this.nodes[alphaSiblingId];\n                        // remap all properties but id and value from node onto alphasibling\n                        alphaSibling.parent = node.parent;\n                        this.updateChildLink(node.parent, id, alphaSiblingId);\n                        if (node.left) {\n                            this.nodes[node.left].parent = alphaSiblingId;\n                        }\n                        if (node.right) {\n                            this.nodes[node.right].parent = alphaSiblingId;\n                        }\n                        alphaSibling.left = node.left;\n                        alphaSibling.right = node.right;\n                        alphaSibling.siblings = node.siblings;\n                        alphaSibling.height = node.height;\n                        alphaSibling.balance = node.balance;\n                        if (this.apex === id) {\n                            this.apex = alphaSiblingId;\n                        }\n                        // parent all remaining siblings alphaSibling (new parent)\n                        for (let si of alphaSibling.siblings) {\n                            this.nodes[si].parent = alphaSiblingId;\n                        }\n                        // delete old node from nodes and return\n                        delete this.nodes[id];\n                        return;\n                    }\n                    // else we are inner sibling\n                    else {\n                        let idx = node.siblings.indexOf(id);\n                        if (idx === -1) {\n                            throw new Error("Unable to remove sibling from parented sibling");\n                        }\n                        node.siblings.splice(idx, 1);\n                        delete this.nodes[id];\n                        return;\n                    }\n                }\n                // else we have no siblings, node will be removed\n                else {\n                    // if node to delete has no children\n                    if (!node.left && !node.right) {\n                        // if we have a parent, remove us from either left or right child link\n                        this.updateChildLink(node.parent, node.id, null);\n                        delete this.nodes[id];\n                        if (id === this.apex) {\n                            this.apex = null;\n                        }\n                        return;\n                    }\n                    // if node to delete has only one child we can do simple copy/replace\n                    if (!node.left || !node.right) {\n                        if (node.left) {\n                            this.promoteChild(node, this.nodes[node.left]);\n                            if (this.apex === id) {\n                                this.apex = node.left;\n                            }\n                        }\n                        if (node.right) {\n                            this.promoteChild(node, this.nodes[node.right]);\n                            if (this.apex === id) {\n                                this.apex = node.right;\n                            }\n                        }\n                        return;\n                    }\n                    // node to delete has two children, need swap with inorder successor\n                    // use find inorder successor by default\n                    this.promoteSuccessor(node);\n                    return;\n                }\n            case 1:\n                // gt - search right branch\n                if (!node.right) {\n                    throw new Error("removeNode: Unable to find value in tree");\n                }\n                this.removeNode(this.nodes[node.right], id);\n                break;\n            case -1:\n                // lt - search left branch\n                if (!node.left) {\n                    throw new Error("removeNode: Unable to find value in tree");\n                }\n                this.removeNode(this.nodes[node.left], id);\n                break;\n        }\n        this.updateBalance(node);\n        if (node.balance < -1) {\n            if (node.left === null) {\n                throw new Error("insertNode.balance() : left child should not be null");\n            }\n            if (this.nodes[node.left].balance <= 0) {\n                this.leftLeftCase(node);\n            }\n            else {\n                this.leftRightCase(node);\n            }\n        }\n        if (node.balance > 1) {\n            if (node.right === null) {\n                throw new Error("insertNode.balance() : right child should not be null");\n            }\n            if (this.nodes[node.right].balance >= 0) {\n                this.rightRightCase(node);\n            }\n            else {\n                this.rightLeftCase(node);\n            }\n        }\n    }\n    /**\n     * Utility method for updating a parent\'s child link when it changes\n     * @param parentId\n     * @param oldChildId\n     * @param newChildId\n     */\n    updateChildLink(parentId, oldChildId, newChildId) {\n        if (parentId === null)\n            return;\n        let parent = this.nodes[parentId];\n        if (parent.left === oldChildId) {\n            parent.left = newChildId;\n        }\n        else if (parent.right === oldChildId) {\n            parent.right = newChildId;\n        }\n    }\n    /**\n     * When removing a parent with only child, this does simple remap of child to grandParent.\n     * @param grandParent New parent of \'child\'.\n     * @param parent Node being removed.\n     * @param child Node to reparent to grandParent.\n     */\n    promoteChild(parent, child) {\n        let gpId = parent.parent;\n        if (gpId) {\n            let gp = this.nodes[gpId];\n            if (gp.left === parent.id) {\n                gp.left = child.id;\n            }\n            else if (gp.right === parent.id) {\n                gp.right = child.id;\n            }\n        }\n        // remap (grand) child\'s parent pointer to grandparent (new parent) or null if new apex\n        child.parent = gpId;\n        // remove parent from bst hashmap\n        delete this.nodes[parent.id];\n        return;\n    }\n    /**\n     * Finds a successor to a node and replaces that node with it.\n     * @param node\n     */\n    promoteSuccessor(node) {\n        let oldId = node.id;\n        // assume successor/right branch (for now)\n        if (!node.right || !node.left) {\n            throw new Error("promoteSuccessor() : node to replace does not have two children");\n        }\n        let successor = null;\n        let glsId;\n        let glsValue;\n        let glsSiblings;\n        // if tree is already left heavy,\n        // let\'s replace with predecessor (greatest val in left branch)\n        if (node.balance < 0) {\n            let lchild = this.nodes[node.left];\n            successor = this.findGreaterLeaf(lchild);\n            glsId = successor.id;\n            glsValue = successor.value;\n            glsSiblings = successor.siblings;\n            successor.siblings = [];\n            this.removeNode(lchild, glsId);\n        }\n        // otherwise the tree is either balanced or right heavy,\n        // so let\'s use sucessor (least value in right branch)\n        else {\n            let rchild = this.nodes[node.right];\n            successor = this.findLesserLeaf(rchild);\n            glsId = successor.id;\n            glsValue = successor.value;\n            glsSiblings = successor.siblings;\n            // dont leave any siblings when we (temporarily) \'remove\' or they will assume ownership of old node\n            successor.siblings = [];\n            this.removeNode(rchild, glsId);\n        }\n        // update any parent pointers to node being replaced\n        if (node.parent) {\n            let p = this.nodes[node.parent];\n            if (p.left === oldId)\n                p.left = glsId;\n            if (p.right === oldId)\n                p.right = glsId;\n        }\n        // update any child points to node being replaced\n        if (node.left)\n            this.nodes[node.left].parent = glsId;\n        if (node.right)\n            this.nodes[node.right].parent = glsId;\n        // update (reuse) node instance id and value with that of successor\n        node.id = glsId;\n        node.value = glsValue;\n        node.siblings = glsSiblings;\n        // update hashmap\n        this.nodes[glsId] = node;\n        delete this.nodes[oldId];\n        // if old was apex, update apex to point to successor\n        if (this.apex === oldId)\n            this.apex = glsId;\n        this.updateBalance(node);\n    }\n    /**\n     * Utility method for finding In-Order predecessor to the provided node\n     * @param node Parent node to find leaf node of greatest \'value\'\n    */\n    findGreaterLeaf(node) {\n        if (!node.right) {\n            return node;\n        }\n        let result = this.findGreaterLeaf(this.nodes[node.right]);\n        return result ? result : node;\n    }\n    /**\n     * Utility method for finding In-Order successor to the provided node\n     * @param node Parent Node to find leaf node of least \'value\'\n     */\n    findLesserLeaf(node) {\n        if (!node.left) {\n            return node;\n        }\n        let result = this.findLesserLeaf(this.nodes[node.left]);\n        return result ? result : node;\n    }\n    /**\n     *  Interface method to support ranged queries.  Results sorted by index property.\n     * @param range Options for ranged request.\n     */\n    rangeRequest(range) {\n        if (!this.apex)\n            return [];\n        // if requesting all id\'s sorted by their value\n        if (!range) {\n            return this.collateIds(this.nodes[this.apex]);\n        }\n        if (range.op === "$eq") {\n            let match = this.locate(this.nodes[this.apex], range.val);\n            if (match === null) {\n                return [];\n            }\n            if (match.siblings.length) {\n                return [match.id, ...match.siblings];\n            }\n            return [match.id];\n        }\n        let result = this.collateRequest(this.nodes[this.apex], range);\n        return result;\n    }\n    /**\n     * Implements ranged request operations.\n     * @param node\n     * @param range\n     */\n    collateRequest(node, range) {\n        let result = [];\n        if (range.op === "$eq") {\n            // we use locate instead for $eq range requests\n            throw new Error("collateRequest does not support $eq range request");\n        }\n        let cmp1 = this.comparator(node.value, range.val);\n        let cmp2 = 0;\n        if (range.op === "$between") {\n            if (range.high === null || range.high === undefined) {\n                throw new Error("collateRequest: $between request missing high range value");\n            }\n            cmp2 = this.comparator(node.value, range.high);\n        }\n        if (node.left) {\n            switch (range.op) {\n                case "$lt":\n                case "$lte":\n                    result = this.collateRequest(this.nodes[node.left], range);\n                    break;\n                case "$gt":\n                case "$gte":\n                    // if the current node is still greater than compare value,\n                    // it\'s possible left child will be too\n                    if (cmp1 === 1) {\n                        result = this.collateRequest(this.nodes[node.left], range);\n                    }\n                    break;\n                case "$between":\n                    // only pursue left path if current node greater than (low) range val\n                    if (cmp1 === 1) {\n                        result = this.collateRequest(this.nodes[node.left], range);\n                    }\n                    break;\n                default: break;\n            }\n        }\n        if (!range) {\n            result.push(node.id);\n            result.push(...node.siblings);\n        }\n        else {\n            switch (range.op) {\n                case "$lt":\n                    if (cmp1 === -1) {\n                        result.push(node.id);\n                        result.push(...node.siblings);\n                    }\n                    break;\n                case "$lte":\n                    if (cmp1 === -1 || cmp1 === 0) {\n                        result.push(node.id);\n                        result.push(...node.siblings);\n                    }\n                    break;\n                case "$gt":\n                    if (cmp1 === 1) {\n                        result.push(node.id);\n                        result.push(...node.siblings);\n                    }\n                    break;\n                case "$gte":\n                    if (cmp1 === 1 || cmp1 === 0) {\n                        result.push(node.id);\n                        result.push(...node.siblings);\n                    }\n                    break;\n                case "$between":\n                    if (cmp1 >= 0 && cmp2 <= 0) {\n                        result.push(node.id);\n                        result.push(...node.siblings);\n                    }\n                    break;\n                default: break;\n            }\n        }\n        if (node.right) {\n            if (!range) {\n                result.push(...this.collateRequest(this.nodes[node.right], range));\n            }\n            else {\n                switch (range.op) {\n                    case "$lt":\n                    case "$lte":\n                        // if the current node is still less than compare value,\n                        // it\'s possible right child will be too\n                        if (cmp1 === -1) {\n                            result.push(...this.collateRequest(this.nodes[node.right], range));\n                        }\n                        break;\n                    case "$gt":\n                    case "$gte":\n                        result.push(...this.collateRequest(this.nodes[node.right], range));\n                        break;\n                    case "$between":\n                        // only pursue right path if current node less than (high) range val\n                        if (cmp2 === -1) {\n                            result.push(...this.collateRequest(this.nodes[node.right], range));\n                        }\n                        break;\n                    default: break;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Used on a branch node to return an array of id within that branch, sorted by their value\n     * @param node\n     */\n    collateIds(node) {\n        let result = [];\n        // debug diagnostic\n        if (!node) {\n            return [];\n        }\n        if (node.left) {\n            result = this.collateIds(this.nodes[node.left]);\n        }\n        result.push(node.id);\n        result.push(...node.siblings);\n        if (node.right) {\n            result.push(...this.collateIds(this.nodes[node.right]));\n        }\n        return result;\n    }\n    /**\n     * Traverses tree to a node matching the provided value.\n     * @param node\n     * @param val\n     */\n    /*\n    private locate(node: TreeNode<T>, val: any): TreeNode<T> {\n       switch (this.comparator.compare(val, node.value)) {\n          case 0: return node;\n          case 1:\n             if (!node.right) {\n                return null;\n             }\n  \n             return this.locate(this.nodes[node.right], val);\n          case -1:\n             if (!node.left) {\n                return null;\n             }\n  \n             return this.locate(this.nodes[node.left], val);\n       }\n    }\n    */\n    /**\n     * Inline/Non-recusive \'single value\' ($eq) lookup.\n     * Traverses tree to a node matching the provided value.\n     * @param node\n     * @param val\n     */\n    locate(node, val) {\n        while (node !== null) {\n            switch (this.comparator(val, node.value)) {\n                case 0: return node;\n                case 1:\n                    if (!node.right) {\n                        return null;\n                    }\n                    node = this.nodes[node.right];\n                    break;\n                case -1:\n                    if (!node.left) {\n                        return null;\n                    }\n                    node = this.nodes[node.left];\n                    break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Index integrity check (IRangedIndex interface function)\n     */\n    validateIndex() {\n        // handle null apex condition and verify empty tree and nodes\n        if (!this.apex) {\n            if (Object.keys(this.nodes).length !== 0) {\n                return false;\n            }\n            return true;\n        }\n        // ensure apex has no parent\n        if (this.nodes[this.apex].parent !== null) {\n            return false;\n        }\n        // high level verification - retrieve all node ids ordered by their values\n        let result = this.collateIds(this.nodes[this.apex]);\n        let nc = Object.keys(this.nodes).length;\n        // verify the inorder traversal returned same number of elements as nodes hashmap\n        if (result.length !== nc) {\n            return false;\n        }\n        // if only one result\n        if (result.length === 1) {\n            if (this.nodes[result[0]].parent !== null)\n                return false;\n            if (this.nodes[result[0]].left !== null)\n                return false;\n            if (this.nodes[result[0]].right !== null)\n                return false;\n            return true;\n        }\n        // iterate results and ensure next value is greater or equal to current\n        for (let i = 0; i < result.length - 1; i++) {\n            if (this.comparator(this.nodes[result[i]].value, this.nodes[result[i + 1]].value) === 1) {\n                return false;\n            }\n        }\n        return this.validateNode(this.nodes[this.apex]);\n    }\n    /**\n     * Recursive Node validation routine\n     * @param node\n     */\n    validateNode(node) {\n        // should never have parent or child pointers reference self\n        if ([node.parent, node.left, node.right].indexOf(node.id) !== -1) {\n            return false;\n        }\n        // validate height and balance\n        let hl = (node.left) ? this.nodes[node.left].height : -1;\n        let hr = (node.right) ? this.nodes[node.right].height : -1;\n        let eh = 1 + Math.max(hl, hr);\n        if (node.height !== eh) {\n            return false;\n        }\n        if (node.balance !== hr - hl) {\n            return false;\n        }\n        // verify any siblings parent back to self\n        if (node.siblings.length > 0) {\n            for (let sid of node.siblings) {\n                if (this.nodes[sid].parent !== node.id)\n                    return false;\n            }\n        }\n        // if there is a left child, verify it parents to self and recurse it\n        if (node.left) {\n            if (this.nodes[node.left].parent !== node.id) {\n                return false;\n            }\n            if (!this.validateNode(this.nodes[node.left])) {\n                return false;\n            }\n        }\n        // if there is a right child, verify it parents to self and recurse it\n        if (node.right) {\n            if (this.nodes[node.right].parent !== node.id) {\n                return false;\n            }\n            if (!this.validateNode(this.nodes[node.right])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// CONCATENATED MODULE: ./packages/loki/src/ranged_indexes.ts\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RangedIndexFactoryMap; });\n\n/** Map/Register of named factory functions returning IRangedIndex instances */\nlet RangedIndexFactoryMap = {\n    "avl": (name, comparator) => { return new AvlTreeIndex(name, comparator); }\n};\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LokiEventEmitter; });\n/**\n * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n * constructor that inherits EventEmitter to emit events and trigger\n * listeners that have been added to the event through the on(event, callback) method\n *\n * @constructor LokiEventEmitter\n */\nclass LokiEventEmitter {\n    constructor() {\n        /**\n         * A map, with each property being an array of callbacks.\n         */\n        this._events = {};\n        /**\n         * Determines whether or not the callbacks associated with each event should happen in an async fashion or not.\n         * Default is false, which means events are synchronous\n         */\n        this._asyncListeners = false;\n    }\n    /**\n     * Adds a listener to the queue of callbacks associated to an event\n     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n     * @param {function} listener - callback function of listener to attach\n     * @returns {int} the index of the callback in the array of listeners for a particular event\n     */\n    on(eventName, listener) {\n        let event;\n        if (Array.isArray(eventName)) {\n            eventName.forEach((currentEventName) => {\n                this.on(currentEventName, listener);\n            });\n            return listener;\n        }\n        event = this._events[eventName];\n        if (!event) {\n            event = this._events[eventName] = [];\n        }\n        event.push(listener);\n        return listener;\n    }\n    /**\n     * Emits a particular event\n     * with the option of passing optional parameters which are going to be processed by the callback\n     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n     * @param {string} eventName - the name of the event\n     * @param {object} data - optional object passed with the event\n     */\n    emit(eventName, ...data) {\n        if (eventName && this._events[eventName]) {\n            this._events[eventName].forEach((listener) => {\n                if (this._asyncListeners) {\n                    setTimeout(() => {\n                        listener(...data);\n                    }, 1);\n                }\n                else {\n                    listener(...data);\n                }\n            });\n        }\n    }\n    /**\n     * Alias of EventEmitter.on().\n     */\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    /**\n     * Removes the listener at position \'index\' from the event \'eventName\'\n     * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n     * @param {function} listener - the listener callback function to remove from emitter\n     */\n    removeListener(eventName, listener) {\n        if (Array.isArray(eventName)) {\n            eventName.forEach((currentEventName) => {\n                this.removeListener(currentEventName, listener);\n            });\n        }\n        if (this._events[eventName]) {\n            const listeners = this._events[eventName];\n            listeners.splice(listeners.indexOf(listener), 1);\n        }\n    }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Loki; });\n/* harmony import */ var _event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\n/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _common_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);\n/* harmony import */ var _comparators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);\n/* harmony import */ var _ranged_indexes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);\n/* harmony import */ var _operator_packages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);\n\n\n\n\n\n\nfunction getENV() {\n    if (global !== undefined && (global["android"] || global["NSObject"])) {\n        return "NATIVESCRIPT";\n    }\n    const isNode = global !== undefined && ({}).toString.call(global.process) === "[object process]";\n    if (isNode) {\n        if (global["window"]) {\n            return "NODEJS"; //node-webkit\n        }\n        else {\n            return "NODEJS";\n        }\n    }\n    if (document !== undefined) {\n        if (document.URL.indexOf("http://") === -1 && document.URL.indexOf("https://") === -1) {\n            return "CORDOVA";\n        }\n        return "BROWSER";\n    }\n    const isBrowser = window !== undefined && ({}).toString.call(window) === "[object Window]";\n    if (isBrowser) {\n        return "BROWSER";\n    }\n    throw SyntaxError("Unknown environment...");\n}\nclass Loki extends _event_emitter__WEBPACK_IMPORTED_MODULE_0__[/* LokiEventEmitter */ "a"] {\n    /**\n     * Constructs the main database class.\n     * @param {string} filename - name of the file to be saved to\n     * @param {object} [options={}] - options\n     * @param {Loki.Environment} [options.env] - the javascript environment\n     * @param {Loki.SerializationMethod} [options.serializationMethod=NORMAL] - the serialization method\n     * @param {string} [options.destructureDelimiter="$<\\n"] - string delimiter used for destructured serialization\n     * @param {IComparatorMap} [options.comparatorMap] allows injecting or overriding registered comparators\n     * @param {IRangedIndexFactoryMap} [options.rangedIndexFactoryMap] allows injecting or overriding registered ranged index factories\n     * @param {ILokiOperatorPackageMap} [options.lokiOperatorPackageMap] allows injecting or overriding registered loki operator packages\n     */\n    constructor(filename = "loki.db", options = {}) {\n        super();\n        // persist version of code which created the database to the database.\n        // could use for upgrade scenarios\n        this.databaseVersion = 1.5; // TODO\n        this.engineVersion = 1.5;\n        // persistenceMethod could be \'fs\', \'localStorage\', or \'adapter\'\n        // this is optional option param, otherwise environment detection will be used\n        // if user passes their own adapter we will force this method to \'adapter\' later, so no need to pass method option.\n        this._persistenceMethod = null;\n        // retain reference to optional (non-serializable) persistenceAdapter \'instance\'\n        this._persistenceAdapter = null;\n        // flags used to throttle saves\n        this._throttledSaves = true;\n        this._throttledSaveRunning = null;\n        this._throttledSavePending = null;\n        // autosave support (disabled by default)\n        this._autosave = false;\n        this._autosaveInterval = 5000;\n        this._autosaveRunning = false;\n        this._autosaveHandler = Promise.resolve();\n        this.filename = filename;\n        this._collections = [];\n        ({\n            serializationMethod: this._serializationMethod = "normal",\n            destructureDelimiter: this._destructureDelimiter = "$<\\n",\n            env: this._env = getENV()\n        } = options);\n        this._events = {\n            "init": [],\n            "loaded": [],\n            "flushChanges": [],\n            "close": [],\n            "changes": [],\n            "warning": []\n        };\n        // allow users to inject their own comparators\n        if (options.comparatorMap) {\n            for (let c in options.comparatorMap) {\n                _comparators__WEBPACK_IMPORTED_MODULE_3__[/* ComparatorMap */ "a"][c] = options.comparatorMap[c];\n            }\n        }\n        // allow users to register their own rangedIndex factory functions\n        if (options.rangedIndexFactoryMap) {\n            for (let rif in options.rangedIndexFactoryMap) {\n                _ranged_indexes__WEBPACK_IMPORTED_MODULE_4__[/* RangedIndexFactoryMap */ "a"][rif] = options.rangedIndexFactoryMap[rif];\n            }\n        }\n        // allow users to register their own LokiOperatorPackages or inject functionality within existing ones\n        if (options.lokiOperatorPackageMap) {\n            for (let lop in options.lokiOperatorPackageMap) {\n                _operator_packages__WEBPACK_IMPORTED_MODULE_5__[/* LokiOperatorPackageMap */ "a"][lop] = options.lokiOperatorPackageMap[lop];\n            }\n        }\n        this.on("init", this.clearChanges);\n    }\n    /**\n     * configures options related to database persistence.\n     *\n     * @param {Loki.PersistenceOptions} [options={}] - options\n     * @param {adapter} [options.adapter=auto] - an instance of a loki persistence adapter\n     * @param {boolean} [options.autosave=false] - enables autosave\n     * @param {int} [options.autosaveInterval=5000] - time interval (in milliseconds) between saves (if dirty)\n     * @param {boolean} [options.autoload=false] - enables autoload on loki instantiation\n     * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n     * @param {boolean} [options.throttledSaves=true] - if true, it batches multiple calls to to saveDatabase reducing number of\n     *   disk I/O operations and guaranteeing proper serialization of the calls. Default value is true.\n     * @param {Loki.PersistenceMethod} options.persistenceMethod - a persistence method which should be used (FS_STORAGE, LOCAL_STORAGE...)\n     * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n     */\n    initializePersistence(options = {}) {\n        let loaded = this._autosaveDisable();\n        ({\n            autosave: this._autosave = false,\n            autosaveInterval: this._autosaveInterval = 5000,\n            persistenceMethod: this._persistenceMethod,\n            // TODO\n            //inflate: this.options.inflate,\n            throttledSaves: this._throttledSaves = true\n        } = options);\n        const DEFAULT_PERSISTENCE = {\n            "NODEJS": ["fs-storage"],\n            "BROWSER": ["local-storage", "indexed-storage"],\n            "CORDOVA": ["local-storage", "indexed-storage"],\n            "MEMORY": ["memory-storage"]\n        };\n        const PERSISTENCE_METHODS = {\n            "fs-storage": _common_plugin__WEBPACK_IMPORTED_MODULE_2__[/* PLUGINS */ "a"]["FSStorage"],\n            "local-storage": _common_plugin__WEBPACK_IMPORTED_MODULE_2__[/* PLUGINS */ "a"]["LocalStorage"],\n            "indexed-storage": _common_plugin__WEBPACK_IMPORTED_MODULE_2__[/* PLUGINS */ "a"]["IndexedStorage"],\n            "memory-storage": _common_plugin__WEBPACK_IMPORTED_MODULE_2__[/* PLUGINS */ "a"]["MemoryStorage"]\n        };\n        // process the options\n        if (this._persistenceMethod !== undefined) {\n            // check if the specified persistence method is known\n            if (typeof (PERSISTENCE_METHODS[this._persistenceMethod]) === "function") {\n                this._persistenceAdapter = new (PERSISTENCE_METHODS[this._persistenceMethod]);\n            }\n            else {\n                throw Error("Unknown persistence method.");\n            }\n        }\n        // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n        if (options.adapter !== undefined) {\n            this._persistenceMethod = "adapter";\n            this._persistenceAdapter = options.adapter;\n        }\n        // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n        if (this._persistenceAdapter === null) {\n            let possiblePersistenceMethods = DEFAULT_PERSISTENCE[this._env];\n            if (possiblePersistenceMethods) {\n                for (let i = 0; i < possiblePersistenceMethods.length; i++) {\n                    if (PERSISTENCE_METHODS[possiblePersistenceMethods[i]]) {\n                        this._persistenceMethod = possiblePersistenceMethods[i];\n                        this._persistenceAdapter = new (PERSISTENCE_METHODS[possiblePersistenceMethods[i]]);\n                        break;\n                    }\n                }\n            }\n        }\n        // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before\n        // possible autosave initiation\n        if (options.autoload) {\n            loaded = loaded.then(() => this._loadDatabase(options.inflate, true));\n        }\n        return loaded.then(() => {\n            this._autosaveEnable();\n        });\n    }\n    /**\n     * Copies \'this\' database into a new Loki instance. Object references are shared to make lightweight.\n     * @param {object} options - options\n     * @param {boolean} options.removeNonSerializable - nulls properties not safe for serialization.\n     */\n    copy(options = {}) {\n        const databaseCopy = new Loki(this.filename, { env: this._env });\n        // currently inverting and letting loadJSONObject do most of the work\n        databaseCopy.loadJSONObject(this, {\n            retainDirtyFlags: true\n        });\n        // since our toJSON is not invoked for reference database adapters, this will let us mimic\n        if (options.removeNonSerializable) {\n            databaseCopy._persistenceAdapter = null;\n            for (let idx = 0; idx < databaseCopy._collections.length; idx++) {\n                databaseCopy._collections[idx]._constraints = null;\n                databaseCopy._collections[idx]._ttl = null;\n            }\n        }\n        return databaseCopy;\n    }\n    /**\n     * Adds a collection to the database.\n     * @param {string} name - name of collection to add\n     * @param {object} [options={}] - options to configure collection with.\n     * @param {array} [options.unique=[]] - array of property names to define unique constraints for\n     * @param {array} [options.exact=[]] - array of property names to define exact constraints for\n     * @param {array} [options.indices=[]] - array property names to define binary indexes for\n     * @param {boolean} [options.asyncListeners=false] - whether listeners are called asynchronously\n     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents\n     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes Api\n     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)\n     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user\n     * @param {string} [options.cloneMethod=CloneMethod.DEEP] - the clone method\n     * @param {number} [options.ttl=] - age of document (in ms.) before document is considered aged/stale\n     * @param {number} [options.ttlInterval=] - time interval for clearing out \'aged\' documents; not set by default\n     * @returns {Collection} a reference to the collection which was just added\n     */\n    addCollection(name, options = {}) {\n        // Return an existing collection if a collection with the same name already exists.\n        for (let i = 0; i < this._collections.length; i++) {\n            if (this._collections[i].name === name) {\n                return this._collections[i];\n            }\n        }\n        // Create a new collection otherwise.\n        const collection = new _collection__WEBPACK_IMPORTED_MODULE_1__[/* Collection */ "a"](name, options);\n        this._collections.push(collection);\n        return collection;\n    }\n    loadCollection(collection) {\n        if (!collection.name) {\n            throw new Error("Collection must have a name property to be loaded");\n        }\n        this._collections.push(collection);\n    }\n    /**\n     * Retrieves reference to a collection by name.\n     * @param {string} name - name of collection to look up\n     * @returns {Collection} Reference to collection in database by that name, or null if not found\n     */\n    getCollection(name) {\n        for (let i = 0; i < this._collections.length; i++) {\n            if (this._collections[i].name === name) {\n                return this._collections[i];\n            }\n        }\n        // no such collection\n        this.emit("warning", "collection " + name + " not found");\n        return null;\n    }\n    /**\n     * Renames an existing loki collection\n     * @param {string} oldName - name of collection to rename\n     * @param {string} newName - new name of collection\n     * @returns {Collection} reference to the newly renamed collection\n     */\n    renameCollection(oldName, newName) {\n        const c = this.getCollection(oldName);\n        if (c) {\n            c.name = newName;\n        }\n        return c;\n    }\n    listCollections() {\n        const colls = [];\n        for (let i = 0; i < this._collections.length; i++) {\n            colls.push({\n                name: this._collections[i].name,\n                count: this._collections[i].count()\n            });\n        }\n        return colls;\n    }\n    /**\n     * Removes a collection from the database.\n     * @param {string} collectionName - name of collection to remove\n     */\n    removeCollection(collectionName) {\n        for (let i = 0; i < this._collections.length; i++) {\n            if (this._collections[i].name === collectionName) {\n                const tmpcol = new _collection__WEBPACK_IMPORTED_MODULE_1__[/* Collection */ "a"](collectionName, {});\n                const curcol = this._collections[i];\n                for (const prop in curcol) {\n                    if (curcol[prop] !== undefined && tmpcol[prop] !== undefined) {\n                        curcol[prop] = tmpcol[prop];\n                    }\n                }\n                this._collections.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n     *\n     * @returns {string} Stringified representation of the loki database.\n     */\n    serialize(options = {}) {\n        if (options.serializationMethod === undefined) {\n            options.serializationMethod = this._serializationMethod;\n        }\n        switch (options.serializationMethod) {\n            case "normal":\n                return JSON.stringify(this);\n            case "pretty":\n                return JSON.stringify(this, null, 2);\n            case "destructured":\n                return this.serializeDestructured(); // use default options\n            default:\n                return JSON.stringify(this);\n        }\n    }\n    // alias of serialize\n    toJSON() {\n        return {\n            _env: this._env,\n            _serializationMethod: this._serializationMethod,\n            _autosave: this._autosave,\n            _autosaveInterval: this._autosaveInterval,\n            _collections: this._collections,\n            databaseVersion: this.databaseVersion,\n            engineVersion: this.engineVersion,\n            filename: this.filename,\n            _persistenceAdapter: this._persistenceAdapter,\n            _persistenceMethod: this._persistenceMethod,\n            _throttledSaves: this._throttledSaves\n        };\n    }\n    /**\n     * Database level destructured JSON serialization routine to allow alternate serialization methods.\n     * Internally, Loki supports destructuring via loki "serializationMethod\' option and\n     * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n     * your own structured persistence or data exchange.\n     *\n     * @param {object} options - output format options for use externally to loki\n     * @param {boolean} [options.partitioned=false] - whether db and each collection are separate\n     * @param {int} options.partition - can be used to only output an individual collection or db (-1)\n     * @param {boolean} [options.delimited=true] - whether subitems are delimited or subarrays\n     * @param {string} options.delimiter - override default delimiter\n     *\n     * @returns {string|Array} A custom, restructured aggregation of independent serializations.\n     */\n    serializeDestructured(options = {}) {\n        if (options.partitioned === undefined) {\n            options.partitioned = false;\n        }\n        if (options.delimited === undefined) {\n            options.delimited = true;\n        }\n        if (options.delimiter === undefined) {\n            options.delimiter = this._destructureDelimiter;\n        }\n        // \'partitioned\' along with \'partition\' of 0 or greater is a request for single collection serialization\n        if (options.partitioned === true && options.partition !== undefined && options.partition >= 0) {\n            return this.serializeCollection({\n                delimited: options.delimited,\n                delimiter: options.delimiter,\n                collectionIndex: options.partition\n            });\n        }\n        // not just an individual collection, so we will need to serialize db container via shallow copy\n        let dbcopy = new Loki(this.filename);\n        dbcopy.loadJSONObject(this);\n        for (let idx = 0; idx < dbcopy._collections.length; idx++) {\n            dbcopy._collections[idx]._data = [];\n        }\n        // if we -only- wanted the db container portion, return it now\n        if (options.partitioned === true && options.partition === -1) {\n            // since we are deconstructing, override serializationMethod to normal for here\n            return dbcopy.serialize({\n                serializationMethod: "normal"\n            });\n        }\n        // at this point we must be deconstructing the entire database\n        // start by pushing db serialization into first array element\n        const reconstruct = [];\n        reconstruct.push(dbcopy.serialize({\n            serializationMethod: "normal"\n        }));\n        dbcopy = null;\n        // push collection data into subsequent elements\n        for (let idx = 0; idx < this._collections.length; idx++) {\n            let result = this.serializeCollection({\n                delimited: options.delimited,\n                delimiter: options.delimiter,\n                collectionIndex: idx\n            });\n            // NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n            if (options.partitioned === false && options.delimited === false) {\n                if (!Array.isArray(result)) {\n                    throw new Error("a nondelimited, non partitioned collection serialization did not return an expected array");\n                }\n                // Array.concat would probably duplicate memory overhead for copying strings.\n                // Instead copy each individually, and clear old value after each copy.\n                // Hopefully this will allow g.c. to reduce memory pressure, if needed.\n                for (let sidx = 0; sidx < result.length; sidx++) {\n                    reconstruct.push(result[sidx]);\n                    result[sidx] = null;\n                }\n                reconstruct.push("");\n            }\n            else {\n                reconstruct.push(result);\n            }\n        }\n        // Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n        if (options.partitioned) {\n            // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n            // useful for simple future adaptations of existing persistence adapters to save collections separately\n            if (options.delimited) {\n                return reconstruct;\n            }\n            // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n            // This format might be the most versatile for \'rolling your own\' partitioned sync or save.\n            // Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n            else {\n                return reconstruct;\n            }\n        }\n        else {\n            // D : one big Delimited string { partitioned: false, delimited : true }\n            // This is the method Loki will use internally if \'destructured\'.\n            // Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n            if (options.delimited) {\n                // indicate no more collections\n                reconstruct.push("");\n                return reconstruct.join(options.delimiter);\n            }\n            // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n            // This format might be best candidate for custom synchronous syncs or saves\n            else {\n                // indicate no more collections\n                reconstruct.push("");\n                return reconstruct;\n            }\n        }\n    }\n    /**\n     * Collection level utility method to serialize a collection in a \'destructured\' format\n     *\n     * @param {object} options - used to determine output of method\n     * @param {int} options.delimited - whether to return single delimited string or an array\n     * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n     * @param {int} options.collectionIndex -  specify which collection to serialize data for\n     *\n     * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n     */\n    serializeCollection(options = {}) {\n        if (options.delimited === undefined) {\n            options.delimited = true;\n        }\n        if (options.collectionIndex === undefined) {\n            throw new Error("serializeCollection called without \'collectionIndex\' option");\n        }\n        const doccount = this._collections[options.collectionIndex].count();\n        let resultlines = [];\n        for (let docidx = 0; docidx < doccount; docidx++) {\n            resultlines.push(JSON.stringify(this._collections[options.collectionIndex]._data[docidx]));\n        }\n        // D and DA\n        if (options.delimited) {\n            // indicate no more documents in collection (via empty delimited string)\n            resultlines.push("");\n            return resultlines.join(options.delimiter);\n        }\n        else {\n            // NDAA and NDA\n            return resultlines;\n        }\n    }\n    /**\n     * Database level destructured JSON deserialization routine to minimize memory overhead.\n     * Internally, Loki supports destructuring via loki "serializationMethod\' option and\n     * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n     * your own structured persistence or data exchange.\n     *\n     * @param {string|array} destructuredSource - destructured json or array to deserialize from\n     * @param {object} options - source format options\n     * @param {boolean} [options.partitioned=false] - whether db and each collection are separate\n     * @param {int} options.partition - can be used to deserialize only a single partition\n     * @param {boolean} [options.delimited=true] - whether subitems are delimited or subarrays\n     * @param {string} options.delimiter - override default delimiter\n     *\n     * @returns {object|array} An object representation of the deserialized database, not yet applied to \'this\' db or document array\n     */\n    deserializeDestructured(destructuredSource, options = {}) {\n        if (options.partitioned === undefined) {\n            options.partitioned = false;\n        }\n        if (options.delimited === undefined) {\n            options.delimited = true;\n        }\n        if (options.delimiter === undefined) {\n            options.delimiter = this._destructureDelimiter;\n        }\n        // Partitioned\n        // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n        // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n        // -or- single partition\n        if (options.partitioned) {\n            // handle single partition\n            if (options.partition !== undefined) {\n                // db only\n                if (options.partition === -1) {\n                    return JSON.parse(destructuredSource[0]);\n                }\n                // single collection, return doc array\n                return this.deserializeCollection(destructuredSource[options.partition + 1], options);\n            }\n            // Otherwise we are restoring an entire partitioned db\n            const cdb = JSON.parse(destructuredSource[0]);\n            const collCount = cdb._collections.length;\n            for (let collIndex = 0; collIndex < collCount; collIndex++) {\n                // attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n                cdb._collections[collIndex]._data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n            }\n            return cdb;\n        }\n        // Non-Partitioned\n        // D : one big Delimited string { partitioned: false, delimited : true }\n        // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n        let workarray = [];\n        // D\n        if (options.delimited) {\n            workarray = destructuredSource.split(options.delimiter);\n            destructuredSource = null; // lower memory pressure\n            if (workarray.length === 0) {\n                return null;\n            }\n        }\n        // NDA\n        else {\n            workarray = destructuredSource;\n        }\n        // first line is database and collection shells\n        const cdb = JSON.parse(workarray[0]);\n        const collCount = cdb._collections.length;\n        workarray[0] = null;\n        let collIndex = 0;\n        let lineIndex = 1;\n        let done = false;\n        while (!done) {\n            // empty string indicates either end of collection or end of file\n            if (workarray[lineIndex] === "") {\n                // if no more collections to load into, we are done\n                if (++collIndex > collCount) {\n                    done = true;\n                }\n            }\n            else {\n                cdb._collections[collIndex]._data.push(JSON.parse(workarray[lineIndex]));\n            }\n            // lower memory pressure and advance iterator\n            workarray[lineIndex++] = null;\n        }\n        return cdb;\n    }\n    /**\n     * Collection level utility function to deserializes a destructured collection.\n     *\n     * @param {string|string[]} destructuredSource - destructured representation of collection to inflate\n     * @param {object} options - used to describe format of destructuredSource input\n     * @param {int} [options.delimited=false] - whether source is delimited string or an array\n     * @param {string} options.delimiter - if delimited, this is delimiter to use (if other than default)\n     *\n     * @returns {Array} an array of documents to attach to collection.data.\n     */\n    deserializeCollection(destructuredSource, options = {}) {\n        if (options.partitioned === undefined) {\n            options.partitioned = false;\n        }\n        if (options.delimited === undefined) {\n            options.delimited = true;\n        }\n        if (options.delimiter === undefined) {\n            options.delimiter = this._destructureDelimiter;\n        }\n        let workarray = [];\n        if (options.delimited) {\n            workarray = destructuredSource.split(options.delimiter);\n            workarray.pop();\n        }\n        else {\n            workarray = destructuredSource;\n        }\n        for (let idx = 0; idx < workarray.length; idx++) {\n            workarray[idx] = JSON.parse(workarray[idx]);\n        }\n        return workarray;\n    }\n    /**\n     * Inflates a loki database from a serialized JSON string\n     *\n     * @param {string} serializedDb - a serialized loki database string\n     * @param {object} options - apply or override collection level settings\n     * @param {boolean} options.retainDirtyFlags - whether collection dirty flags will be preserved\n     */\n    loadJSON(serializedDb, options) {\n        let dbObject;\n        if (serializedDb.length === 0) {\n            dbObject = {};\n        }\n        else {\n            // using option defined in instantiated db not what was in serialized db\n            switch (this._serializationMethod) {\n                case "normal":\n                case "pretty":\n                    dbObject = JSON.parse(serializedDb);\n                    break;\n                case "destructured":\n                    dbObject = this.deserializeDestructured(serializedDb);\n                    break;\n                default:\n                    dbObject = JSON.parse(serializedDb);\n                    break;\n            }\n        }\n        this.loadJSONObject(dbObject, options);\n    }\n    loadJSONObject(dbObject, options = {}) {\n        const len = dbObject._collections ? dbObject._collections.length : 0;\n        this.filename = dbObject.filename;\n        this._collections = [];\n        for (let i = 0; i < len; ++i) {\n            this._collections.push(_collection__WEBPACK_IMPORTED_MODULE_1__[/* Collection */ "a"].fromJSONObject(dbObject._collections[i], options));\n        }\n    }\n    /**\n     * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n     * Does not actually destroy the db.\n     *\n     * @returns {Promise} a Promise that resolves after closing the database succeeded\n     */\n    close() {\n        // for autosave scenarios, we will let close perform final save (if dirty)\n        // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n        if (this._autosave) {\n            return this._autosaveDisable()\n                .then(() => {\n                if (this._autosaveDirty()) {\n                    return this.saveDatabase();\n                }\n                return Promise.resolve();\n            });\n        }\n        return Promise.resolve().then(() => {\n            this.emit("close");\n        });\n    }\n    /**-------------------------+\n     | Changes API               |\n     +--------------------------*/\n    /**\n     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n     * so it\'s possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n     */\n    /**\n     * (Changes API) : takes all the changes stored in each\n     * collection and creates a single array for the entire database. If an array of names\n     * of collections is passed then only the included collections will be tracked.\n     *\n     * @param {Array} [arrayOfCollectionNames=] - array of collection names. No arg means all collections are processed.\n     * @returns {Array} array of changes\n     * @see private method _createChange() in Collection\n     */\n    generateChangesNotification(arrayOfCollectionNames) {\n        let changes = [];\n        const selectedCollections = arrayOfCollectionNames\n            || this._collections.map((coll) => coll.name);\n        this._collections.forEach((coll) => {\n            if (selectedCollections.indexOf(coll.name) !== -1) {\n                changes = changes.concat(coll.getChanges());\n            }\n        });\n        return changes;\n    }\n    /**\n     * (Changes API) - stringify changes for network transmission\n     * @returns {string} string representation of the changes\n     */\n    serializeChanges(collectionNamesArray) {\n        return JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n    }\n    /**\n     * (Changes API) : clears all the changes in all collections.\n     */\n    clearChanges() {\n        this._collections.forEach((coll) => {\n            if (coll.flushChanges) {\n                coll.flushChanges();\n            }\n        });\n    }\n    /**\n     * Wait for throttledSaves to complete and invoke your callback when drained or duration is met.\n     *\n     * @param {object} options - configuration options\n     * @param {boolean} [options.recursiveWait=true] - if after queue is drained, another save was kicked off, wait for it\n     * @param {boolean} [options.recursiveWaitLimit=false] - limit our recursive waiting to a duration\n     * @param {number} [options.recursiveWaitLimitDuration=2000] - cutoff in ms to stop recursively re-draining\n     * @param {Date} [options.started=now()] - the start time of the recursive wait duration\n     * @returns {Promise} a Promise that resolves when save queue is drained, it is passed a sucess parameter value\n     */\n    throttledSaveDrain(options = {}) {\n        const now = (new Date()).getTime();\n        if (!this._throttledSaves) {\n            return Promise.resolve();\n        }\n        if (options.recursiveWait === undefined) {\n            options.recursiveWait = true;\n        }\n        if (options.recursiveWaitLimit === undefined) {\n            options.recursiveWaitLimit = false;\n        }\n        if (options.recursiveWaitLimitDuration === undefined) {\n            options.recursiveWaitLimitDuration = 2000;\n        }\n        if (options.started === undefined) {\n            options.started = new Date();\n        }\n        // if save is pending\n        if (this._throttledSaves && this._throttledSaveRunning !== null) {\n            // if we want to wait until we are in a state where there are no pending saves at all\n            if (options.recursiveWait) {\n                // queue the following meta callback for when it completes\n                return Promise.resolve(Promise.all([this._throttledSaveRunning, this._throttledSavePending])).then(() => {\n                    if (this._throttledSaveRunning !== null || this._throttledSavePending !== null) {\n                        if (options.recursiveWaitLimit && (now - options.started.getTime() > options.recursiveWaitLimitDuration)) {\n                            return Promise.reject({});\n                        }\n                        return this.throttledSaveDrain(options);\n                    }\n                    else {\n                        return Promise.resolve();\n                    }\n                });\n            }\n            // just notify when current queue is depleted\n            else {\n                return Promise.resolve(this._throttledSaveRunning);\n            }\n        }\n        // no save pending, just callback\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Internal load logic, decoupled from throttling/contention logic\n     *\n     * @param {object} options - an object containing inflation options for each collection\n     * @param {boolean} ignore_not_found - does not raise an error if database is not found\n     * @returns {Promise} a Promise that resolves after the database is loaded\n     */\n    _loadDatabase(options = {}, ignore_not_found = false) {\n        // the persistenceAdapter should be present if all is ok, but check to be sure.\n        if (this._persistenceAdapter === null) {\n            return Promise.reject(new Error("persistenceAdapter not configured"));\n        }\n        return Promise.resolve(this._persistenceAdapter.loadDatabase(this.filename))\n            .then((dbString) => {\n            if (typeof (dbString) === "string") {\n                this.loadJSON(dbString, options);\n                this.emit("load", this);\n                // if adapter has returned a js object (other than null or error) attempt to load from JSON object\n            }\n            else if (typeof (dbString) === "object" && dbString !== null && !(dbString instanceof Error)) {\n                this.loadJSONObject(dbString, options);\n                this.emit("load", this);\n            }\n            else {\n                throw dbString;\n            }\n        }).catch(e => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else if (e != null) {\n                throw new TypeError("The persistence adapter did not load a serialized DB string or object.");\n            }\n            else if (!ignore_not_found) {\n                throw new Error("Database not found.");\n            }\n        });\n    }\n    /**\n     * Handles manually loading from an adapter storage (such as fs-storage)\n     *    This method utilizes loki configuration options (if provided) to determine which\n     *    persistence method to use, or environment detection (if configuration was not provided).\n     *    To avoid contention with any throttledSaves, we will drain the save queue first.\n     *\n     * If you are configured with autosave, you do not need to call this method yourself.\n     *\n     * @param {object} [options={}] - if throttling saves and loads, this controls how we drain save queue before loading\n     * @param {boolean} [options.recursiveWait=true] wait recursively until no saves are queued\n     * @param {boolean} [options.recursiveWaitLimit=false] limit our recursive waiting to a duration\n     * @param {number} [options.recursiveWaitLimitDelay=2000] cutoff in ms to stop recursively re-draining\n     * @param {Date} [options.started=now()] - the start time of the recursive wait duration\n     * @returns {Promise} a Promise that resolves after the database is loaded\n     */\n    loadDatabase(options = {}) {\n        // if throttling disabled, just call internal\n        if (!this._throttledSaves) {\n            return this._loadDatabase(options);\n        }\n        // try to drain any pending saves in the queue to lock it for loading\n        return this.throttledSaveDrain(options).then(() => {\n            // pause/throttle saving until loading is done\n            this._throttledSaveRunning = this._loadDatabase(options).then(() => {\n                // now that we are finished loading, if no saves were throttled, disable flag\n                this._throttledSaveRunning = null;\n            });\n            return this._throttledSaveRunning;\n        }, () => {\n            throw new Error("Unable to pause save throttling long enough to read database");\n        });\n    }\n    _saveDatabase() {\n        // the persistenceAdapter should be present if all is ok, but check to be sure.\n        if (this._persistenceAdapter === null) {\n            return Promise.reject(new Error("persistenceAdapter not configured"));\n        }\n        // check if the adapter is requesting (and supports) a \'reference\' mode export\n        if (this._persistenceAdapter.mode === "reference" && typeof this._persistenceAdapter.exportDatabase === "function") {\n            // filename may seem redundant but loadDatabase will need to expect this same filename\n            return Promise.resolve(this._persistenceAdapter.exportDatabase(this.filename, this.copy({ removeNonSerializable: true })))\n                .then(() => {\n                this._autosaveClearFlags();\n                this.emit("save");\n            });\n        }\n        // otherwise just pass the serialized database to adapter\n        // persistenceAdapter might be asynchronous, so we must clear `dirty` immediately\n        // or autosave won\'t work if an update occurs between here and the callback\n        this._autosaveClearFlags();\n        return Promise.resolve(this._persistenceAdapter.saveDatabase(this.filename, this.serialize()))\n            .then(() => {\n            this.emit("save");\n        });\n    }\n    /**\n     * Handles manually saving to an adapter storage (such as fs-storage)\n     *    This method utilizes loki configuration options (if provided) to determine which\n     *    persistence method to use, or environment detection (if configuration was not provided).\n     *\n     * If you are configured with autosave, you do not need to call this method yourself.\n     *\n     * @returns {Promise} a Promise that resolves after the database is persisted\n     */\n    saveDatabase() {\n        if (!this._throttledSaves) {\n            return this._saveDatabase();\n        }\n        // if the db save is currently running, a new promise for a next db save is created\n        // all calls to save db will get this new promise which will be processed right after\n        // the current db save is finished\n        if (this._throttledSaveRunning !== null && this._throttledSavePending === null) {\n            this._throttledSavePending = Promise.resolve(this._throttledSaveRunning).then(() => {\n                this._throttledSaveRunning = null;\n                this._throttledSavePending = null;\n                return this.saveDatabase();\n            });\n        }\n        if (this._throttledSavePending !== null) {\n            return this._throttledSavePending;\n        }\n        this._throttledSaveRunning = this._saveDatabase().then(() => {\n            this._throttledSaveRunning = null;\n        });\n        return this._throttledSaveRunning;\n    }\n    /**\n     * Handles deleting a database from the underlying storage adapter\n     *\n     * @returns {Promise} a Promise that resolves after the database is deleted\n     */\n    deleteDatabase() {\n        // the persistenceAdapter should be present if all is ok, but check to be sure.\n        if (this._persistenceAdapter === null) {\n            return Promise.reject(new Error("persistenceAdapter not configured"));\n        }\n        return Promise.resolve(this._persistenceAdapter.deleteDatabase(this.filename));\n    }\n    /****************\n     * Autosave API\n     ****************/\n    /**\n     * Check whether any collections are "dirty" meaning we need to save the (entire) database\n     * @returns {boolean} - true if database has changed since last autosave, otherwise false\n     */\n    _autosaveDirty() {\n        for (let idx = 0; idx < this._collections.length; idx++) {\n            if (this._collections[idx]._dirty) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Resets dirty flags on all collections.\n     */\n    _autosaveClearFlags() {\n        for (let idx = 0; idx < this._collections.length; idx++) {\n            this._collections[idx]._dirty = false;\n        }\n    }\n    /**\n     * Starts periodically saves to the underlying storage adapter.\n     */\n    _autosaveEnable() {\n        if (!this._autosave || this._autosaveRunning) {\n            return;\n        }\n        this._autosaveRunning = true;\n        const interval = setInterval(() => {\n            if (!this._autosaveRunning) {\n                clearInterval(interval);\n            }\n            else if (this._autosaveDirty()) {\n                this._autosaveHandler = this._autosaveHandler\n                    .then(() => {\n                    return this.saveDatabase();\n                });\n            }\n        }, this._autosaveInterval);\n    }\n    /**\n     * Stops the autosave interval timer.\n     */\n    _autosaveDisable() {\n        this._autosaveRunning = false;\n        return this._autosaveHandler;\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function("return this")() || (1, eval)("this");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _loki__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Loki", function() { return _loki__WEBPACK_IMPORTED_MODULE_0__["a"]; });\n\n/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Collection", function() { return _collection__WEBPACK_IMPORTED_MODULE_1__["a"]; });\n\n\n\n_loki__WEBPACK_IMPORTED_MODULE_0__[/* Loki */ "a"]["Collection"] = _collection__WEBPACK_IMPORTED_MODULE_1__[/* Collection */ "a"];\n\n/* harmony default export */ __webpack_exports__["default"] = (_loki__WEBPACK_IMPORTED_MODULE_0__[/* Loki */ "a"]);\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=lokidb.loki.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxva2lkYi9sb2tpL2xva2lkYi5sb2tpLmpzPzYzM2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUs4RTtBQUNwRixDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkYsc0JBQXNCLEVBQUU7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QywyRkFBMkYsZ0JBQWdCLEVBQUU7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsMkZBQTJGLGtCQUFrQixFQUFFO0FBQy9HLDJGQUEyRixpQkFBaUIsRUFBRTtBQUM5RztBQUNBLDJGQUEyRixtQkFBbUIsRUFBRTtBQUNoSDtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsK0JBQStCLEVBQUU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJLEdBQUcsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLElBQUk7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxJQUFJO0FBQ2YsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkYsOEJBQThCLEVBQUU7O0FBRTNIO0FBQ0E7QUFDQSxrQ0FBa0MsMkNBQTJDO0FBQzdFOzs7QUFH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QUFDUDtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiI0NTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIkBsb2tpZGIvbG9raVwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJAbG9raWRiL2xva2lcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHR7IHJvb3RbXCJAbG9raWRiL2xva2lcIl0gPSBmYWN0b3J5KCk7IHJvb3RbXCJMb2tpXCJdID0gcm9vdFtcIkBsb2tpZGIvbG9raVwiXS5kZWZhdWx0OyB9XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA4KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENvbXBhcmF0b3JNYXA7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IENyZWF0ZUphdmFzY3JpcHRDb21wYXJhdG9yICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgQ3JlYXRlQWJzdHJhY3RKYXZhc2NyaXB0Q29tcGFyYXRvciAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IENyZWF0ZUFic3RyYWN0RGF0ZUphdmFzY3JpcHRDb21wYXJhdG9yICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgQ3JlYXRlTG9raUNvbXBhcmF0b3IgKi9cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfb3BlcmF0b3JfcGFja2FnZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBMb2tpT3BlcmF0b3JQYWNrYWdlcywgUmFuZ2VkSW5kZXggYW5kIENvbXBhcmF0b3IgaW50ZXJmYWNlcywgYXMgd2VsbCBhc1xuICogZ2xvYmFsIG1hcCBvYmplY3QgaW5zdGFuY2VzIGZvciByZWdpc3RlcmVkIExva2lPcGVyYXRvclBhY2thZ2VzLCBSYW5nZWRJbmRleCBpbXBsZW1lbnRhdGlvbnMsIGFuZCBDb21wYXJhdG9yIGZ1bmN0aW9uc1xuICovXG5cbi8qKiBNYXAvUmVnaXN0ZXIgb2YgbmFtZWQgSUxva2lDb21wYXJlciBmdW5jdGlvbnMgcmV0dXJuaW5nIC0xLCAwLCAxIGZvciBsdC9lcS9ndCBhc3NlcnRpb25zIGZvciB0d28gcGFzc2VkIHBhcmFtZXRlcnMgKi9cbmxldCBDb21wYXJhdG9yTWFwID0ge1xuICAgIFwianNcIjogQ3JlYXRlSmF2YXNjcmlwdENvbXBhcmF0b3IoKSxcbiAgICBcImFic3RyYWN0LWpzXCI6IENyZWF0ZUFic3RyYWN0SmF2YXNjcmlwdENvbXBhcmF0b3IoKSxcbiAgICBcImFic3RyYWN0LWRhdGVcIjogQ3JlYXRlQWJzdHJhY3REYXRlSmF2YXNjcmlwdENvbXBhcmF0b3IoKSxcbiAgICBcImxva2lcIjogQ3JlYXRlTG9raUNvbXBhcmF0b3IoKVxufTtcbi8qKiBUeXBlc2NyaXB0LWZyaWVuZGx5IGZhY3RvcnkgZm9yIHN0cm9uZ2x5IHR5cGVkICdqcycgY29tcGFyYXRvcnMgKi9cbmZ1bmN0aW9uIENyZWF0ZUphdmFzY3JpcHRDb21wYXJhdG9yKCkge1xuICAgIHJldHVybiAodmFsLCB2YWwyKSA9PiB7XG4gICAgICAgIGlmICh2YWwgPT09IHZhbDIpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHZhbCA8IHZhbDIpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH07XG59XG4vKiogVHlwZXNjcmlwdC1mcmllbmRseSBmYWN0b3J5IGZvciBzdHJvbmdseSB0eXBlZCAnYWJzdHJhY3QganMnIGNvbXBhcmF0b3JzICovXG5mdW5jdGlvbiBDcmVhdGVBYnN0cmFjdEphdmFzY3JpcHRDb21wYXJhdG9yKCkge1xuICAgIHJldHVybiAodmFsLCB2YWwyKSA9PiB7XG4gICAgICAgIGlmICh2YWwgPT0gdmFsMilcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAodmFsIDwgdmFsMilcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfTtcbn1cbi8qKlxuICogQ29tcGFyYXRvciB3aGljaCBhdHRlbXB0cyB0byBkZWFsIHdpdGggZGVhbCB3aXRoIGRhdGVzIGF0IGNvbXBhcmF0b3IgbGV2ZWwuXG4gKiBTaG91bGQgd29yayBmb3IgZGF0ZXMgaW4gYW55IG9mIHRoZSBvYmplY3QsIHN0cmluZywgYW5kIG51bWJlciBmb3JtYXRzXG4gKi9cbmZ1bmN0aW9uIENyZWF0ZUFic3RyYWN0RGF0ZUphdmFzY3JpcHRDb21wYXJhdG9yKCkge1xuICAgIHJldHVybiAodmFsLCB2YWwyKSA9PiB7XG4gICAgICAgIGxldCB2MSA9IChuZXcgRGF0ZSh2YWwpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICBsZXQgdjIgPSAobmV3IERhdGUodmFsMikudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIGlmICh2MSA9PSB2MilcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAodjEgPCB2MilcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfTtcbn1cbi8qKiBUeXBlc2NyaXB0LWZyaWVuZGx5IGZhY3RvcnkgZm9yIHN0cm9uZ2x5IHR5cGVkICdsb2tpJyBjb21wYXJhdG9ycyAqL1xuZnVuY3Rpb24gQ3JlYXRlTG9raUNvbXBhcmF0b3IoKSB7XG4gICAgcmV0dXJuICh2YWwsIHZhbDIpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdChfb3BlcmF0b3JfcGFja2FnZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBhZXFIZWxwZXIgKi8gXCJiXCJdKSh2YWwsIHZhbDIpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmIChPYmplY3QoX29wZXJhdG9yX3BhY2thZ2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogbHRIZWxwZXIgKi8gXCJjXCJdKSh2YWwsIHZhbDIsIGZhbHNlKSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQTFVHSU5TOyB9KTtcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBsZXQgZ2xvYjtcbiAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICBnbG9iID0gZ2xvYmFsO1xuICAgIH0pKGdsb2JhbCAhPT0gdW5kZWZpbmVkICYmIGdsb2JhbCB8fCB0aGlzKTtcbiAgICByZXR1cm4gZ2xvYjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICBjb25zdCBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcbiAgICBjb25zdCBzeW0gPSBTeW1ib2wuZm9yKFwiTE9LSVwiKTtcbiAgICBpZiAoZ2xvYmFsW3N5bV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbG9iYWxbc3ltXSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsW3N5bV07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUExVR0lOUyA9IGNyZWF0ZSgpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyg3KSkpXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYWVxSGVscGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbHRIZWxwZXI7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGd0SGVscGVyICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNvcnRIZWxwZXI7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IExva2lPcGVyYXRvclBhY2thZ2UgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBMb2tpQWJzdHJhY3RPcGVyYXRvclBhY2thZ2UgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBDb21wYXJhdG9yT3BlcmF0b3JQYWNrYWdlICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExva2lPcGVyYXRvclBhY2thZ2VNYXA7IH0pO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nICdsb2tpJyBhYnN0cmFjdCBlcXVhbGl0eSB3aGljaCBpcyBhIGxpdHRsZSBtb3JlIGFic3RyYWN0IHRoYW4gPT1cbiAqICAgICBhZXFIZWxwZXIoNSwgJzUnKSA9PT0gdHJ1ZVxuICogICAgIGFlcUhlbHBlcig1LjAsICc1JykgPT09IHRydWVcbiAqICAgICBhZXFIZWxwZXIobmV3IERhdGUoXCIxLzEvMjAxMVwiKSwgbmV3IERhdGUoXCIxLzEvMjAxMVwiKSkgPT09IHRydWVcbiAqICAgICBhZXFIZWxwZXIoe2E6MX0sIHt6OjR9KSA9PT0gdHJ1ZSAoYWxsIG9iamVjdHMgc29ydGVkIGVxdWFsbHkpXG4gKiAgICAgYWVxSGVscGVyKFsxLCAyLCAzXSwgWzEsIDNdKSA9PT0gZmFsc2VcbiAqICAgICBhZXFIZWxwZXIoWzEsIDIsIDNdLCBbMSwgMiwgM10pID09PSB0cnVlXG4gKiAgICAgYWVxSGVscGVyKHVuZGVmaW5lZCwgbnVsbCkgPT09IHRydWVcbiAqIEBwYXJhbSB7YW55fSBwcm9wMVxuICogQHBhcmFtIHthbnl9IHByb3AyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYWVxSGVscGVyKHByb3AxLCBwcm9wMikge1xuICAgIGlmIChwcm9wMSA9PT0gcHJvcDIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vICdmYWxzeScgYW5kIEJvb2xlYW4gaGFuZGxpbmdcbiAgICBpZiAoIXByb3AxIHx8ICFwcm9wMiB8fCBwcm9wMSA9PT0gdHJ1ZSB8fCBwcm9wMiA9PT0gdHJ1ZSB8fCBwcm9wMSAhPT0gcHJvcDEgfHwgcHJvcDIgIT09IHByb3AyKSB7XG4gICAgICAgIGxldCB0MTtcbiAgICAgICAgbGV0IHQyO1xuICAgICAgICAvLyBkYXRlcyBhbmQgTmFOIGNvbmRpdGlvbnMgKHR5cGVkIGRhdGVzIGJlZm9yZSBzZXJpYWxpemF0aW9uKVxuICAgICAgICBzd2l0Y2ggKHByb3AxKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB0MSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdDEgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgICAgICB0MSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICAgICAgdDEgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHQxID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdDEgPSAocHJvcDEgPT09IHByb3AxKSA/IDkgOiAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocHJvcDIpIHtcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHQyID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICB0MiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgICAgIHQyID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICAgICAgICB0MiA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgdDIgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0MiA9IChwcm9wMiA9PT0gcHJvcDIpID8gOSA6IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25lIG9yIGJvdGggaXMgZWRnZSBjYXNlXG4gICAgICAgIGlmICh0MSAhPT0gOSB8fCB0MiAhPT0gOSkge1xuICAgICAgICAgICAgcmV0dXJuICh0MSA9PT0gdDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSAnTnVtYmVyLWxpa2UnIGNvbXBhcmlzb25zXG4gICAgbGV0IGN2MSA9IE51bWJlcihwcm9wMSk7XG4gICAgbGV0IGN2MiA9IE51bWJlcihwcm9wMik7XG4gICAgLy8gaWYgb25lIG9yIGJvdGggYXJlICdudW1iZXItbGlrZScuLi5cbiAgICBpZiAoY3YxID09PSBjdjEgfHwgY3YyID09PSBjdjIpIHtcbiAgICAgICAgcmV0dXJuIChjdjEgPT09IGN2Mik7XG4gICAgfVxuICAgIC8vIG5vdCBzdHJpY3QgZXF1YWwgbm9yIGxlc3MgdGhhbiBub3IgZ3Qgc28gbXVzdCBiZSBtaXhlZCB0eXBlcywgY29udmVydCB0byBzdHJpbmcgYW5kIHVzZSB0aGF0IHRvIGNvbXBhcmVcbiAgICBjdjEgPSBwcm9wMS50b1N0cmluZygpO1xuICAgIGN2MiA9IHByb3AyLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIChjdjEgPT0gY3YyKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyAnbGVzcy10aGFuJyBjb25kaXRpb25zIGZvciBvcHMsIHNvcnRpbmcsIGFuZCBiaW5hcnkgaW5kaWNlcy5cbiAqICAgICBJbiB0aGUgZnV0dXJlIHdlIG1pZ2h0IHdhbnQgJGx0IGFuZCAkZ3Qgb3BzIHRvIHVzZSB0aGVpciBvd24gZnVuY3Rpb25hbGl0eS9oZWxwZXIuXG4gKiAgICAgU2luY2UgYmluYXJ5IGluZGljZXMgb24gYSBwcm9wZXJ0eSBtaWdodCBuZWVkIHRvIGluZGV4IFsxMiwgTmFOLCBuZXcgRGF0ZSgpLCBJbmZpbml0eV0sIHdlXG4gKiAgICAgbmVlZCB0aGlzIGZ1bmN0aW9uIChhcyB3ZWxsIGFzIGd0SGVscGVyKSB0byBhbHdheXMgZW5zdXJlIG9uZSB2YWx1ZSBpcyBMVCwgR1QsIG9yIEVRIHRvIGFub3RoZXIuXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGx0SGVscGVyKHByb3AxLCBwcm9wMiwgZXF1YWwpIHtcbiAgICAvLyBpZiBvbmUgb2YgdGhlIHBhcmFtcyBpcyBmYWxzeSBvciBzdHJpY3RseSB0cnVlIG9yIG5vdCBlcXVhbCB0byBpdHNlbGZcbiAgICAvLyAwLCAwLjAsIFwiXCIsIE5hTiwgbnVsbCwgdW5kZWZpbmVkLCBub3QgZGVmaW5lZCwgZmFsc2UsIHRydWVcbiAgICBpZiAoIXByb3AxIHx8ICFwcm9wMiB8fCBwcm9wMSA9PT0gdHJ1ZSB8fCBwcm9wMiA9PT0gdHJ1ZSB8fCBwcm9wMSAhPT0gcHJvcDEgfHwgcHJvcDIgIT09IHByb3AyKSB7XG4gICAgICAgIGxldCB0MTtcbiAgICAgICAgbGV0IHQyO1xuICAgICAgICBzd2l0Y2ggKHByb3AxKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB0MSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdDEgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgICAgICB0MSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICAgICAgdDEgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHQxID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGlmIHN0cmljdCBlcXVhbCBwcm9iYWJseSAwIHNvIHNvcnQgaGlnaGVyLCBvdGhlcndpc2UgcHJvYmFibHkgTmFOIHNvIHNvcnQgbG93ZXIgdGhhbiBldmVuIG51bGxcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdDEgPSAocHJvcDEgPT09IHByb3AxKSA/IDkgOiAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocHJvcDIpIHtcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHQyID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICB0MiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgICAgIHQyID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICAgICAgICB0MiA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgdDIgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0MiA9IChwcm9wMiA9PT0gcHJvcDIpID8gOSA6IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25lIG9yIGJvdGggaXMgZWRnZSBjYXNlXG4gICAgICAgIGlmICh0MSAhPT0gOSB8fCB0MiAhPT0gOSkge1xuICAgICAgICAgICAgcmV0dXJuICh0MSA9PT0gdDIpID8gZXF1YWwgOiAodDEgPCB0Mik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgYm90aCBhcmUgbnVtYmVycyAoc3RyaW5nIGVuY29kZWQgb3Igbm90KSwgY29tcGFyZSBhcyBudW1iZXJzXG4gICAgbGV0IGN2MSA9IE51bWJlcihwcm9wMSk7XG4gICAgbGV0IGN2MiA9IE51bWJlcihwcm9wMik7XG4gICAgaWYgKGN2MSA9PT0gY3YxICYmIGN2MiA9PT0gY3YyKSB7XG4gICAgICAgIGlmIChjdjEgPCBjdjIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGN2MSA+IGN2MilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cbiAgICBpZiAoY3YxID09PSBjdjEgJiYgY3YyICE9PSBjdjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjdjIgPT09IGN2MiAmJiBjdjEgIT09IGN2MSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwcm9wMSA8IHByb3AyKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocHJvcDEgPiBwcm9wMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcm9wMSA9PSBwcm9wMilcbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIC8vIG5vdCBzdHJpY3QgZXF1YWwgbm9yIGxlc3MgdGhhbiBub3IgZ3Qgc28gbXVzdCBiZSBtaXhlZCB0eXBlcywgY29udmVydCB0byBzdHJpbmcgYW5kIHVzZSB0aGF0IHRvIGNvbXBhcmVcbiAgICBjdjEgPSBwcm9wMS50b1N0cmluZygpO1xuICAgIGN2MiA9IHByb3AyLnRvU3RyaW5nKCk7XG4gICAgaWYgKGN2MSA8IGN2Mikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN2MSA9PSBjdjIpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqIEBwYXJhbSB7YW55fSBwcm9wMVxuICogQHBhcmFtIHthbnl9IHByb3AyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVxdWFsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZ3RIZWxwZXIocHJvcDEsIHByb3AyLCBlcXVhbCkge1xuICAgIC8vICdmYWxzeScgYW5kIEJvb2xlYW4gaGFuZGxpbmdcbiAgICBpZiAoIXByb3AxIHx8ICFwcm9wMiB8fCBwcm9wMSA9PT0gdHJ1ZSB8fCBwcm9wMiA9PT0gdHJ1ZSB8fCBwcm9wMSAhPT0gcHJvcDEgfHwgcHJvcDIgIT09IHByb3AyKSB7XG4gICAgICAgIGxldCB0MTtcbiAgICAgICAgbGV0IHQyO1xuICAgICAgICBzd2l0Y2ggKHByb3AxKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB0MSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdDEgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgICAgICB0MSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICAgICAgdDEgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHQxID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIE5hTiAwXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHQxID0gKHByb3AxID09PSBwcm9wMSkgPyA5IDogMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHByb3AyKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB0MiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdDIgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgICAgICB0MiA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICAgICAgdDIgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHQyID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdDIgPSAocHJvcDIgPT09IHByb3AyKSA/IDkgOiAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9uZSBvciBib3RoIGlzIGVkZ2UgY2FzZVxuICAgICAgICBpZiAodDEgIT09IDkgfHwgdDIgIT09IDkpIHtcbiAgICAgICAgICAgIHJldHVybiAodDEgPT09IHQyKSA/IGVxdWFsIDogKHQxID4gdDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIGJvdGggYXJlIG51bWJlcnMgKHN0cmluZyBlbmNvZGVkIG9yIG5vdCksIGNvbXBhcmUgYXMgbnVtYmVyc1xuICAgIGxldCBjdjEgPSBOdW1iZXIocHJvcDEpO1xuICAgIGxldCBjdjIgPSBOdW1iZXIocHJvcDIpO1xuICAgIGlmIChjdjEgPT09IGN2MSAmJiBjdjIgPT09IGN2Mikge1xuICAgICAgICBpZiAoY3YxID4gY3YyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdjEgPCBjdjIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcXVhbDtcbiAgICB9XG4gICAgaWYgKGN2MSA9PT0gY3YxICYmIGN2MiAhPT0gY3YyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN2MiA9PT0gY3YyICYmIGN2MSAhPT0gY3YxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcDEgPiBwcm9wMilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHByb3AxIDwgcHJvcDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJvcDEgPT0gcHJvcDIpXG4gICAgICAgIHJldHVybiBlcXVhbDtcbiAgICAvLyBub3Qgc3RyaWN0IGVxdWFsIG5vciBsZXNzIHRoYW4gbm9yIGd0IHNvIG11c3QgYmUgZGF0ZXMgb3IgbWl4ZWQgdHlwZXNcbiAgICAvLyBjb252ZXJ0IHRvIHN0cmluZyBhbmQgdXNlIHRoYXQgdG8gY29tcGFyZVxuICAgIGN2MSA9IHByb3AxLnRvU3RyaW5nKCk7XG4gICAgY3YyID0gcHJvcDIudG9TdHJpbmcoKTtcbiAgICBpZiAoY3YxID4gY3YyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3YxID09IGN2Mikge1xuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQHBhcmFtIHthbnl9IHByb3AxXG4gKiBAcGFyYW0ge2FueX0gcHJvcDJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVzY2VuZGluZ1xuICogQHJldHVybnMge251bWJlcn1cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gc29ydEhlbHBlcihwcm9wMSwgcHJvcDIsIGRlc2NlbmRpbmcpIHtcbiAgICBpZiAoYWVxSGVscGVyKHByb3AxLCBwcm9wMikpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChsdEhlbHBlcihwcm9wMSwgcHJvcDIsIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gZGVzY2VuZGluZyA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKGd0SGVscGVyKHByb3AxLCBwcm9wMiwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBkZXNjZW5kaW5nID8gLTEgOiAxO1xuICAgIH1cbiAgICAvLyBub3QgbHQsIG5vdCBndCBzbyBpbXBsaWVkIGVxdWFsaXR5LS0gZGF0ZSBjb21wYXRpYmxlXG4gICAgcmV0dXJuIDA7XG59XG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgTG9raU9wZXJhdG9yUGFja2FnZSwgdXNpbmcgZmFzdGVzdCBqYXZhc2NyaXB0IGNvbXBhcmlzb24gb3BlcmF0b3JzLlxuICovXG5jbGFzcyBMb2tpT3BlcmF0b3JQYWNrYWdlIHtcbiAgICAvLyBjb21wYXJpc29uIG9wZXJhdG9yc1xuICAgIC8vIGEgaXMgdGhlIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gYiBpcyB0aGUgcXVlcnkgdmFsdWVcbiAgICAkZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG4gICAgJG5lKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgIT09IGI7XG4gICAgfVxuICAgICRndChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID4gYjtcbiAgICB9XG4gICAgJGd0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID49IGI7XG4gICAgfVxuICAgICRsdChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIDwgYjtcbiAgICB9XG4gICAgJGx0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIDw9IGI7XG4gICAgfVxuICAgICRiZXR3ZWVuKGEsIHJhbmdlKSB7XG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGEgPj0gcmFuZ2VbMF0gJiYgYSA8PSByYW5nZVsxXTtcbiAgICB9XG4gICAgJGluKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSAhPT0gLTE7XG4gICAgfVxuICAgICRuaW4oYSwgYikge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKGEpID09PSAtMTtcbiAgICB9XG4gICAgJGtleWluKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgaW4gYjtcbiAgICB9XG4gICAgJG5rZXlpbihhLCBiKSB7XG4gICAgICAgIHJldHVybiAhKGEgaW4gYik7XG4gICAgfVxuICAgICRkZWZpbmVkaW4oYSwgYikge1xuICAgICAgICByZXR1cm4gYlthXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAkdW5kZWZpbmVkaW4oYSwgYikge1xuICAgICAgICByZXR1cm4gYlthXSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAkcmVnZXgoYSwgYikge1xuICAgICAgICByZXR1cm4gYi50ZXN0KGEpO1xuICAgIH1cbiAgICAkY29udGFpbnNOb25lKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLiRjb250YWluc0FueShhLCBiKTtcbiAgICB9XG4gICAgJGNvbnRhaW5zQW55KGEsIGIpIHtcbiAgICAgICAgY29uc3QgY2hlY2tGbiA9IHRoaXMuY29udGFpbnNDaGVja0ZuKGEpO1xuICAgICAgICBpZiAoY2hlY2tGbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGIpKSA/IChiLnNvbWUoY2hlY2tGbikpIDogKGNoZWNrRm4oYikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgJGNvbnRhaW5zKGEsIGIpIHtcbiAgICAgICAgY29uc3QgY2hlY2tGbiA9IHRoaXMuY29udGFpbnNDaGVja0ZuKGEpO1xuICAgICAgICBpZiAoY2hlY2tGbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGIpKSA/IChiLmV2ZXJ5KGNoZWNrRm4pKSA6IChjaGVja0ZuKGIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgICR0eXBlKGEsIGIpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgYTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwiZGF0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodHlwZW9mIGIgIT09IFwib2JqZWN0XCIpID8gKHR5cGUgPT09IGIpIDogdGhpcy5kb1F1ZXJ5T3AodHlwZSwgYik7XG4gICAgfVxuICAgICRmaW5pdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gKGIgPT09IGlzRmluaXRlKGEpKTtcbiAgICB9XG4gICAgJHNpemUoYSwgYikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgPyAoYS5sZW5ndGggPT09IGIpIDogdGhpcy5kb1F1ZXJ5T3AoYS5sZW5ndGgsIGIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgJGxlbihhLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgPyAoYS5sZW5ndGggPT09IGIpIDogdGhpcy5kb1F1ZXJ5T3AoYS5sZW5ndGgsIGIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgJHdoZXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIoYSkgPT09IHRydWU7XG4gICAgfVxuICAgIC8vIGZpZWxkLWxldmVsIGxvZ2ljYWwgb3BlcmF0b3JzXG4gICAgLy8gYSBpcyB0aGUgdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBiIGlzIHRoZSBuZXN0ZWQgcXVlcnkgb3BlcmF0aW9uIChmb3IgJyRub3QnKVxuICAgIC8vICAgb3IgYW4gYXJyYXkgb2YgbmVzdGVkIHF1ZXJ5IG9wZXJhdGlvbnMgKGZvciAnJGFuZCcgYW5kICckb3InKVxuICAgICRub3QoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9RdWVyeU9wKGEsIGIpO1xuICAgIH1cbiAgICAkYW5kKGEsIGIpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMCwgbGVuID0gYi5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb1F1ZXJ5T3AoYSwgYltpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgJG9yKGEsIGIpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMCwgbGVuID0gYi5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvUXVlcnlPcChhLCBiW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb1F1ZXJ5T3AodmFsLCBvcCkge1xuICAgICAgICBmb3IgKGxldCBwIGluIG9wKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob3AsIHApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbcF0odmFsLCBvcFtwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb250YWluc0NoZWNrRm4oYSkge1xuICAgICAgICBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgcmV0dXJuIChiKSA9PiBhLmluZGV4T2YoYikgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoYikgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBMb2tpT3BlcmF0b3JQYWNrYWdlIHdoaWNoIHV0aWxpemVzIGFic3RyYWN0ICdsb2tpJyBjb21wYXJpc29ucyBmb3IgYmFzaWMgcmVsYXRpb25hbCBlcXVhbGl0eSBvcCBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbmNsYXNzIExva2lBYnN0cmFjdE9wZXJhdG9yUGFja2FnZSBleHRlbmRzIExva2lPcGVyYXRvclBhY2thZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYWVxSGVscGVyKGEsIGIpO1xuICAgIH1cbiAgICAkbmUoYSwgYikge1xuICAgICAgICByZXR1cm4gIWFlcUhlbHBlcihhLCBiKTtcbiAgICB9XG4gICAgJGd0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGd0SGVscGVyKGEsIGIsIGZhbHNlKTtcbiAgICB9XG4gICAgJGd0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBndEhlbHBlcihhLCBiLCB0cnVlKTtcbiAgICB9XG4gICAgJGx0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGx0SGVscGVyKGEsIGIsIGZhbHNlKTtcbiAgICB9XG4gICAgJGx0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBsdEhlbHBlcihhLCBiLCB0cnVlKTtcbiAgICB9XG4gICAgJGJldHdlZW4oYSwgcmFuZ2UpIHtcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZ3RIZWxwZXIoYSwgcmFuZ2VbMF0sIHRydWUpICYmIGx0SGVscGVyKGEsIHJhbmdlWzFdLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqIExva2lPcGVyYXRvclBhY2thZ2Ugd2hpY2ggdXRpbGl6ZXMgcHJvdmlkZWQgY29tcGFyYXRvciBmb3IgYmFzaWMgcmVsYXRpb25hbCBlcXVhbGl0eSBvcCBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbmNsYXNzIENvbXBhcmF0b3JPcGVyYXRvclBhY2thZ2UgZXh0ZW5kcyBMb2tpT3BlcmF0b3JQYWNrYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgfVxuICAgICRlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IoYSwgYikgPT09IDA7XG4gICAgfVxuICAgICRuZShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IoYSwgYikgIT09IDA7XG4gICAgfVxuICAgICRndChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IoYSwgYikgPT09IDE7XG4gICAgfVxuICAgICRndGUoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJhdG9yKGEsIGIpID4gLTE7XG4gICAgfVxuICAgICRsdChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IoYSwgYikgPT09IC0xO1xuICAgIH1cbiAgICAkbHRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyYXRvcihhLCBiKSA8IDE7XG4gICAgfVxuICAgICRiZXR3ZWVuKGEsIHJhbmdlKSB7XG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyYXRvcihhLCByYW5nZVswXSkgPiAtMSAmJiB0aGlzLmNvbXBhcmF0b3IoYSwgcmFuZ2VbMV0pIDwgMTtcbiAgICB9XG59XG4vKipcbiAqIE1hcC9SZWdpc3RlciBvZiBuYW1lZCBMb2tpT3BlcmF0b3JQYWNrYWdlcyB3aGljaCBpbXBsZW1lbnQgYWxsIHVuaW5kZXhlZCBxdWVyeSBvcHMgd2l0aGluICdmaW5kJyBxdWVyeSBvYmplY3RzXG4gKi9cbmxldCBMb2tpT3BlcmF0b3JQYWNrYWdlTWFwID0ge1xuICAgIFwianNcIjogbmV3IExva2lPcGVyYXRvclBhY2thZ2UoKSxcbiAgICBcImxva2lcIjogbmV3IExva2lBYnN0cmFjdE9wZXJhdG9yUGFja2FnZSgpXG59O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3BhY2thZ2VzL2xva2kvc3JjL2V2ZW50X2VtaXR0ZXIudHNcbnZhciBldmVudF9lbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9sb2tpL3NyYy91bmlxdWVfaW5kZXgudHNcbmNsYXNzIFVuaXF1ZUluZGV4IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIHVuaXF1ZSBpbmRleCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5RmllbGQgLSB0aGUgcHJvcGVydHkgZmllbGQgdG8gaW5kZXhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eUZpZWxkKSB7XG4gICAgICAgIHRoaXMuX2ZpZWxkID0gcHJvcGVydHlGaWVsZDtcbiAgICAgICAgdGhpcy5fbG9raU1hcCA9IHt9O1xuICAgICAgICB0aGlzLl92YWxNYXAgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGRvY3VtZW50J3MgdW5pcXVlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBsb2tpIGlkIHRvIGFzc29jaWF0ZSB3aXRoIHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSAgdmFsdWUgdG8gYXNzb2NpYXRlIHdpdGggaWRcbiAgICAgKi9cbiAgICBzZXQoaWQsIHZhbHVlKSB7XG4gICAgICAgIC8vIHVuaXF1ZSBpbmRleCBzaG91bGQgbm90IGluY2x1ZGUgbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW4gdGhpcy5fbG9raU1hcCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBrZXkgZm9yIHByb3BlcnR5IFwiICsgdGhpcy5fZmllbGQgKyBcIjogXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5fdmFsTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGtleSBmb3IgcHJvcGVydHkgJGxva2kgOiBcIiArIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xva2lNYXBbdmFsdWVdID0gaWQ7XG4gICAgICAgICAgICB0aGlzLl92YWxNYXBbaWRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgJGxva2kgaWQgb2YgYW4gdW5pcXVlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgdGhlIHZhbHVlIHRvIHJldHJpZXZlIGEgbG9raSBpZCBtYXRjaCBmb3JcbiAgICAgKi9cbiAgICBnZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xva2lNYXBbdmFsdWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgZG9jdW1lbnQncyB1bmlxdWUgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIChsb2tpKSBpZCBvZiBkb2N1bWVudCB0byB1cGRhdGUgdGhlIHZhbHVlIHRvXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSB2YWx1ZSB0byBhc3NvY2lhdGUgd2l0aCBsb2tpIGlkXG4gICAgICovXG4gICAgdXBkYXRlKGlkLCB2YWx1ZSkge1xuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fdmFsTWFwW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSB2YWx1ZSBtdXN0IGhhdmUgY2hhbmdlZCwgc28gY2hlY2sgaWYgbmV3IHZhbHVlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGlmICh2YWx1ZSBpbiB0aGlzLl9sb2tpTWFwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUga2V5IGZvciBwcm9wZXJ0eSBcIiArIHRoaXMuX2ZpZWxkICsgXCI6IFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlKGlkKTtcbiAgICAgICAgdGhpcy5zZXQoaWQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiB1bmlxdWUgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIChsb2tpKSBpZCB0byByZW1vdmUgZnJvbSBpbmRleFxuICAgICAqL1xuICAgIHJlbW92ZShpZCkge1xuICAgICAgICBpZiAoIShpZCBpbiB0aGlzLl92YWxNYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgaXMgbm90IGluIHVuaXF1ZSBpbmRleDogXCIgKyB0aGlzLl9maWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZFZhbHVlID0gdGhpcy5fdmFsTWFwW2lkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xva2lNYXBbb2xkVmFsdWVdO1xuICAgICAgICBkZWxldGUgdGhpcy5fdmFsTWFwW2lkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSB1bmlxdWUgaW5kZXguXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX2xva2lNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5fdmFsTWFwID0ge307XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2xva2kvc3JjL2Nsb25lLnRzXG5mdW5jdGlvbiBhZGQoY29weSwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChjb3B5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29weS5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNvcHlbY29weS5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29weSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBjb3B5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNvcHlba2V5XTtcbiAgICB9XG59XG5mdW5jdGlvbiB3YWxrKHRhcmdldCwgY29weSkge1xuICAgIGZvciAobGV0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG9iaiA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbmV3IERhdGUob2JqLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBhZGQoY29weSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9iajtcbiAgICAgICAgICAgIGFkZChjb3B5LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gW107XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGFkZChjb3B5LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHdhbGsob2JqLCBsYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBhZGQoY29weSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB3YWxrKG9iaiwgbGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvYmo7XG4gICAgICAgICAgICBhZGQoY29weSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBEZWVwIGNvcHkgZnJvbSBTaW1lb24gVmVsaWNoa292LlxuLyoqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBkZWVwQ29weSh0YXJnZXQpIHtcbiAgICBpZiAoL251bWJlcnxzdHJpbmd8Ym9vbGVhbi8udGVzdCh0eXBlb2YgdGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0YXJnZXQuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgY29uc3QgY29weSA9ICh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSkgPyBbXSA6IHt9O1xuICAgIHdhbGsodGFyZ2V0LCBjb3B5KTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjbG9uZShkYXRhLCBtZXRob2QgPSBcInBhcnNlLXN0cmluZ2lmeVwiKSB7XG4gICAgaWYgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgY2xvbmVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJwYXJzZS1zdHJpbmdpZnlcIjpcbiAgICAgICAgICAgIGNsb25lZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWVwXCI6XG4gICAgICAgICAgICBjbG9uZWQgPSBkZWVwQ29weShkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2hhbGxvd1wiOlxuICAgICAgICAgICAgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShkYXRhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNsb25lZCwgZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNoYWxsb3ctcmVjdXJzZVwiOlxuICAgICAgICAgICAgLy8gc2hhbGxvdyBjbG9uZSB0b3AgbGV2ZWwgcHJvcGVydGllc1xuICAgICAgICAgICAgY2xvbmVkID0gY2xvbmUoZGF0YSwgXCJzaGFsbG93XCIpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIHRvcCBsZXZlbCBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBvYmplY3QgbGl0ZXJhbHMsIHJlY3Vyc2l2ZWx5IHNoYWxsb3cgY29weVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFba2V5XSA9PT0gXCJvYmplY3RcIiAmJiBkYXRhW2tleV0uY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWRba2V5XSA9IGNsb25lKGRhdGFba2V5XSwgXCJzaGFsbG93LXJlY3Vyc2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3BhY2thZ2VzL2xva2kvc3JjL29wZXJhdG9yX3BhY2thZ2VzLnRzXG52YXIgb3BlcmF0b3JfcGFja2FnZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vcGFja2FnZXMvbG9raS9zcmMvY29tcGFyYXRvcnMudHNcbnZhciBjb21wYXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvbG9raS9zcmMvcmVzdWx0X3NldC50c1xuXG5cblxuXG4vLyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHNjYW4gaGllcmFyY2hpY2FsIHRyYW5zZm9ybSBzdGVwIG9iamVjdCBmb3IgcGFyYW0gc3Vic3RpdHV0aW9uXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNmb3JtT2JqZWN0KHN1Yk9iaiwgcGFyYW1zLCBkZXB0aCA9IDApIHtcbiAgICBpZiAoKytkZXB0aCA+PSAxMCkge1xuICAgICAgICByZXR1cm4gc3ViT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc3ViT2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3ViT2JqW3Byb3BdID09PSBcInN0cmluZ1wiICYmIHN1Yk9ialtwcm9wXS5pbmRleE9mKFwiWyVsa3R4cF1cIikgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBuYW1lID0gc3ViT2JqW3Byb3BdLnN1YnN0cmluZyg4KTtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbcG5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJPYmpbcHJvcF0gPSBwYXJhbXNbcG5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdWJPYmpbcHJvcF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHN1Yk9ialtwcm9wXSA9IHJlc29sdmVUcmFuc2Zvcm1PYmplY3Qoc3ViT2JqW3Byb3BdLCBwYXJhbXMsIGRlcHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3ViT2JqO1xufVxuLy8gdG9wIGxldmVsIHV0aWxpdHkgdG8gcmVzb2x2ZSBhbiBlbnRpcmUgKHNpbmdsZSkgdHJhbnNmb3JtIChhcnJheSBvZiBzdGVwcykgZm9yIHBhcmFtZXRlciBzdWJzdGl0dXRpb25cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2Zvcm1QYXJhbXModHJhbnNmb3JtLCBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICB9XG4gICAgLy8gaXRlcmF0ZSBhbGwgc3RlcHMgaW4gdGhlIHRyYW5zZm9ybSBhcnJheVxuICAgIGNvbnN0IHJlc29sdmVkVHJhbnNmb3JtID0gW107XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdHJhbnNmb3JtLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgLy8gY2xvbmUgdHJhbnNmb3JtIHNvIG91ciBzY2FuL3JlcGxhY2UgY2FuIG9wZXJhdGUgZGlyZWN0bHkgb24gY2xvbmVkIHRyYW5zZm9ybVxuICAgICAgICBjb25zdCBjbG9uZWRTdGVwID0gY2xvbmUodHJhbnNmb3JtW2lkeF0sIFwic2hhbGxvdy1yZWN1cnNlXCIpO1xuICAgICAgICByZXNvbHZlZFRyYW5zZm9ybS5wdXNoKHJlc29sdmVUcmFuc2Zvcm1PYmplY3QoY2xvbmVkU3RlcCwgcGFyYW1zKSk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZFRyYW5zZm9ybTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG4vLyBpZiBhbiBvcCBpcyByZWdpc3RlcmVkIGluIHRoaXMgb2JqZWN0LCBvdXIgJ2NhbGN1bGF0ZVJhbmdlJyBjYW4gdXNlIGl0IHdpdGggb3VyIGJpbmFyeSBpbmRpY2VzLlxuLy8gaWYgdGhlIG9wIGlzIHJlZ2lzdGVyZWQgdG8gYSBmdW5jdGlvbiwgd2Ugd2lsbCBydW4gdGhhdCBmdW5jdGlvbi9vcCBhcyBhIDJuZCBwYXNzIGZpbHRlciBvbiByZXN1bHRzLlxuLy8gdGhvc2UgMm5kIHBhc3MgZmlsdGVyIGZ1bmN0aW9ucyBzaG91bGQgYmUgc2ltaWxhciB0byBMb2tpT3BzIGZ1bmN0aW9ucywgYWNjZXB0aW5nIDIgdmFscyB0byBjb21wYXJlLlxuY29uc3QgaW5kZXhlZE9wcyA9IHtcbiAgICAkZXE6IHRydWUsXG4gICAgJGR0ZXE6IHRydWUsXG4gICAgJGd0OiB0cnVlLFxuICAgICRndGU6IHRydWUsXG4gICAgJGx0OiB0cnVlLFxuICAgICRsdGU6IHRydWUsXG4gICAgJGluOiB0cnVlLFxuICAgICRiZXR3ZWVuOiB0cnVlXG59O1xuLyoqXG4gKiBSZXN1bHRTZXQgY2xhc3MgYWxsb3dpbmcgY2hhaW5hYmxlIHF1ZXJpZXMuICBJbnRlbmRlZCB0byBiZSBpbnN0YW5jZWQgaW50ZXJuYWxseS5cbiAqICAgIENvbGxlY3Rpb24uZmluZCgpLCBDb2xsZWN0aW9uLndoZXJlKCksIGFuZCBDb2xsZWN0aW9uLmNoYWluKCkgaW5zdGFudGlhdGUgdGhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgbXljb2xsZWN0aW9uLmNoYWluKClcbiAqICAgICAgLmZpbmQoeyAnZG9vcnMnIDogNCB9KVxuICogICAgICAud2hlcmUoZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmoubmFtZSA9PT0gJ1RveW90YScgfSlcbiAqICAgICAgLmRhdGEoKTtcbiAqXG4gKiBAcGFyYW0gPFREYXRhPiAtIHRoZSBkYXRhIHR5cGVcbiAqIEBwYXJhbSA8VE5lc3RlZD4gLSBuZXN0ZWQgcHJvcGVydGllcyBvZiBkYXRhIHR5cGVcbiAqL1xuY2xhc3MgcmVzdWx0X3NldF9SZXN1bHRTZXQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gY29sbGVjdGlvbiAtIHRoZSBjb2xsZWN0aW9uIHdoaWNoIHRoaXMgUmVzdWx0U2V0IHdpbGwgcXVlcnkgYWdhaW5zdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzID0gW107XG4gICAgICAgIHRoaXMuX2ZpbHRlckluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8vIEhvbGRzIHRoZSBzY29yaW5nIHJlc3VsdCBvZiB0aGUgbGFzdCBmdWxsLXRleHQgc2VhcmNoLlxuICAgICAgICB0aGlzLl9zY29yaW5nID0gbnVsbDtcbiAgICAgICAgLy8gcmV0YWluIHJlZmVyZW5jZSB0byBjb2xsZWN0aW9uIHdlIGFyZSBxdWVyeWluZyBhZ2FpbnN0XG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgUmVzdWx0U2V0IHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9IFJlZmVyZW5jZSB0byB0aGlzIFJlc3VsdFNldCwgZm9yIGZ1dHVyZSBjaGFpbiBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZmlsdGVyZWRSb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpbHRlckluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBvZiB0b0pTT04gdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgY29weSA9IHRoaXMuY29weSgpO1xuICAgICAgICBjb3B5Ll9jb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB5b3UgdG8gbGltaXQgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcGFzc2VkIHRvIG5leHQgY2hhaW4gb3BlcmF0aW9uLlxuICAgICAqIEEgUmVzdWx0U2V0IGNvcHkoKSBpcyBtYWRlIHRvIGF2b2lkIGFsdGVyaW5nIG9yaWdpbmFsIFJlc3VsdFNldC5cbiAgICAgKiBAcGFyYW0ge2ludH0gcXR5IC0gVGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9IFJldHVybnMgYSBjb3B5IG9mIHRoZSBSZXN1bHRTZXQsIGxpbWl0ZWQgYnkgcXR5LCBmb3Igc3Vic2VxdWVudCBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgbGltaXQocXR5KSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaGFzIG5vIGZpbHRlcnMgYXBwbGllZCwgd2UgbmVlZCB0byBwb3B1bGF0ZSBmaWx0ZXJlZFJvd3MgZmlyc3RcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJJbml0aWFsaXplZCAmJiB0aGlzLl9maWx0ZXJlZFJvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJlZFJvd3MgPSB0aGlzLl9jb2xsZWN0aW9uLl9wcmVwYXJlRnVsbERvY0luZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzID0gdGhpcy5fZmlsdGVyZWRSb3dzLnNsaWNlKDAsIHF0eSk7XG4gICAgICAgIHRoaXMuX2ZpbHRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHNraXBwaW5nICdwb3MnIG51bWJlciBvZiBkb2N1bWVudHMgaW4gdGhlIFJlc3VsdFNldC5cbiAgICAgKiBAcGFyYW0ge2ludH0gcG9zIC0gTnVtYmVyIG9mIGRvY3VtZW50cyB0byBza2lwOyBhbGwgcHJlY2VkaW5nIGRvY3VtZW50cyBhcmUgZmlsdGVyZWQgb3V0LlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9IFJldHVybnMgYSBjb3B5IG9mIHRoZSBSZXN1bHRTZXQsIGNvbnRhaW5pbmcgZG9jcyBzdGFydGluZyBhdCAncG9zJyBmb3Igc3Vic2VxdWVudCBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgb2Zmc2V0KHBvcykge1xuICAgICAgICAvLyBpZiB0aGlzIGhhcyBubyBmaWx0ZXJzIGFwcGxpZWQsIHdlIG5lZWQgdG8gcG9wdWxhdGUgZmlsdGVyZWRSb3dzIGZpcnN0XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5fZmlsdGVyZWRSb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzID0gdGhpcy5fY29sbGVjdGlvbi5fcHJlcGFyZUZ1bGxEb2NJbmRleCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IHRoaXMuX2ZpbHRlcmVkUm93cy5zbGljZShwb3MpO1xuICAgICAgICB0aGlzLl9maWx0ZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBzdXBwb3J0IHJldXNlIG9mIFJlc3VsdFNldCBpbiBicmFuY2hlZCBxdWVyeSBzaXR1YXRpb25zLlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9IFJldHVybnMgYSBjb3B5IG9mIHRoZSBSZXN1bHRTZXQgKHNldCkgYnV0IHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50IHJlZmVyZW5jZXMgd2lsbCBiZSB0aGUgc2FtZS5cbiAgICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgcmVzdWx0X3NldF9SZXN1bHRTZXQodGhpcy5fY29sbGVjdGlvbik7XG4gICAgICAgIHJlc3VsdC5fZmlsdGVyZWRSb3dzID0gdGhpcy5fZmlsdGVyZWRSb3dzLnNsaWNlKCk7XG4gICAgICAgIHJlc3VsdC5fZmlsdGVySW5pdGlhbGl6ZWQgPSB0aGlzLl9maWx0ZXJJbml0aWFsaXplZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBuYW1lZCBjb2xsZWN0aW9uIHRyYW5zZm9ybSBvciByYXcgYXJyYXkgb2YgdHJhbnNmb3JtIHN0ZXBzIGFnYWluc3QgdGhlIFJlc3VsdFNldC5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8YXJyYXkpfSB0cmFuc2Zvcm0gLSBuYW1lIG9mIGNvbGxlY3Rpb24gdHJhbnNmb3JtIG9yIHJhdyB0cmFuc2Zvcm0gYXJyYXlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtZXRlcnM9XSAtIG9iamVjdCBwcm9wZXJ0eSBoYXNoIG9mIHBhcmFtZXRlcnMsIGlmIHRoZSB0cmFuc2Zvcm0gcmVxdWlyZXMgdGhlbS5cbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0U2V0fSBlaXRoZXIgKHRoaXMpIFJlc3VsdFNldCBvciBhIGNsb25lIG9mIG9mIHRoaXMgUmVzdWx0U2V0IChkZXBlbmRpbmcgb24gc3RlcHMpXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSwgcGFyYW1ldGVycykge1xuICAgICAgICAvLyBpZiB0cmFuc2Zvcm0gaXMgbmFtZSwgdGhlbiBkbyBsb29rdXAgZmlyc3RcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuX2NvbGxlY3Rpb24uX3RyYW5zZm9ybXNbdHJhbnNmb3JtXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSByZXNvbHZlVHJhbnNmb3JtUGFyYW1zKHRyYW5zZm9ybSwgcGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJzID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdHJhbnNmb3JtLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSB0cmFuc2Zvcm1baWR4XTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RlcC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcnMuZmluZChzdGVwLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIndoZXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJzLndoZXJlKHN0ZXAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic2ltcGxlc29ydFwiOlxuICAgICAgICAgICAgICAgICAgICBycy5zaW1wbGVzb3J0KHN0ZXAucHJvcGVydHksIHN0ZXAub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wb3VuZHNvcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcnMuY29tcG91bmRzb3J0KHN0ZXAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic29ydFwiOlxuICAgICAgICAgICAgICAgICAgICBycy5zb3J0KHN0ZXAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic29ydEJ5U2NvcmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBycy5zb3J0QnlTY29yaW5nKHN0ZXAuZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsaW1pdFwiOlxuICAgICAgICAgICAgICAgICAgICBycyA9IHJzLmxpbWl0KHN0ZXAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gbGltaXQgbWFrZXMgY29weSBzbyB1cGRhdGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9mZnNldFwiOlxuICAgICAgICAgICAgICAgICAgICBycyA9IHJzLm9mZnNldChzdGVwLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIG9mZnNldCBtYWtlcyBjb3B5IHNvIHVwZGF0ZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIHJzID0gcnMubWFwKHN0ZXAudmFsdWUsIHN0ZXAuZGF0YU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXFKb2luXCI6XG4gICAgICAgICAgICAgICAgICAgIHJzID0gcnMuZXFKb2luKHN0ZXAuam9pbkRhdGEsIHN0ZXAubGVmdEpvaW5LZXksIHN0ZXAucmlnaHRKb2luS2V5LCBzdGVwLm1hcEZ1biwgc3RlcC5kYXRhT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIGZvbGxvd2luZyBjYXNlcyBicmVhayBjaGFpbiBieSByZXR1cm5pbmcgYXJyYXkgZGF0YSBzbyBtYWtlIGFueSBvZiB0aGVzZSBsYXN0IGluIHRyYW5zZm9ybSBzdGVwc1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBSZWR1Y2VcIjpcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBycy5tYXBSZWR1Y2Uoc3RlcC5tYXBGdW5jdGlvbiwgc3RlcC5yZWR1Y2VGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIGZvbGxvd2luZyBjYXNlcyB1cGRhdGUgZG9jdW1lbnRzIGluIGN1cnJlbnQgZmlsdGVyZWQgUmVzdWx0U2V0ICh1c2UgY2FyZWZ1bGx5KVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgcnMudXBkYXRlKHN0ZXAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZXIgc3VwcGxpZWQgY29tcGFyZSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0d28gZG9jdW1lbnRzIHRvIGNvbXBhcmUuIChjaGFpbmFibGUpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICByc2x0LnNvcnQoZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuICAgICAgICogICAgICBpZiAob2JqMS5uYW1lID09PSBvYmoyLm5hbWUpIHJldHVybiAwO1xuICAgICAgICogICAgICBpZiAob2JqMS5uYW1lID4gb2JqMi5uYW1lKSByZXR1cm4gMTtcbiAgICAgICAqICAgICAgaWYgKG9iajEubmFtZSA8IG9iajIubmFtZSkgcmV0dXJuIC0xO1xuICAgICAgICogICAgfSk7XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZWZ1biAtIEEgamF2YXNjcmlwdCBjb21wYXJlIGZ1bmN0aW9uIHVzZWQgZm9yIHNvcnRpbmcuXG4gICAgICogQHJldHVybnMge1Jlc3VsdFNldH0gUmVmZXJlbmNlIHRvIHRoaXMgUmVzdWx0U2V0LCBzb3J0ZWQsIGZvciBmdXR1cmUgY2hhaW4gb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBzb3J0KGNvbXBhcmVmdW4pIHtcbiAgICAgICAgLy8gaWYgdGhpcyBoYXMgbm8gZmlsdGVycyBhcHBsaWVkLCBqdXN0IHdlIG5lZWQgdG8gcG9wdWxhdGUgZmlsdGVyZWRSb3dzIGZpcnN0XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5fZmlsdGVyZWRSb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzID0gdGhpcy5fY29sbGVjdGlvbi5fcHJlcGFyZUZ1bGxEb2NJbmRleCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jb2xsZWN0aW9uLl9kYXRhO1xuICAgICAgICBjb25zdCB3cmFwcGVkQ29tcGFyZXIgPSAoYSwgYikgPT4gY29tcGFyZWZ1bihkYXRhW2FdLCBkYXRhW2JdKTtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzLnNvcnQod3JhcHBlZENvbXBhcmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXBsZXIsIGxvb3NlIGV2YWx1YXRpb24gZm9yIHVzZXIgdG8gc29ydCBiYXNlZCBvbiBhIHByb3BlcnR5IG5hbWUuIChjaGFpbmFibGUpLlxuICAgICAqIFNvcnRpbmcgYmFzZWQgb24gdGhlIHNhbWUgbHQvZ3QgaGVscGVyIGZ1bmN0aW9ucyB1c2VkIGZvciBiaW5hcnkgaW5kaWNlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcG5hbWUgLSBuYW1lIG9mIHByb3BlcnR5IHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufG9iamVjdD19IG9wdGlvbnMgLSBib29sZWFuIGZvciBzb3J0IGRlc2NlbmRpbmcgb3Igb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlc2M9ZmFsc2VdIC0gd2hldGhlciB0byBzb3J0IGRlc2NlbmRpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc29ydENvbXBhcmF0b3JdIG92ZXJyaWRlIGRlZmF1bHQgd2l0aCBuYW1lIG9mIGNvbXBhcmF0b3IgcmVnaXN0ZXJlZCBpbiBDb21wYXJhdG9yTWFwXG4gICAgICogQHJldHVybnMge1Jlc3VsdFNldH0gUmVmZXJlbmNlIHRvIHRoaXMgUmVzdWx0U2V0LCBzb3J0ZWQsIGZvciBmdXR1cmUgY2hhaW4gb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBzaW1wbGVzb3J0KHByb3BuYW1lLCBvcHRpb25zID0geyBkZXNjOiBmYWxzZSB9KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZGVzYzogb3B0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckluaXRpYWxpemVkICYmIHRoaXMuX2NvbGxlY3Rpb24uX3JhbmdlZEluZGV4ZXMuaGFzT3duUHJvcGVydHkocHJvcG5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgc29ydGVkSWRzID0gdGhpcy5fY29sbGVjdGlvbi5fcmFuZ2VkSW5kZXhlc1twcm9wbmFtZV0uaW5kZXgucmFuZ2VSZXF1ZXN0KCk7XG4gICAgICAgICAgICBsZXQgZGF0YVBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgLy8gdW50aWwgd2UgcmVmYWN0b3IgcmVzdWx0c2V0IHRvIHN0b3JlICRsb2tpIGlkcyBpbiBmaWx0ZXJlZHJvd3MsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNvbnZlcnQgJGxva2kgaWRzIHRvIGRhdGEgYXJyYXkgcG9zaXRpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBvZiBzb3J0ZWRJZHMpIHtcbiAgICAgICAgICAgICAgICBkYXRhUG9zaXRpb25zLnB1c2godGhpcy5fY29sbGVjdGlvbi5nZXQoaWQsIHRydWUpWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IG9wdGlvbnMuZGVzYyA/IGRhdGFQb3NpdGlvbnMucmV2ZXJzZSgpIDogZGF0YVBvc2l0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoaXMgaGFzIG5vIGZpbHRlcnMgYXBwbGllZCwganVzdCB3ZSBuZWVkIHRvIHBvcHVsYXRlIGZpbHRlcmVkUm93cyBmaXJzdFxuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckluaXRpYWxpemVkICYmIHRoaXMuX2ZpbHRlcmVkUm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IHRoaXMuX2NvbGxlY3Rpb24uX3ByZXBhcmVGdWxsRG9jSW5kZXgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fY29sbGVjdGlvbi5fZGF0YTtcbiAgICAgICAgbGV0IGNvbXBhcmF0b3IgPSAob3B0aW9ucy5zb3J0Q29tcGFyYXRvcikgP1xuICAgICAgICAgICAgY29tcGFyYXRvcnNbXCJhXCIgLyogQ29tcGFyYXRvck1hcCAqL11bb3B0aW9ucy5zb3J0Q29tcGFyYXRvcl0gOlxuICAgICAgICAgICAgY29tcGFyYXRvcnNbXCJhXCIgLyogQ29tcGFyYXRvck1hcCAqL11bdGhpcy5fY29sbGVjdGlvbi5fdW5pbmRleGVkU29ydENvbXBhcmF0b3JdO1xuICAgICAgICBjb25zdCB3cmFwcGVkQ29tcGFyZXIgPSAoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoZGF0YVthXVtwcm9wbmFtZV0sIGRhdGFbYl1bcHJvcG5hbWVdKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzLnNvcnQod3JhcHBlZENvbXBhcmVyKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVzYykge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHNvcnRpbmcgYSBSZXN1bHRTZXQgYmFzZWQgb24gbXVsdGlwbGUgY29sdW1ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRvIHNvcnQgYnkgYWdlIGFuZCB0aGVuIG5hbWUgKGJvdGggYXNjZW5kaW5nKVxuICAgICAqIHJzLmNvbXBvdW5kc29ydChbJ2FnZScsICduYW1lJ10pO1xuICAgICAqIC8vIHRvIHNvcnQgYnkgYWdlIChhc2NlbmRpbmcpIGFuZCB0aGVuIGJ5IG5hbWUgKGRlc2NlbmRpbmcpXG4gICAgICogcnMuY29tcG91bmRzb3J0KFsnYWdlJywgWyduYW1lJywgdHJ1ZV0pO1xuICAgICAqIEBwYXJhbSB7YXJyYXl9IHByb3BlcnRpZXMgLSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvciBzdWJhcnJheSBvZiBbcHJvcGVydHluYW1lLCBpc2Rlc2NdIHVzZWQgZXZhbHVhdGUgc29ydCBvcmRlclxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9IFJlZmVyZW5jZSB0byB0aGlzIFJlc3VsdFNldCwgc29ydGVkLCBmb3IgZnV0dXJlIGNoYWluIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgY29tcG91bmRzb3J0KHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbGwgdG8gY29tcG91bmRzb3J0LCBuZWVkIGF0IGxlYXN0IG9uZSBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBwcm9wZXJ0aWVzWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2ltcGxlc29ydChwcm9wLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGVzb3J0KHByb3BbMF0sIHByb3BbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVuaWZ5IHRoZSBzdHJ1Y3R1cmUgb2YgJ3Byb3BlcnRpZXMnIHRvIGF2b2lkIGNoZWNraW5nIGl0IHJlcGVhdGVkbHkgd2hpbGUgc29ydGluZ1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2ldID0gW3Byb3AsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGlzIGhhcyBubyBmaWx0ZXJzIGFwcGxpZWQsIGp1c3Qgd2UgbmVlZCB0byBwb3B1bGF0ZSBmaWx0ZXJlZFJvd3MgZmlyc3RcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJJbml0aWFsaXplZCAmJiB0aGlzLl9maWx0ZXJlZFJvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJlZFJvd3MgPSB0aGlzLl9jb2xsZWN0aW9uLl9wcmVwYXJlRnVsbERvY0luZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2NvbGxlY3Rpb24uX2RhdGE7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRDb21wYXJlciA9IChhLCBiKSA9PiB0aGlzLl9jb21wb3VuZGV2YWwocHJvcGVydGllcywgZGF0YVthXSwgZGF0YVtiXSk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cy5zb3J0KHdyYXBwZWRDb21wYXJlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGNvbXBvdW5kc29ydCgpLCBwZXJmb3JtaW5nIGluZGl2aWR1YWwgb2JqZWN0IGNvbXBhcmlzb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcGVydGllcyAtIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLCBpbiBvcmRlciwgYnkgd2hpY2ggdG8gZXZhbHVhdGUgc29ydCBvcmRlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmoxIC0gZmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqMiAtIHNlY29uZCBvYmplY3QgdG8gY29tcGFyZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAsIC0xLCBvciAxIHRvIGRlc2lnbmF0ZSBpZiBpZGVudGljYWwgKHNvcnR3aXNlKSBvciB3aGljaCBzaG91bGQgYmUgZmlyc3RcbiAgICAgKi9cbiAgICBfY29tcG91bmRldmFsKHByb3BlcnRpZXMsIG9iajEsIG9iajIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBwcm9wWzBdO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0KG9wZXJhdG9yX3BhY2thZ2VzW1wiZFwiIC8qIHNvcnRIZWxwZXIgKi9dKShvYmoxW2ZpZWxkXSwgb2JqMltmaWVsZF0sIHByb3BbMV0pO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBSZXN1bHRTZXQgYmFzZWQgb24gdGhlIGxhc3QgZnVsbC10ZXh0LXNlYXJjaCBzY29yaW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzY2VuZGluZz1mYWxzZV0gLSBzb3J0IGFzY2VuZGluZ1xuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9XG4gICAgICovXG4gICAgc29ydEJ5U2NvcmluZyhhc2NlbmRpbmcgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fc2NvcmluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2NvcmluZyBhdmFpbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzY2VuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzLnNvcnQoKGEsIGIpID0+IHRoaXMuX3Njb3JpbmdbYV0uc2NvcmUgLSB0aGlzLl9zY29yaW5nW2JdLnNjb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cy5zb3J0KChhLCBiKSA9PiB0aGlzLl9zY29yaW5nW2JdLnNjb3JlIC0gdGhpcy5fc2NvcmluZ1thXS5zY29yZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjb3Jpbmcgb2YgdGhlIGxhc3QgZnVsbC10ZXh0LXNlYXJjaC5cbiAgICAgKiBAcmV0dXJucyB7U2NvcmVSZXN1bHRbXX1cbiAgICAgKi9cbiAgICBnZXRTY29yaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5fc2NvcmluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2NvcmluZyBhdmFpbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NvcmluZyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZpbHRlcmVkUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2NvcmluZy5wdXNoKHRoaXMuX3Njb3JpbmdbdGhpcy5fZmlsdGVyZWRSb3dzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3Jpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJzZWUgdGhlIG9wZXJhdGlvbiBvZiBPUidlZCBxdWVyeSBleHByZXNzaW9ucy5cbiAgICAgKiBPUidlZCBleHByZXNzaW9uIGV2YWx1YXRpb24gcnVucyBlYWNoIGV4cHJlc3Npb24gaW5kaXZpZHVhbGx5IGFnYWluc3QgdGhlIGZ1bGwgY29sbGVjdGlvbixcbiAgICAgKiBhbmQgZmluYWxseSBkb2VzIGEgc2V0IE9SIG9uIGVhY2ggZXhwcmVzc2lvbidzIHJlc3VsdHMuXG4gICAgICogRWFjaCBldmFsdWF0aW9uIGNhbiB1dGlsaXplIGEgYmluYXJ5IGluZGV4IHRvIHByZXZlbnQgbXVsdGlwbGUgbGluZWFyIGFycmF5IHNjYW5zLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGV4cHJlc3Npb25BcnJheSAtIGFycmF5IG9mIGV4cHJlc3Npb25zXG4gICAgICogQHJldHVybnMge1Jlc3VsdFNldH0gdGhpcyBSZXN1bHRTZXQgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIGZpbmRPcihleHByZXNzaW9uQXJyYXkpIHtcbiAgICAgICAgY29uc3QgZG9jc2V0ID0gW107XG4gICAgICAgIGNvbnN0IGlkeHNldCA9IFtdO1xuICAgICAgICBjb25zdCBvcmlnQ291bnQgPSB0aGlzLmNvdW50KCk7XG4gICAgICAgIC8vIElmIGZpbHRlciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLCB0aGVuIHdlIHF1ZXJ5IGFnYWluc3Qgb25seSB0aG9zZSBpdGVtcyBhbHJlYWR5IGluIGZpbHRlci5cbiAgICAgICAgLy8gVGhpcyBtZWFucyBubyBpbmRleCB1dGlsaXphdGlvbiBmb3IgZmllbGRzLCBzbyBob3BlZnVsbHkgaXRzIGZpbHRlcmVkIHRvIGEgc21hbGxpc2ggZmlsdGVyZWRSb3dzLlxuICAgICAgICBmb3IgKGxldCBlaSA9IDAsIGVsZW4gPSBleHByZXNzaW9uQXJyYXkubGVuZ3RoOyBlaSA8IGVsZW47IGVpKyspIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYnJhbmNoIGV4aXN0aW5nIHF1ZXJ5IHRvIHJ1biBlYWNoIGZpbHRlciBzZXBhcmF0ZWx5IGFuZCBjb21iaW5lIHJlc3VsdHNcbiAgICAgICAgICAgIGNvbnN0IGZyID0gdGhpcy5jb3B5KCkuZmluZChleHByZXNzaW9uQXJyYXlbZWldKS5fZmlsdGVyZWRSb3dzO1xuICAgICAgICAgICAgY29uc3QgZnJsZW4gPSBmci5sZW5ndGg7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZmluZCBvcGVyYXRpb24gZGlkIG5vdCByZWR1Y2UgdGhlIGluaXRpYWwgc2V0LCB0aGVuIHRoZSBpbml0aWFsIHNldCBpcyB0aGUgYWN0dWFsIHJlc3VsdFxuICAgICAgICAgICAgaWYgKGZybGVuID09PSBvcmlnQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBhbnkgZG9jdW1lbnQgJ2hpdHMnXG4gICAgICAgICAgICBmb3IgKGxldCBmcmkgPSAwOyBmcmkgPCBmcmxlbjsgZnJpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBmcltmcmldO1xuICAgICAgICAgICAgICAgIGlmIChpZHhzZXRbaWR4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeHNldFtpZHhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZG9jc2V0LnB1c2goaWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzID0gZG9jc2V0O1xuICAgICAgICB0aGlzLl9maWx0ZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAkb3IoZXhwcmVzc2lvbkFycmF5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRPcihleHByZXNzaW9uQXJyYXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVyc2VlIHRoZSBvcGVyYXRpb24gb2YgQU5EJ2VkIHF1ZXJ5IGV4cHJlc3Npb25zLlxuICAgICAqIEFORCdlZCBleHByZXNzaW9uIGV2YWx1YXRpb24gcnVucyBlYWNoIGV4cHJlc3Npb24gcHJvZ3Jlc3NpdmVseSBhZ2FpbnN0IHRoZSBmdWxsIGNvbGxlY3Rpb24sXG4gICAgICogaW50ZXJuYWxseSB1dGlsaXppbmcgZXhpc3RpbmcgY2hhaW5lZCBSZXN1bHRTZXQgZnVuY3Rpb25hbGl0eS5cbiAgICAgKiBPbmx5IHRoZSBmaXJzdCBmaWx0ZXIgY2FuIHV0aWxpemUgYSBiaW5hcnkgaW5kZXguXG4gICAgICogQHBhcmFtIHthcnJheX0gZXhwcmVzc2lvbkFycmF5IC0gYXJyYXkgb2YgZXhwcmVzc2lvbnNcbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0U2V0fSB0aGlzIFJlc3VsdFNldCBmb3IgZnVydGhlciBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgZmluZEFuZChleHByZXNzaW9uQXJyYXkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhbHJlYWR5IGltcGxlbWVudGluZyBtZXRob2QgY2hhaW5pbmcgaW4gdGhpcyAob3VyIFJlc3VsdFNldCBjbGFzcylcbiAgICAgICAgLy8gc28gbGV0cyBqdXN0IHByb2dyZXNzaXZlbHkgYXBwbHkgdXNlciBzdXBwbGllZCBhbmQgZmlsdGVyc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZXhwcmVzc2lvbkFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudCgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpbmQoZXhwcmVzc2lvbkFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgJGFuZChleHByZXNzaW9uQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEFuZChleHByZXNzaW9uQXJyYXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBxdWVyeWluZyB2aWEgYSBtb25nby1zdHlsZSBxdWVyeSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnkgLSBBIG1vbmdvLXN0eWxlIHF1ZXJ5IG9iamVjdCB1c2VkIGZvciBmaWx0ZXJpbmcgY3VycmVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RPbmx5IC0gKE9wdGlvbmFsKSBVc2VkIGJ5IGNvbGxlY3Rpb24uZmluZE9uZSgpIC0gZmxhZyBpZiB0aGlzIHdhcyBpbnZva2VkIHZpYSBmaW5kT25lKClcbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0U2V0fSB0aGlzIFJlc3VsdFNldCBmb3IgZnVydGhlciBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgZmluZChxdWVyeSwgZmlyc3RPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb24uX2RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJlZFJvd3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5T2JqZWN0ID0gcXVlcnkgfHwgXCJnZXRBbGxcIjtcbiAgICAgICAgbGV0IHByb3BlcnR5O1xuICAgICAgICBsZXQgcXVlcnlPYmplY3RPcDtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5T2JqZWN0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBxdWVyeU9iamVjdCkge1xuICAgICAgICAgICAgICAgIGxldCBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICBvYmpbcF0gPSBxdWVyeU9iamVjdFtwXTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlPYmplY3RbcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5T2JqZWN0T3AgPSBxdWVyeU9iamVjdFtwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGV4cHJlc3Npb24gaW4gc2luZ2xlIHF1ZXJ5IG9iamVjdCxcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgaW1wbGljaXQgJGFuZCB0byBleHBsaWNpdCAkYW5kXG4gICAgICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZCh7IFwiJGFuZFwiOiBmaWx0ZXJzIH0sIGZpcnN0T25seSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgbm8gZmlsdGVycyBpZiB0aGV5IHdhbnQgYWxsXG4gICAgICAgIGlmICghcHJvcGVydHkgfHwgcXVlcnlPYmplY3QgPT09IFwiZ2V0QWxsXCIpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdE9ubHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJlZFJvd3MgPSAodGhpcy5fY29sbGVjdGlvbi5fZGF0YS5sZW5ndGggPiAwKSA/IFswXSA6IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluamVjdGluZyAkYW5kIGFuZCAkb3IgZXhwcmVzc2lvbiB0cmVlIGV2YWx1YXRpb24gaGVyZS5cbiAgICAgICAgaWYgKHByb3BlcnR5ID09PSBcIiRhbmRcIiB8fCBwcm9wZXJ0eSA9PT0gXCIkb3JcIikge1xuICAgICAgICAgICAgdGhpc1twcm9wZXJ0eV0ocXVlcnlPYmplY3RPcCk7XG4gICAgICAgICAgICAvLyBmb3IgY2hhaW5lZCBmaW5kIHdpdGggZmlyc3RPbmx5LFxuICAgICAgICAgICAgaWYgKGZpcnN0T25seSAmJiB0aGlzLl9maWx0ZXJlZFJvd3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IHRoaXMuX2ZpbHRlcmVkUm93cy5zbGljZSgwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZSBpZiBxdWVyeSBvYmplY3QgaXMgaW4gc2hvcnRoYW5kIG1vZGUgKGFzc3VtaW5nIGVxIG9wZXJhdG9yKVxuICAgICAgICBsZXQgb3BlcmF0b3IgPSBcIlwiO1xuICAgICAgICBpZiAocXVlcnlPYmplY3RPcCA9PT0gbnVsbCB8fCAodHlwZW9mIHF1ZXJ5T2JqZWN0T3AgIT09IFwib2JqZWN0XCIgfHwgcXVlcnlPYmplY3RPcCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICBvcGVyYXRvciA9IFwiJGVxXCI7XG4gICAgICAgICAgICB2YWx1ZSA9IHF1ZXJ5T2JqZWN0T3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHF1ZXJ5T2JqZWN0T3AgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBxdWVyeU9iamVjdE9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5T2JqZWN0T3Bba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHF1ZXJ5T2JqZWN0T3Bba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGtub3cgd2hhdCB5b3Ugd2FudCB0byBkby5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIHJlZ2V4IG9wcywgcHJlY29tcGlsZVxuICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwiJHJlZ2V4XCIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFuIGluZGV4IGV4aXN0cyBmb3IgdGhlIHByb3BlcnR5IGJlaW5nIHF1ZXJpZWQgYWdhaW5zdCwgdXNlIGl0XG4gICAgICAgIC8vIGZvciBub3cgb25seSBlbmFibGluZyB3aGVyZSBpdCBpcyB0aGUgZmlyc3QgZmlsdGVyIGFwcGxpZWQgYW5kIHByb3AgaXMgaW5kZXhlZFxuICAgICAgICBjb25zdCBkb0luZGV4Q2hlY2sgPSAhdGhpcy5fZmlsdGVySW5pdGlhbGl6ZWQ7XG4gICAgICAgIGxldCBzZWFyY2hCeUluZGV4ID0gZmFsc2U7XG4gICAgICAgIGlmIChkb0luZGV4Q2hlY2sgJiYgdGhpcy5fY29sbGVjdGlvbi5fcmFuZ2VkSW5kZXhlc1twcm9wZXJ0eV0gJiYgaW5kZXhlZE9wc1tvcGVyYXRvcl0pIHtcbiAgICAgICAgICAgIHNlYXJjaEJ5SW5kZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IG9wZXJhdG9yUGFja2FnZSA9IG9wZXJhdG9yX3BhY2thZ2VzW1wiYVwiIC8qIExva2lPcGVyYXRvclBhY2thZ2VNYXAgKi9dW3RoaXMuX2NvbGxlY3Rpb24uX2RlZmF1bHRMb2tpT3BlcmF0b3JQYWNrYWdlXTtcbiAgICAgICAgLy8gXCJzaG9ydGN1dFwiIGZvciBjb2xsZWN0aW9uIGRhdGFcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2NvbGxlY3Rpb24uX2RhdGE7XG4gICAgICAgIC8vIFF1ZXJ5IGV4ZWN1dGVkIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiA6XG4gICAgICAgIC8vICAgIC0gd2hldGhlciB0aGUgcHJvcGVydHkgYmVpbmcgcXVlcmllZCBoYXMgYW4gaW5kZXggZGVmaW5lZFxuICAgICAgICAvLyAgICAtIGlmIGNoYWluZWQsIHdlIGhhbmRsZSBmaXJzdCBwYXNzIGRpZmZlcmVudGx5IGZvciBpbml0aWFsIGZpbHRlcmVkUm93c1tdIHBvcHVsYXRpb25cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGVhY2ggY2FzZSBoYXMgaXRzIG93biBpZiBibG9jayB0byBtaW5pbWl6ZSBpbi1sb29wIGNhbGN1bGF0aW9uc1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIC8vIElmIHRoZSBmaWx0ZXJlZFJvd3NbXSBpcyBhbHJlYWR5IGluaXRpYWxpemVkLCB1c2UgaXRcbiAgICAgICAgaWYgKHRoaXMuX2ZpbHRlckluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyID0gdGhpcy5fZmlsdGVyZWRSb3dzO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSBcIiRmdHNcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njb3JpbmcgPSB0aGlzLl9jb2xsZWN0aW9uLl9mdWxsVGV4dFNlYXJjaC5zZWFyY2gocXVlcnlPYmplY3QuJGZ0cyk7XG4gICAgICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9zY29yaW5nKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5pbmRleE9mKCtrZXlzW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCtrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2NvbGxlY3Rpb24uX2NvbnN0cmFpbnRzLnVuaXF1ZVtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCAmJiBvcGVyYXRvciA9PT0gXCIkZXFcIikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFjayB0byBwb3NpdGlvbiBmb3IgZmlsdGVyZWQgcm93cyAodW50aWwgd2UgcmVmYWN0b3IgZmlsdGVyZWRyb3dzIHRvIHN0b3JlICRsb2tpIGluc3RlYWQgb2YgZGF0YSBwb3MpXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLl9jb2xsZWN0aW9uLl9jb25zdHJhaW50cy51bmlxdWVbcHJvcGVydHldLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5fY29sbGVjdGlvbi5nZXQoaWQsIHRydWUpWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmluZGV4T2Yocm93KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm93SWR4ID0gZmlsdGVyW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIG9wZXJhdG9yIGFzIG1ldGhvZCBwcm9wZXJ0eSBvZiBvcGVyYXRvciBwYWNrYWdlIHByZXNlcnZlcyAndGhpcydcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yUGFja2FnZVtvcGVyYXRvcl0oZGF0YVtyb3dJZHhdW3Byb3BlcnR5XSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyb3dJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZmlsdGVyZWRSb3dzID0gcmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVySW5pdGlhbGl6ZWQgPSB0cnVlOyAvLyBuZXh0IHRpbWUgd29yayBhZ2FpbnN0IGZpbHRlcmVkUm93c1tdXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maWx0ZXJlZFJvd3MgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX2ZpbHRlckluaXRpYWxpemVkID0gdHJ1ZTsgLy8gbmV4dCB0aW1lIHdvcmsgYWdhaW5zdCBmaWx0ZXJlZFJvd3NbXVxuICAgICAgICBpZiAocHJvcGVydHkgPT09IFwiJGZ0c1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zY29yaW5nID0gdGhpcy5fY29sbGVjdGlvbi5fZnVsbFRleHRTZWFyY2guc2VhcmNoKHF1ZXJ5T2JqZWN0LiRmdHMpO1xuICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9zY29yaW5nKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCtrZXlzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSB1bmlxdWUgY29uc3RyYWludCBmb3Igc2VhcmNoLlxuICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbi5fY29uc3RyYWludHMudW5pcXVlW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkICYmIG9wZXJhdG9yID09PSBcIiRlcVwiKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGJhY2sgdG8gcG9zaXRpb24gZm9yIGZpbHRlcmVkIHJvd3MgKHVudGlsIHdlIHJlZmFjdG9yIGZpbHRlcmVkcm93cyB0byBzdG9yZSAkbG9raSBpbnN0ZWFkIG9mIGRhdGEgcG9zKVxuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLl9jb2xsZWN0aW9uLl9jb25zdHJhaW50cy51bmlxdWVbcHJvcGVydHldLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX2NvbGxlY3Rpb24uZ2V0KGlkLCB0cnVlKVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBub3Qgc2VhcmNoaW5nIGJ5IGluZGV4XG4gICAgICAgIGlmICghc2VhcmNoQnlJbmRleCkge1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGNvbXBhcmF0b3IgdG8gdXNlIGZvciBvcHNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGxpbmcgb3BlcmF0b3IgYXMgbWV0aG9kIHByb3BlcnR5IG9mIG9wZXJhdG9yIHBhY2thZ2UgcHJlc2VydmVzICd0aGlzJ1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvclBhY2thZ2Vbb3BlcmF0b3JdKGRhdGFbaV1bcHJvcGVydHldLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJhbmdlZEluZGV4IGRlZmluZWQsIHVzZSB0aGF0IGFuZCBiYWlsXG4gICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uLl9yYW5nZWRJbmRleGVzW3Byb3BlcnR5XSkge1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIiRpblwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJpID0gdGhpcy5fY29sbGVjdGlvbi5fcmFuZ2VkSW5kZXhlc1twcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBlYWNoICRpbiBhcnJheSB2YWx1ZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHZhbCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IG1hdGNoZXMgd2hlcmUgdmFsIGVxIGN1cnJlbnQgaXRlcmF0ZWQgdmFsXG4gICAgICAgICAgICAgICAgICAgIGxldCBpZFJlc3VsdCA9IHJpLmluZGV4LnJhbmdlUmVxdWVzdCh7IG9wOiBcIiRlcVwiLCB2YWw6IHZhbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggcmVzdWx0IGluIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkIG9mIGlkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ICRsb2tpIGlkIHRvIGRhdGEgcG9zaXRpb24gYW5kIGFkZCB0byByZXN1bHQgKGZpbHRlcmVkcm93cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX2NvbGxlY3Rpb24uZ2V0KGlkLCB0cnVlKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwiJGJldHdlZW5cIikge1xuICAgICAgICAgICAgICAgIGxldCBpZFJlc3VsdCA9IHRoaXMuX2NvbGxlY3Rpb24uX3JhbmdlZEluZGV4ZXNbcHJvcGVydHldLmluZGV4LnJhbmdlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgdmFsOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgaGlnaDogdmFsdWVbMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBmb3Igbm93IHdlIHdpbGwgaGF2ZSB0byAnc2hpbScgdGhlIGJpbmFyeSB0cmVlIGluZGV4J3MgJGxva2kgaWRzIGJhY2tcbiAgICAgICAgICAgICAgICAvLyBpbnRvIGRhdGEgYXJyYXkgaW5kaWNlcywgaWRlYWxseSBpIHdvdWxkIGxpa2UgdG8gcmVwdXJwb3NlIGZpbHRlcmVkcm93cyB0byB1c2UgbG9raSBpZHNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpZCBvZiBpZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9jb2xsZWN0aW9uLmdldChpZCwgdHJ1ZSlbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpZFJlc3VsdCA9IHRoaXMuX2NvbGxlY3Rpb24uX3JhbmdlZEluZGV4ZXNbcHJvcGVydHldLmluZGV4LnJhbmdlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgb3A6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIHZhbDogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgb3VyIG9wIHJlcXVpcmVzICdzZWNvbmQgcGFzcydcbiAgICAgICAgICAgIGlmIChpbmRleGVkT3BzW29wZXJhdG9yXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGlkIG9mIGlkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSB0aGlzLl9jb2xsZWN0aW9uLmdldChpZCwgdHJ1ZSlbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleGVkT3BzW29wZXJhdG9yXShkYXRhW3Bvc11bcHJvcGVydHldLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmb3Igbm93IHdlIHdpbGwgaGF2ZSB0byAnc2hpbScgdGhlIGJpbmFyeSB0cmVlIGluZGV4J3MgJGxva2kgaWRzIGJhY2tcbiAgICAgICAgICAgICAgICAvLyBpbnRvIGRhdGEgYXJyYXkgaW5kaWNlcywgaWRlYWxseSBpIHdvdWxkIGxpa2UgdG8gcmVwdXJwb3NlIGZpbHRlcmVkcm93cyB0byB1c2UgbG9raSBpZHNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpZCBvZiBpZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9jb2xsZWN0aW9uLmdldChpZCwgdHJ1ZSlbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZmlsdGVyaW5nIHZpYSBhIGphdmFzY3JpcHQgZmlsdGVyIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1biAtIEEgamF2YXNjcmlwdCBmdW5jdGlvbiB1c2VkIGZvciBmaWx0ZXJpbmcgY3VycmVudCByZXN1bHRzIGJ5LlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9IHRoaXMgUmVzdWx0U2V0IGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICB3aGVyZShmdW4pIHtcbiAgICAgICAgbGV0IHZpZXdGdW5jdGlvbjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZnVuKSB7XG4gICAgICAgICAgICB2aWV3RnVuY3Rpb24gPSBmdW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgc3RvcmVkIHZpZXcgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZmlsdGVyZWRSb3dzW10gaXMgYWxyZWFkeSBpbml0aWFsaXplZCwgdXNlIGl0XG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXJJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgbGV0IGogPSB0aGlzLl9maWx0ZXJlZFJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgICAgIGlmICh2aWV3RnVuY3Rpb24odGhpcy5fY29sbGVjdGlvbi5fZGF0YVt0aGlzLl9maWx0ZXJlZFJvd3Nbal1dKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9maWx0ZXJlZFJvd3Nbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGlzIGlzIGluaXRpYWwgY2hhaW5lZCBvcCwgd29yayBhZ2FpbnN0IGRhdGEsIHB1c2ggaW50byBmaWx0ZXJlZFJvd3NbXVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrID0gdGhpcy5fY29sbGVjdGlvbi5fZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoay0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdGdW5jdGlvbih0aGlzLl9jb2xsZWN0aW9uLl9kYXRhW2tdKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJlZFJvd3MgPSByZXN1bHQ7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGluIHRoZSBSZXN1bHRTZXQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW4gdGhlIFJlc3VsdFNldC5cbiAgICAgKi9cbiAgICBjb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbHRlckluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWRSb3dzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5jb3VudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGVzIHRoZSBjaGFpbiBhbmQgcmV0dXJucyBhcnJheSBvZiBmaWx0ZXJlZCBkb2N1bWVudHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yY2VDbG9uZXNdIC0gQWxsb3dzIGZvcmNpbmcgdGhlIHJldHVybiBvZiBjbG9uZWQgb2JqZWN0cyBldmVuIHdoZW5cbiAgICAgKiAgICAgICAgdGhlIGNvbGxlY3Rpb24gaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGNsb25lIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9yY2VDbG9uZU1ldGhvZF0gLSBBbGxvd3Mgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBvciBjb2xsZWN0aW9uIHNwZWNpZmllZCBjbG9uaW5nIG1ldGhvZC5cbiAgICAgKiAgICAgICAgUG9zc2libGUgdmFsdWVzICdwYXJzZS1zdHJpbmdpZnknLCAnZGVlcCcsIGFuZCAnc2hhbGxvdycgYW5kXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZW1vdmVNZXRhXSAtIHdpbGwgZm9yY2UgY2xvbmVzIGFuZCBzdHJpcCAkbG9raSBhbmQgbWV0YSBwcm9wZXJ0aWVzIGZyb20gZG9jdW1lbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGRvY3VtZW50cyBpbiB0aGUgUmVzdWx0U2V0XG4gICAgICovXG4gICAgZGF0YShvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGZvcmNlQ2xvbmVzO1xuICAgICAgICBsZXQgZm9yY2VDbG9uZU1ldGhvZDtcbiAgICAgICAgbGV0IHJlbW92ZU1ldGE7XG4gICAgICAgICh7XG4gICAgICAgICAgICBmb3JjZUNsb25lcyA9IGZhbHNlLFxuICAgICAgICAgICAgZm9yY2VDbG9uZU1ldGhvZCA9IHRoaXMuX2NvbGxlY3Rpb24uX2Nsb25lTWV0aG9kLFxuICAgICAgICAgICAgcmVtb3ZlTWV0YSA9IGZhbHNlXG4gICAgICAgIH0gPSBvcHRpb25zKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2NvbGxlY3Rpb24uX2RhdGE7XG4gICAgICAgIGxldCBvYmo7XG4gICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgIC8vIGlmIHVzZXIgb3B0cyB0byBzdHJpcCBtZXRhLCB0aGVuIGZvcmNlIGNsb25lcyBhbmQgdXNlICdzaGFsbG93JyBpZiAnZm9yY2UnIG9wdGlvbnMgYXJlIG5vdCBwcmVzZW50XG4gICAgICAgIGlmIChyZW1vdmVNZXRhICYmICFmb3JjZUNsb25lcykge1xuICAgICAgICAgICAgZm9yY2VDbG9uZXMgPSB0cnVlO1xuICAgICAgICAgICAgZm9yY2VDbG9uZU1ldGhvZCA9IFwic2hhbGxvd1wiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGNvbGxlY3Rpb24gaGFzIGRlbHRhIGNoYW5nZXMgYWN0aXZlLCB0aGVuIGZvcmNlIGNsb25lcyBhbmQgdXNlIENsb25lTWV0aG9kLkRFRVAgZm9yIGVmZmVjdGl2ZSBjaGFuZ2UgdHJhY2tpbmcgb2YgbmVzdGVkIG9iamVjdHNcbiAgICAgICAgaWYgKCF0aGlzLl9jb2xsZWN0aW9uLl9kaXNhYmxlRGVsdGFDaGFuZ2VzQXBpKSB7XG4gICAgICAgICAgICBmb3JjZUNsb25lcyA9IHRydWU7XG4gICAgICAgICAgICBmb3JjZUNsb25lTWV0aG9kID0gXCJkZWVwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhpcyBoYXMgbm8gZmlsdGVycyBhcHBsaWVkLCBqdXN0IHJldHVybiBjb2xsZWN0aW9uLmRhdGFcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbHRlcmVkUm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGNsb25lIG9iamVjdHMgb3Igbm90XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb24uX2Nsb25lT2JqZWN0cyB8fCBmb3JjZUNsb25lcykge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBmb3JjZUNsb25lTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMuX2NvbGxlY3Rpb24uX2RlZmluZU5lc3RlZFByb3BlcnRpZXMoY2xvbmUoZGF0YVtpXSwgbWV0aG9kKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlTWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmouJGxva2k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9iai5tZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYXJlIG5vdCBjbG9uaW5nIHNvIHJldHVybiBzbGljZWQgYXJyYXkgd2l0aCBzYW1lIG9iamVjdCByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyZWRSb3dzIG11c3QgaGF2ZSBiZWVuIHNldCBtYW51YWxseSwgc28gdXNlIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyID0gdGhpcy5fZmlsdGVyZWRSb3dzO1xuICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbi5fY2xvbmVPYmplY3RzIHx8IGZvcmNlQ2xvbmVzKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBmb3JjZUNsb25lTWV0aG9kO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMuX2NvbGxlY3Rpb24uX2RlZmluZU5lc3RlZFByb3BlcnRpZXMoY2xvbmUoZGF0YVtmcltpXV0sIG1ldGhvZCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmouJGxva2k7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmoubWV0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkYXRhW2ZyW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBydW4gYW4gdXBkYXRlIG9wZXJhdGlvbiBvbiBhbGwgZG9jdW1lbnRzIGN1cnJlbnRseSBpbiB0aGUgUmVzdWx0U2V0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHVwZGF0ZUZ1bmN0aW9uIC0gVXNlciBzdXBwbGllZCB1cGRhdGVGdW5jdGlvbihvYmopIHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggZG9jdW1lbnQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9IHRoaXMgUmVzdWx0U2V0IGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICB1cGRhdGUodXBkYXRlRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gaWYgdGhpcyBoYXMgbm8gZmlsdGVycyBhcHBsaWVkLCB3ZSBuZWVkIHRvIHBvcHVsYXRlIGZpbHRlcmVkUm93cyBmaXJzdFxuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckluaXRpYWxpemVkICYmIHRoaXMuX2ZpbHRlcmVkUm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IHRoaXMuX2NvbGxlY3Rpb24uX3ByZXBhcmVGdWxsRG9jSW5kZXgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9maWx0ZXJlZFJvd3MubGVuZ3RoO1xuICAgICAgICBjb25zdCByY2QgPSB0aGlzLl9jb2xsZWN0aW9uLl9kYXRhO1xuICAgICAgICAvLyBwYXNzIGluIGVhY2ggZG9jdW1lbnQgb2JqZWN0IGN1cnJlbnRseSBpbiBSZXN1bHRTZXQgdG8gdXNlciBzdXBwbGllZCB1cGRhdGVGdW5jdGlvblxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNsb25pbmcgb3B0aW9uIHNwZWNpZmllZCBvciBhcmUgZG9pbmcgZGlmZmVyZW50aWFsIGRlbHRhIGNoYW5nZXMsIGNsb25lIG9iamVjdCBmaXJzdFxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb24uX2Nsb25lT2JqZWN0cyB8fCAhdGhpcy5fY29sbGVjdGlvbi5fZGlzYWJsZURlbHRhQ2hhbmdlc0FwaSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IGNsb25lKHJjZFt0aGlzLl9maWx0ZXJlZFJvd3NbaWR4XV0sIHRoaXMuX2NvbGxlY3Rpb24uX2Nsb25lTWV0aG9kKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jdGlvbihvYmopO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24udXBkYXRlKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIGNsb25lLCBzbyBqdXN0IHBlcmZvcm0gdXBkYXRlIG9uIGNvbGxlY3Rpb24gZGF0YSBvYmplY3QgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jdGlvbihyY2RbdGhpcy5fZmlsdGVyZWRSb3dzW2lkeF1dKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uLnVwZGF0ZShyY2RbdGhpcy5fZmlsdGVyZWRSb3dzW2lkeF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZG9jdW1lbnQgb2JqZWN0cyB3aGljaCBhcmUgY3VycmVudGx5IGluIFJlc3VsdFNldCBmcm9tIGNvbGxlY3Rpb24gKGFzIHdlbGwgYXMgUmVzdWx0U2V0KVxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9IHRoaXMgKGVtcHR5KSBSZXN1bHRTZXQgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBoYXMgbm8gZmlsdGVycyBhcHBsaWVkLCB3ZSBuZWVkIHRvIHBvcHVsYXRlIGZpbHRlcmVkUm93cyBmaXJzdFxuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckluaXRpYWxpemVkICYmIHRoaXMuX2ZpbHRlcmVkUm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IHRoaXMuX2NvbGxlY3Rpb24uX3ByZXBhcmVGdWxsRG9jSW5kZXgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uLnJlbW92ZSh0aGlzLmRhdGEoKSk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGF0YSB0cmFuc2Zvcm1hdGlvbiB2aWEgdXNlciBzdXBwbGllZCBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZ1bmN0aW9uIC0gdGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgc2luZ2xlIGRvY3VtZW50IGZvciB5b3UgdG8gdHJhbnNmb3JtIGFuZCByZXR1cm5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWR1Y2VGdW5jdGlvbiAtIHRoaXMgZnVuY3Rpb24gYWNjZXB0cyBtYW55IChhcnJheSBvZiBtYXAgb3V0cHV0cykgYW5kIHJldHVybnMgc2luZ2xlIHZhbHVlXG4gICAgICogQHJldHVybnMge3ZhbHVlfSBUaGUgb3V0cHV0IG9mIHlvdXIgcmVkdWNlRnVuY3Rpb25cbiAgICAgKi9cbiAgICBtYXBSZWR1Y2UobWFwRnVuY3Rpb24sIHJlZHVjZUZ1bmN0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlRnVuY3Rpb24odGhpcy5kYXRhKCkubWFwKG1hcEZ1bmN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlZnQgam9pbmluZyB0d28gc2V0cyBvZiBkYXRhLiBKb2luIGtleXMgY2FuIGJlIGRlZmluZWQgb3IgY2FsY3VsYXRlZCBwcm9wZXJ0aWVzXG4gICAgICogZXFKb2luIGV4cGVjdHMgdGhlIHJpZ2h0IGpvaW4ga2V5IHZhbHVlcyB0byBiZSB1bmlxdWUuICBPdGhlcndpc2UgbGVmdCBkYXRhIHdpbGwgYmUgam9pbmVkIG9uIHRoZSBsYXN0IGpvaW5EYXRhIG9iamVjdCB3aXRoIHRoYXQga2V5XG4gICAgICogQHBhcmFtIHtBcnJheXxSZXN1bHRTZXR8Q29sbGVjdGlvbn0gam9pbkRhdGEgLSBEYXRhIGFycmF5IHRvIGpvaW4gdG8uXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKX0gbGVmdEpvaW5LZXkgLSBQcm9wZXJ0eSBuYW1lIGluIHRoaXMgcmVzdWx0IHNldCB0byBqb2luIG9uIG9yIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIHZhbHVlIHRvIGpvaW4gb25cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8ZnVuY3Rpb24pfSByaWdodEpvaW5LZXkgLSBQcm9wZXJ0eSBuYW1lIGluIHRoZSBqb2luRGF0YSB0byBqb2luIG9uIG9yIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIHZhbHVlIHRvIGpvaW4gb25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbbWFwRnVuPV0gLSBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgZWFjaCBtYXRjaGluZyBwYWlyIGFuZCBtYXBzIHRoZW0gaW50byBvdXRwdXQgb2JqZWN0cyAtIGZ1bmN0aW9uKGxlZnQscmlnaHQpe3JldHVybiBqb2luZWRPYmplY3R9XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtkYXRhT3B0aW9ucz1dIC0gb3B0aW9uYWwgb3B0aW9ucyB0byBhcHBseSB0byBkYXRhKCkgY2FsbHMgZm9yIGxlZnQgYW5kIHJpZ2h0IHNpZGVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkYXRhT3B0aW9ucy5yZW1vdmVNZXRhIC0gYWxsb3dzIHJlbW92aW5nIG1ldGEgYmVmb3JlIGNhbGxpbmcgbWFwRnVuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkYXRhT3B0aW9ucy5mb3JjZUNsb25lcyAtIGZvcmNpbmcgdGhlIHJldHVybiBvZiBjbG9uZWQgb2JqZWN0cyB0byB5b3VyIG1hcCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YU9wdGlvbnMuZm9yY2VDbG9uZU1ldGhvZCAtIGFsbG93cyBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IG9yIGNvbGxlY3Rpb24gc3BlY2lmaWVkIGNsb25pbmcgbWV0aG9kXG4gICAgICogQHJldHVybnMge1Jlc3VsdFNldH0gQSBSZXN1bHRTZXQgd2l0aCBkYXRhIGluIHRoZSBmb3JtYXQgW3tsZWZ0OiBsZWZ0T2JqLCByaWdodDogcmlnaHRPYmp9XVxuICAgICAqL1xuICAgIGVxSm9pbihqb2luRGF0YSwgbGVmdEpvaW5LZXksIHJpZ2h0Sm9pbktleSwgbWFwRnVuLCBkYXRhT3B0aW9ucykge1xuICAgICAgICBsZXQgcmlnaHREYXRhID0gW107XG4gICAgICAgIGxldCByaWdodERhdGFMZW5ndGg7XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGxlZnRLZXlpc0Z1bmN0aW9uID0gdHlwZW9mIGxlZnRKb2luS2V5ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGxldCByaWdodEtleWlzRnVuY3Rpb24gPSB0eXBlb2YgcmlnaHRKb2luS2V5ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGxldCBqb2luTWFwID0ge307XG4gICAgICAgIC8vZ2V0IHRoZSBsZWZ0IGRhdGFcbiAgICAgICAgbGV0IGxlZnREYXRhID0gdGhpcy5kYXRhKGRhdGFPcHRpb25zKTtcbiAgICAgICAgbGV0IGxlZnREYXRhTGVuZ3RoID0gbGVmdERhdGEubGVuZ3RoO1xuICAgICAgICAvL2dldCB0aGUgcmlnaHQgZGF0YVxuICAgICAgICBpZiAoam9pbkRhdGEgaW5zdGFuY2VvZiBjb2xsZWN0aW9uX0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJpZ2h0RGF0YSA9IGpvaW5EYXRhLmNoYWluKCkuZGF0YShkYXRhT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoam9pbkRhdGEgaW5zdGFuY2VvZiByZXN1bHRfc2V0X1Jlc3VsdFNldCkge1xuICAgICAgICAgICAgcmlnaHREYXRhID0gam9pbkRhdGEuZGF0YShkYXRhT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShqb2luRGF0YSkpIHtcbiAgICAgICAgICAgIHJpZ2h0RGF0YSA9IGpvaW5EYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImpvaW5EYXRhIG5lZWRzIHRvIGJlIGFuIGFycmF5IG9yIHJlc3VsdCBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmlnaHREYXRhTGVuZ3RoID0gcmlnaHREYXRhLmxlbmd0aDtcbiAgICAgICAgLy9jb25zdHJ1Y3QgYSBsb29rdXAgdGFibGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByaWdodERhdGFMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0gcmlnaHRLZXlpc0Z1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyByaWdodEpvaW5LZXkocmlnaHREYXRhW2ldKVxuICAgICAgICAgICAgICAgIDogcmlnaHREYXRhW2ldW3JpZ2h0Sm9pbktleV07XG4gICAgICAgICAgICBqb2luTWFwW2tleV0gPSByaWdodERhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXBGdW4pIHtcbiAgICAgICAgICAgIG1hcEZ1biA9IChsZWZ0LCByaWdodCkgPT4gKHtcbiAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL1J1biBtYXAgZnVuY3Rpb24gb3ZlciBlYWNoIG9iamVjdCBpbiB0aGUgUmVzdWx0U2V0XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVmdERhdGFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAga2V5ID0gbGVmdEtleWlzRnVuY3Rpb25cbiAgICAgICAgICAgICAgICA/IGxlZnRKb2luS2V5KGxlZnREYXRhW2pdKVxuICAgICAgICAgICAgICAgIDogbGVmdERhdGFbal1bbGVmdEpvaW5LZXldO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwRnVuKGxlZnREYXRhW2pdLCBqb2luTWFwW2tleV0gfHwge30pKTtcbiAgICAgICAgfVxuICAgICAgICAvL3JldHVybiBhIG5ldyBSZXN1bHRTZXQgd2l0aCBubyBmaWx0ZXJzXG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBuZXcgY29sbGVjdGlvbl9Db2xsZWN0aW9uKFwiam9pbkRhdGFcIik7XG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24uaW5zZXJ0KHJlc3VsdCk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IFtdO1xuICAgICAgICB0aGlzLl9maWx0ZXJJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIG1hcCBmdW5jdGlvbiBpbnRvIGEgbmV3IGNvbGxlY3Rpb24gZm9yIGZ1cnRoZXIgY2hhaW5pbmcuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRnVuIC0gamF2YXNjcmlwdCBtYXAgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2RhdGFPcHRpb25zPV0gLSBvcHRpb25zIHRvIGRhdGEoKSBiZWZvcmUgaW5wdXQgdG8geW91ciBtYXAgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRhdGFPcHRpb25zLnJlbW92ZU1ldGEgLSBhbGxvd3MgcmVtb3ZpbmcgbWV0YSBiZWZvcmUgY2FsbGluZyBtYXBGdW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRhdGFPcHRpb25zLmZvcmNlQ2xvbmVzIC0gZm9yY2luZyB0aGUgcmV0dXJuIG9mIGNsb25lZCBvYmplY3RzIHRvIHlvdXIgbWFwIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhT3B0aW9ucy5mb3JjZUNsb25lTWV0aG9kIC0gQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWQgY2xvbmluZyBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtSZXN1bHRTZXR9XG4gICAgICovXG4gICAgbWFwKG1hcEZ1biwgZGF0YU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YShkYXRhT3B0aW9ucykubWFwKG1hcEZ1bik7XG4gICAgICAgIC8vcmV0dXJuIHJldHVybiBhIG5ldyBSZXN1bHRTZXQgd2l0aCBubyBmaWx0ZXJzXG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBuZXcgY29sbGVjdGlvbl9Db2xsZWN0aW9uKFwibWFwcGVkRGF0YVwiKTtcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbi5pbnNlcnQoZGF0YSk7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkUm93cyA9IFtdO1xuICAgICAgICB0aGlzLl9maWx0ZXJJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvbG9raS9zcmMvZHluYW1pY192aWV3LnRzXG5cblxuLyoqXG4gKiBEeW5hbWljVmlldyBjbGFzcyBpcyBhIHZlcnNhdGlsZSAnbGl2ZScgdmlldyBjbGFzcyB3aGljaCBjYW4gaGF2ZSBmaWx0ZXJzIGFuZCBzb3J0cyBhcHBsaWVkLlxuICogICAgQ29sbGVjdGlvbi5hZGREeW5hbWljVmlldyhuYW1lKSBpbnN0YW50aWF0ZXMgdGhpcyBEeW5hbWljVmlldyBvYmplY3QgYW5kIG5vdGlmaWVzIGl0XG4gKiAgICB3aGVuZXZlciBkb2N1bWVudHMgYXJlIGFkZC91cGRhdGVkL3JlbW92ZWQgc28gaXQgY2FuIHJlbWFpbiB1cC10by1kYXRlLiAoY2hhaW5hYmxlKVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgbXlkdiA9IG15Y29sbGVjdGlvbi5hZGREeW5hbWljVmlldygndGVzdCcpOyAgLy8gZGVmYXVsdCBpcyBub24tcGVyc2lzdGVudFxuICogbXlkdi5hcHBseUZpbmQoeyAnZG9vcnMnIDogNCB9KTtcbiAqIG15ZHYuYXBwbHlXaGVyZShmdW5jdGlvbihvYmopIHsgcmV0dXJuIG9iai5uYW1lID09PSAnVG95b3RhJzsgfSk7XG4gKiBsZXQgcmVzdWx0cyA9IG15ZHYuZGF0YSgpO1xuICpcbiAqIEBleHRlbmRzIExva2lFdmVudEVtaXR0ZXJcblxuICogQHNlZSB7QGxpbmsgQ29sbGVjdGlvbiNhZGREeW5hbWljVmlld30gdG8gY29uc3RydWN0IGluc3RhbmNlcyBvZiBEeW5hbWljVmlld1xuICpcbiAqIEBwYXJhbSA8VERhdGE+IC0gdGhlIGRhdGEgdHlwZVxuICogQHBhcmFtIDxUTmVzdGVkPiAtIG5lc3RlZCBwcm9wZXJ0aWVzIG9mIGRhdGEgdHlwZVxuICovXG5jbGFzcyBkeW5hbWljX3ZpZXdfRHluYW1pY1ZpZXcgZXh0ZW5kcyBldmVudF9lbWl0dGVyW1wiYVwiIC8qIExva2lFdmVudEVtaXR0ZXIgKi9dIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge0NvbGxlY3Rpb259IGNvbGxlY3Rpb24gLSBhIHJlZmVyZW5jZSB0byB0aGUgY29sbGVjdGlvbiB0byB3b3JrIGFnYWluc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhpcyBkeW5hbWljIHZpZXdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wZXJzaXN0ZW50PWZhbHNlXSAtIGluZGljYXRlcyBpZiB2aWV3IGlzIHRvIG1haW4gaW50ZXJuYWwgcmVzdWx0cyBhcnJheSBpbiAncmVzdWx0ZGF0YSdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc29ydFByaW9yaXR5PVwicGFzc2l2ZVwiXSAtIHRoZSBzb3J0IHByaW9yaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pblJlYnVpbGRJbnRlcnZhbD0xXSAtIG1pbmltdW0gcmVidWlsZCBpbnRlcnZhbCAobmVlZCBjbGFyaWZpY2F0aW9uIHRvIGRvY3MgaGVyZSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uLCBuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcmVidWlsZFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVzdWx0RGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9yZXN1bHREaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jYWNoZWRSZXN1bHRTZXQgPSBudWxsO1xuICAgICAgICAvLyBrZWVwIG9yZGVyZWQgZmlsdGVyIHBpcGVsaW5lXG4gICAgICAgIHRoaXMuX2ZpbHRlclBpcGVsaW5lID0gW107XG4gICAgICAgIC8vIHNvcnRpbmcgbWVtYmVyIHZhcmlhYmxlc1xuICAgICAgICAvLyB3ZSBvbmx5IHN1cHBvcnQgb25lIGFjdGl2ZSBzZWFyY2gsIGFwcGxpZWQgdXNpbmcgYXBwbHlTb3J0KCkgb3IgYXBwbHlTaW1wbGVTb3J0KClcbiAgICAgICAgdGhpcy5fc29ydEZ1bmN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc29ydENyaXRlcmlhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc29ydENyaXRlcmlhU2ltcGxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc29ydEJ5U2NvcmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NvcnREaXJ0eSA9IGZhbHNlO1xuICAgICAgICAoe1xuICAgICAgICAgICAgcGVyc2lzdGVudDogdGhpcy5fcGVyc2lzdGVudCA9IGZhbHNlLFxuICAgICAgICAgICAgLy8gJ3Bhc3NpdmUnIHdpbGwgZGVmZXIgdGhlIHNvcnQgcGhhc2UgdW50aWwgdGhleSBjYWxsIGRhdGEoKS4gKG1vc3QgZWZmaWNpZW50IG92ZXJhbGwpXG4gICAgICAgICAgICAvLyAnYWN0aXZlJyB3aWxsIHNvcnQgYXN5bmMgd2hlbmV2ZXIgbmV4dCBpZGxlLiAocHJpb3JpdGl6ZXMgcmVhZCBzcGVlZHMpXG4gICAgICAgICAgICBzb3J0UHJpb3JpdHk6IHRoaXMuX3NvcnRQcmlvcml0eSA9IFwicGFzc2l2ZVwiLFxuICAgICAgICAgICAgbWluUmVidWlsZEludGVydmFsOiB0aGlzLl9taW5SZWJ1aWxkSW50ZXJ2YWwgPSAxXG4gICAgICAgIH0gPSBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFNldCA9IG5ldyByZXN1bHRfc2V0X1Jlc3VsdFNldChjb2xsZWN0aW9uKTtcbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IGhhdmUgMSBldmVudCBmb3Igd2hlbiB3ZSBmaW5hbGx5IHJlYnVpbHQgbGF6eSB2aWV3XG4gICAgICAgIC8vIG9uY2Ugd2UgcmVmYWN0b3IgdHJhbnNhY3Rpb25zLCBpIHdpbGwgdGllIGluIGNlcnRhaW4gdHJhbnNhY3Rpb25hbCBldmVudHNcbiAgICAgICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgICAgICAgXCJyZWJ1aWxkXCI6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgdXNlZCBpbW1lZGlhdGVseSBhZnRlciBkZXNlcmlhbGl6YXRpb24gKGxvYWRpbmcpXG4gICAgICogICAgVGhpcyB3aWxsIGNsZWFyIG91dCBhbmQgcmVhcHBseSBmaWx0ZXJQaXBlbGluZSBvcHMsIHJlY3JlYXRpbmcgdGhlIHZpZXcuXG4gICAgICogICAgU2luY2Ugd2hlcmUgZmlsdGVycyBkbyBub3QgcGVyc2lzdCBjb3JyZWN0bHksIHRoaXMgbWV0aG9kIGFsbG93c1xuICAgICAqICAgIHJlc3RvcmluZyB0aGUgdmlldyB0byBzdGF0ZSB3aGVyZSB1c2VyIGNhbiByZS1hcHBseSB0aG9zZSB3aGVyZSBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbW92ZVdoZXJlRmlsdGVyc1xuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gVGhpcyBkeW5hbWljIHZpZXcgZm9yIGZ1cnRoZXIgY2hhaW5lZCBvcHMuXG4gICAgICogQGZpcmVzIER5bmFtaWNWaWV3LnJlYnVpbGRcbiAgICAgKi9cbiAgICBfcmVtYXRlcmlhbGl6ZSh7IHJlbW92ZVdoZXJlRmlsdGVycyA9IGZhbHNlIH0pIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0RGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9yZXN1bHREaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFNldCA9IG5ldyByZXN1bHRfc2V0X1Jlc3VsdFNldCh0aGlzLl9jb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuX3NvcnRGdW5jdGlvbiB8fCB0aGlzLl9zb3J0Q3JpdGVyaWEgfHwgdGhpcy5fc29ydENyaXRlcmlhU2ltcGxlIHx8IHRoaXMuX3NvcnRCeVNjb3JpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnREaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZVdoZXJlRmlsdGVycykge1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggdmlldyBzZWUgaWYgaXQgaGFkIGFueSB3aGVyZSBmaWx0ZXJzIGFwcGxpZWQuLi4gc2luY2UgdGhleSBkb24ndFxuICAgICAgICAgICAgLy8gc2VyaWFsaXplIHRob3NlIGZ1bmN0aW9ucyBsZXRzIHJlbW92ZSB0aG9zZSBpbnZhbGlkIGZpbHRlcnNcbiAgICAgICAgICAgIGxldCBmcGkgPSB0aGlzLl9maWx0ZXJQaXBlbGluZS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoZnBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmlsdGVyUGlwZWxpbmVbZnBpXS50eXBlID09PSBcIndoZXJlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZwaSAhPT0gdGhpcy5fZmlsdGVyUGlwZWxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyUGlwZWxpbmVbZnBpXSA9IHRoaXMuX2ZpbHRlclBpcGVsaW5lW3RoaXMuX2ZpbHRlclBpcGVsaW5lLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlclBpcGVsaW5lLmxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBiYWNrIHVwIG9sZCBmaWx0ZXIgcGlwZWxpbmUsIGNsZWFyIGZpbHRlciBwaXBlbGluZSwgYW5kIHJlYXBwbHkgcGlwZWxpbmUgb3BzXG4gICAgICAgIGNvbnN0IG9mcCA9IHRoaXMuX2ZpbHRlclBpcGVsaW5lO1xuICAgICAgICB0aGlzLl9maWx0ZXJQaXBlbGluZSA9IFtdO1xuICAgICAgICAvLyBub3cgcmUtYXBwbHkgJ2ZpbmQnIGZpbHRlclBpcGVsaW5lIG9wc1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBvZnAubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgdGhpcy5hcHBseUZpbmQob2ZwW2lkeF0udmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgY3JlYXRpb24gb2YgdW5pdCB0ZXN0cywgaSB3aWxsIHJlbW92ZSB0aGlzIGZvcmNlZCByZWZyZXNoIGFuZCBsZWF2ZSBsYXp5XG4gICAgICAgIHRoaXMuZGF0YSgpO1xuICAgICAgICAvLyBlbWl0IHJlYnVpbGQgZXZlbnQgaW4gY2FzZSB1c2VyIHdhbnRzIHRvIGJlIG5vdGlmaWVkXG4gICAgICAgIHRoaXMuZW1pdChcInJlYnVpbGRcIiwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIFJlc3VsdFNldCBmb3IgYnJhbmNoZWQgcXVlcmllcy5cbiAgICAgKiBVbmxpa2UgdGhpcyBkeW5hbWljIHZpZXcsIHRoZSBicmFuY2hlZCBSZXN1bHRTZXQgd2lsbCBub3QgYmUgJ2xpdmUnIHVwZGF0ZWQsXG4gICAgICogc28geW91ciBicmFuY2hlZCBxdWVyeSBzaG91bGQgYmUgaW1tZWRpYXRlbHkgcmVzb2x2ZWQgYW5kIG5vdCBoZWxkIGZvciBmdXR1cmUgZXZhbHVhdGlvbi5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8YXJyYXk9KX0gdHJhbnNmb3JtIC0gT3B0aW9uYWwgbmFtZSBvZiBjb2xsZWN0aW9uIHRyYW5zZm9ybSwgb3IgYW4gYXJyYXkgb2YgdHJhbnNmb3JtIHN0ZXBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtZXRlcnMgLSBvcHRpb25hbCBwYXJhbWV0ZXJzIChpZiBvcHRpb25hbCB0cmFuc2Zvcm0gcmVxdWlyZXMgdGhlbSlcbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0U2V0fSBBIGNvcHkgb2YgdGhlIGludGVybmFsIFJlc3VsdFNldCBmb3IgYnJhbmNoZWQgcXVlcmllcy5cbiAgICAgKi9cbiAgICBicmFuY2hSZXN1bHRTZXQodHJhbnNmb3JtLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJzID0gdGhpcy5fcmVzdWx0U2V0LmNvcHkoKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJzLnRyYW5zZm9ybSh0cmFuc2Zvcm0sIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBvZiB0b0pTT04gdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBfcGVyc2lzdGVudDogdGhpcy5fcGVyc2lzdGVudCxcbiAgICAgICAgICAgIF9zb3J0UHJpb3JpdHk6IHRoaXMuX3NvcnRQcmlvcml0eSxcbiAgICAgICAgICAgIF9taW5SZWJ1aWxkSW50ZXJ2YWw6IHRoaXMuX21pblJlYnVpbGRJbnRlcnZhbCxcbiAgICAgICAgICAgIF9yZXN1bHRTZXQ6IHRoaXMuX3Jlc3VsdFNldCxcbiAgICAgICAgICAgIF9maWx0ZXJQaXBlbGluZTogdGhpcy5fZmlsdGVyUGlwZWxpbmUsXG4gICAgICAgICAgICBfc29ydENyaXRlcmlhOiB0aGlzLl9zb3J0Q3JpdGVyaWEsXG4gICAgICAgICAgICBfc29ydENyaXRlcmlhU2ltcGxlOiB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUsXG4gICAgICAgICAgICBfc29ydEJ5U2NvcmluZzogdGhpcy5fc29ydEJ5U2NvcmluZyxcbiAgICAgICAgICAgIF9zb3J0RGlydHk6IHRoaXMuX3NvcnREaXJ0eSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OT2JqZWN0KGNvbGxlY3Rpb24sIG9iaikge1xuICAgICAgICBsZXQgZHYgPSBuZXcgZHluYW1pY192aWV3X0R5bmFtaWNWaWV3KGNvbGxlY3Rpb24sIG9iai5uYW1lKTtcbiAgICAgICAgZHYuX3Jlc3VsdERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgZHYuX2ZpbHRlclBpcGVsaW5lID0gb2JqLl9maWx0ZXJQaXBlbGluZTtcbiAgICAgICAgZHYuX3Jlc3VsdERhdGEgPSBbXTtcbiAgICAgICAgZHYuX3NvcnRDcml0ZXJpYSA9IG9iai5fc29ydENyaXRlcmlhO1xuICAgICAgICBkdi5fc29ydENyaXRlcmlhU2ltcGxlID0gb2JqLl9zb3J0Q3JpdGVyaWFTaW1wbGU7XG4gICAgICAgIGR2Ll9zb3J0QnlTY29yaW5nID0gb2JqLl9zb3J0QnlTY29yaW5nO1xuICAgICAgICBkdi5fc29ydERpcnR5ID0gb2JqLl9zb3J0RGlydHk7XG4gICAgICAgIGR2Ll9yZXN1bHRTZXQuX2ZpbHRlcmVkUm93cyA9IG9iai5fcmVzdWx0U2V0Ll9maWx0ZXJlZFJvd3M7XG4gICAgICAgIGR2Ll9yZXN1bHRTZXQuX2ZpbHRlckluaXRpYWxpemVkID0gb2JqLl9yZXN1bHRTZXQuX2ZpbHRlckluaXRpYWxpemVkO1xuICAgICAgICBkdi5fcmVtYXRlcmlhbGl6ZSh7XG4gICAgICAgICAgICByZW1vdmVXaGVyZUZpbHRlcnM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjbGVhciBwaXBlbGluZSBhbmQgcmVzZXQgZHluYW1pYyB2aWV3IHRvIGluaXRpYWwgc3RhdGUuXG4gICAgICogRXhpc3Rpbmcgb3B0aW9ucyBzaG91bGQgYmUgcmV0YWluZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBxdWV1ZVNvcnRQaGFzZSAtIChkZWZhdWx0OiBmYWxzZSkgaWYgdHJ1ZSB3ZSB3aWxsIGFzeW5jIHJlYnVpbGQgdmlldyAobWF5YmUgc2V0IGRlZmF1bHQgdG8gdHJ1ZSBpbiBmdXR1cmU/KVxuICAgICAqL1xuICAgIHJlbW92ZUZpbHRlcnMoeyBxdWV1ZVNvcnRQaGFzZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9yZWJ1aWxkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXN1bHRTZXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fcmVzdWx0RGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9yZXN1bHREaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NhY2hlZFJlc3VsdFNldCA9IG51bGw7XG4gICAgICAgIC8vIGtlZXAgb3JkZXJlZCBmaWx0ZXIgcGlwZWxpbmVcbiAgICAgICAgdGhpcy5fZmlsdGVyUGlwZWxpbmUgPSBbXTtcbiAgICAgICAgLy8gc29ydGluZyBtZW1iZXIgdmFyaWFibGVzXG4gICAgICAgIC8vIHdlIG9ubHkgc3VwcG9ydCBvbmUgYWN0aXZlIHNlYXJjaCwgYXBwbGllZCB1c2luZyBhcHBseVNvcnQoKSBvciBhcHBseVNpbXBsZVNvcnQoKVxuICAgICAgICB0aGlzLl9zb3J0RnVuY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9zb3J0Q3JpdGVyaWEgPSBudWxsO1xuICAgICAgICB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zb3J0QnlTY29yaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc29ydERpcnR5ID0gZmFsc2U7XG4gICAgICAgIGlmIChxdWV1ZVNvcnRQaGFzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVTb3J0UGhhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGFwcGx5IGEgc29ydCB0byB0aGUgZHluYW1pYyB2aWV3XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkdi5hcHBseVNvcnQoZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuICAgICAgICogICBpZiAob2JqMS5uYW1lID09PSBvYmoyLm5hbWUpIHJldHVybiAwO1xuICAgICAgICogICBpZiAob2JqMS5uYW1lID4gb2JqMi5uYW1lKSByZXR1cm4gMTtcbiAgICAgICAqICAgaWYgKG9iajEubmFtZSA8IG9iajIubmFtZSkgcmV0dXJuIC0xO1xuICAgICAgICogfSk7XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZWZ1biAtIGEgamF2YXNjcmlwdCBjb21wYXJlIGZ1bmN0aW9uIHVzZWQgZm9yIHNvcnRpbmdcbiAgICAgKiBAcmV0dXJucyB7RHluYW1pY1ZpZXd9IHRoaXMgRHluYW1pY1ZpZXcgb2JqZWN0LCBmb3IgZnVydGhlciBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgYXBwbHlTb3J0KGNvbXBhcmVmdW4pIHtcbiAgICAgICAgdGhpcy5fc29ydEZ1bmN0aW9uID0gY29tcGFyZWZ1bjtcbiAgICAgICAgdGhpcy5fc29ydENyaXRlcmlhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc29ydENyaXRlcmlhU2ltcGxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc29ydEJ5U2NvcmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3F1ZXVlU29ydFBoYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHNwZWNpZnkgYSBwcm9wZXJ0eSB1c2VkIGZvciB2aWV3IHRyYW5zbGF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIHRoZSBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufG9iamVjdD19IG9wdGlvbnMgLSBib29sZWFuIGZvciBzb3J0IGRlc2NlbmRpbmcgb3Igb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlc2M9ZmFsc2VdIC0gd2hldGhlciB3ZSBzaG91bGQgc29ydCBkZXNjZW5kaW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZUluZGV4SW50ZXJzZWN0PWZhbHNlXSAtIHdoZXRoZXIgd2Ugc2hvdWxkIGV4cGxpY2l0eSBub3QgdXNlIGFycmF5IGludGVyc2VjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlSW5kZXhJbnRlcnNlY3Q9ZmFsc2VdIC0gZm9yY2UgYXJyYXkgaW50ZXJzZWN0aW9uIChpZiBiaW5hcnkgaW5kZXggZXhpc3RzKS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVzZUphdmFzY3JpcHRTb3J0aW5nPWZhbHNlXSAtIHdoZXRoZXIgcmVzdWx0cyBhcmUgc29ydGVkIHZpYSBiYXNpYyBqYXZhc2NyaXB0IHNvcnQuXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCwgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZHYuYXBwbHlTaW1wbGVTb3J0KFwibmFtZVwiKTtcbiAgICAgKi9cbiAgICBhcHBseVNpbXBsZVNvcnQoZmllbGQsIG9wdGlvbnMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUgPSB7IGZpZWxkLCBvcHRpb25zIH07XG4gICAgICAgIHRoaXMuX3NvcnRGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NvcnRDcml0ZXJpYSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NvcnRCeVNjb3JpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9xdWV1ZVNvcnRQaGFzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHNvcnRpbmcgYSBSZXN1bHRTZXQgYmFzZWQgb24gbXVsdGlwbGUgY29sdW1ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjcml0ZXJpYSAtIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9yIHN1YmFycmF5IG9mIFtwcm9wZXJ0eW5hbWUsIGlzZGVzY10gdXNlZCBldmFsdWF0ZSBzb3J0IG9yZGVyXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSBSZWZlcmVuY2UgdG8gdGhpcyBEeW5hbWljVmlldywgc29ydGVkLCBmb3IgZnV0dXJlIGNoYWluIG9wZXJhdGlvbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0byBzb3J0IGJ5IGFnZSBhbmQgdGhlbiBuYW1lIChib3RoIGFzY2VuZGluZylcbiAgICAgKiBkdi5hcHBseVNvcnRDcml0ZXJpYShbJ2FnZScsICduYW1lJ10pO1xuICAgICAqIC8vIHRvIHNvcnQgYnkgYWdlIChhc2NlbmRpbmcpIGFuZCB0aGVuIGJ5IG5hbWUgKGRlc2NlbmRpbmcpXG4gICAgICogZHYuYXBwbHlTb3J0Q3JpdGVyaWEoWydhZ2UnLCBbJ25hbWUnLCB0cnVlXV0pO1xuICAgICAqIC8vIHRvIHNvcnQgYnkgYWdlIChkZXNjZW5kaW5nKSBhbmQgdGhlbiBieSBuYW1lIChkZXNjZW5kaW5nKVxuICAgICAqIGR2LmFwcGx5U29ydENyaXRlcmlhKFtbJ2FnZScsIHRydWVdLCBbJ25hbWUnLCB0cnVlXV0pO1xuICAgICAqL1xuICAgIGFwcGx5U29ydENyaXRlcmlhKGNyaXRlcmlhKSB7XG4gICAgICAgIHRoaXMuX3NvcnRDcml0ZXJpYSA9IGNyaXRlcmlhO1xuICAgICAgICB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zb3J0RnVuY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9zb3J0QnlTY29yaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcXVldWVTb3J0UGhhc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXBwbHkgYSBzb3J0IGJ5IHRoZSBsYXRlc3QgZnVsbC10ZXh0LXNlYXJjaCBzY29yaW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzY2VuZGluZz1mYWxzZV0gLSBzb3J0IGFzY2VuZGluZ1xuICAgICAqL1xuICAgIGFwcGx5U29ydEJ5U2NvcmluZyhhc2NlbmRpbmcgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9zb3J0RnVuY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9zb3J0Q3JpdGVyaWEgPSBudWxsO1xuICAgICAgICB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zb3J0QnlTY29yaW5nID0gYXNjZW5kaW5nO1xuICAgICAgICB0aGlzLl9xdWV1ZVNvcnRQaGFzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2NvcmluZyBvZiB0aGUgbGFzdCBmdWxsLXRleHQtc2VhcmNoLlxuICAgICAqIEByZXR1cm5zIHtTY29yZVJlc3VsdFtdfVxuICAgICAqL1xuICAgIGdldFNjb3JpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRTZXQuZ2V0U2NvcmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCwgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIHN0YXJ0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFJlc3VsdFNldCA9IHRoaXMuX3Jlc3VsdFNldC5jb3B5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21taXRzIGEgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCwgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUmVzdWx0U2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvbGxzIGJhY2sgYSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RHluYW1pY1ZpZXd9IHRoaXMgRHluYW1pY1ZpZXcgb2JqZWN0LCBmb3IgZnVydGhlciBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgcm9sbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFNldCA9IHRoaXMuX2NhY2hlZFJlc3VsdFNldDtcbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgIC8vIGZvciBub3cganVzdCByZWJ1aWxkIHRoZSBwZXJzaXN0ZW50IGR5bmFtaWMgdmlldyBkYXRhIGluIHRoaXMgd29yc3QgY2FzZSBzY2VuYXJpb1xuICAgICAgICAgICAgLy8gKGEgcGVyc2lzdGVudCB2aWV3IHV0aWxpemluZyB0cmFuc2FjdGlvbnMgd2hpY2ggZ2V0IHJvbGxlZCBiYWNrKSwgd2UgYWxyZWFkeSBrbm93IHRoZSBmaWx0ZXIgc28gbm90IHRvbyBiYWQuXG4gICAgICAgICAgICB0aGlzLl9yZXN1bHREYXRhID0gdGhpcy5fcmVzdWx0U2V0LmRhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInJlYnVpbGRcIiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGluZGV4IG9mIGEgZmlsdGVyIGluIHRoZSBwaXBlbGluZSwgYnkgdGhhdCBmaWx0ZXIncyBJRC5cbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKX0gdWlkIC0gVGhlIHVuaXF1ZSBJRCBvZiB0aGUgZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9OiBpbmRleCBvZiB0aGUgcmVmZXJlbmNlZCBmaWx0ZXIgaW4gdGhlIHBpcGVsaW5lOyAtMSBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgX2luZGV4T2ZGaWx0ZXJXaXRoSWQodWlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdWlkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB1aWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDAsIGxlbiA9IHRoaXMuX2ZpbHRlclBpcGVsaW5lLmxlbmd0aDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGlmICh1aWQgPT09IHRoaXMuX2ZpbHRlclBpcGVsaW5lW2lkeF0udWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBmaWx0ZXIgb2JqZWN0IHRvIHRoZSBlbmQgb2YgdmlldydzIGZpbHRlciBwaXBlbGluZSBhbmQgYXBwbHkgdGhlIGZpbHRlciB0byB0aGUgUmVzdWx0U2V0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmaWx0ZXIgLSBUaGUgZmlsdGVyIG9iamVjdC4gUmVmZXIgdG8gYXBwbHlGaWx0ZXIoKSBmb3IgZXh0cmEgZGV0YWlscy5cbiAgICAgKi9cbiAgICBfYWRkRmlsdGVyKGZpbHRlcikge1xuICAgICAgICB0aGlzLl9maWx0ZXJQaXBlbGluZS5wdXNoKGZpbHRlcik7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFNldFtmaWx0ZXIudHlwZV0oZmlsdGVyLnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYXBwbHkgYWxsIHRoZSBmaWx0ZXJzIGluIHRoZSBjdXJyZW50IHBpcGVsaW5lLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCwgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIHJlYXBwbHlGaWx0ZXJzKCkge1xuICAgICAgICB0aGlzLl9yZXN1bHRTZXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUmVzdWx0U2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdERhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5fZmlsdGVyUGlwZWxpbmU7XG4gICAgICAgIHRoaXMuX2ZpbHRlclBpcGVsaW5lID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDAsIGxlbiA9IGZpbHRlcnMubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRGaWx0ZXIoZmlsdGVyc1tpZHhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc29ydEZ1bmN0aW9uIHx8IHRoaXMuX3NvcnRDcml0ZXJpYSB8fCB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUgfHwgdGhpcy5fc29ydEJ5U2NvcmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVTb3J0UGhhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlUmVidWlsZEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgb3IgdXBkYXRlcyBhIGZpbHRlciBpbiB0aGUgRHluYW1pY1ZpZXcgZmlsdGVyIHBpcGVsaW5lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZpbHRlciAtIEEgZmlsdGVyIG9iamVjdCB0byBhZGQgdG8gdGhlIHBpcGVsaW5lLlxuICAgICAqICAgIFRoZSBvYmplY3QgaXMgaW4gdGhlIGZvcm1hdCB7ICd0eXBlJzogZmlsdGVyX3R5cGUsICd2YWwnLCBmaWx0ZXJfcGFyYW0sICd1aWQnLCBvcHRpb25hbF9maWx0ZXJfaWQgfVxuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gdGhpcyBEeW5hbWljVmlldyBvYmplY3QsIGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5faW5kZXhPZkZpbHRlcldpdGhJZChmaWx0ZXIudWlkKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJQaXBlbGluZVtpZHhdID0gZmlsdGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhcHBseUZpbHRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWNoZWRSZXN1bHRTZXQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVudCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0RGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0RGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEZpbHRlcihmaWx0ZXIpO1xuICAgICAgICBpZiAodGhpcy5fc29ydEZ1bmN0aW9uIHx8IHRoaXMuX3NvcnRDcml0ZXJpYSB8fCB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUgfHwgdGhpcy5fc29ydEJ5U2NvcmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVTb3J0UGhhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlUmVidWlsZEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFwcGx5RmluZCgpIC0gQWRkcyBvciB1cGRhdGVzIGEgbW9uZ28tc3R5bGUgcXVlcnkgb3B0aW9uIGluIHRoZSBEeW5hbWljVmlldyBmaWx0ZXIgcGlwZWxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeSAtIEEgbW9uZ28tc3R5bGUgcXVlcnkgb2JqZWN0IHRvIGFwcGx5IHRvIHBpcGVsaW5lXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IHVpZCAtIE9wdGlvbmFsOiBUaGUgdW5pcXVlIElEIG9mIHRoaXMgZmlsdGVyLCB0byByZWZlcmVuY2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBAcmV0dXJucyB7RHluYW1pY1ZpZXd9IHRoaXMgRHluYW1pY1ZpZXcgb2JqZWN0LCBmb3IgZnVydGhlciBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgYXBwbHlGaW5kKHF1ZXJ5LCB1aWQgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoe1xuICAgICAgICAgICAgdHlwZTogXCJmaW5kXCIsXG4gICAgICAgICAgICB2YWw6IHF1ZXJ5LFxuICAgICAgICAgICAgdWlkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBvciB1cGRhdGVzIGEgamF2YXNjcmlwdCBmaWx0ZXIgZnVuY3Rpb24gaW4gdGhlIER5bmFtaWNWaWV3IGZpbHRlciBwaXBlbGluZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1biAtIEEgamF2YXNjcmlwdCBmaWx0ZXIgZnVuY3Rpb24gdG8gYXBwbHkgdG8gcGlwZWxpbmVcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKX0gdWlkIC0gT3B0aW9uYWw6IFRoZSB1bmlxdWUgSUQgb2YgdGhpcyBmaWx0ZXIsIHRvIHJlZmVyZW5jZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gdGhpcyBEeW5hbWljVmlldyBvYmplY3QsIGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBhcHBseVdoZXJlKGZ1biwgdWlkKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoe1xuICAgICAgICAgICAgdHlwZTogXCJ3aGVyZVwiLFxuICAgICAgICAgICAgdmFsOiBmdW4sXG4gICAgICAgICAgICB1aWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHNwZWNpZmllZCBmaWx0ZXIgZnJvbSB0aGUgRHluYW1pY1ZpZXcgZmlsdGVyIHBpcGVsaW5lXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IHVpZCAtIFRoZSB1bmlxdWUgSUQgb2YgdGhlIGZpbHRlciB0byBiZSByZW1vdmVkLlxuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gdGhpcyBEeW5hbWljVmlldyBvYmplY3QsIGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICByZW1vdmVGaWx0ZXIodWlkKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2luZGV4T2ZGaWx0ZXJXaXRoSWQodWlkKTtcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgdmlldyBkb2VzIG5vdCBjb250YWluIGEgZmlsdGVyIHdpdGggSUQ6IFwiICsgdWlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maWx0ZXJQaXBlbGluZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5yZWFwcGx5RmlsdGVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgRHluYW1pY1ZpZXcgY29udGVudHMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBkb2N1bWVudHMgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IER5bmFtaWNWaWV3IGNvbnRlbnRzLlxuICAgICAqL1xuICAgIGNvdW50KCkge1xuICAgICAgICAvLyBpbiBvcmRlciB0byBiZSBhY2N1cmF0ZSB3ZSB3aWxsIHBheSB0aGUgbWluaW11bSBjb3N0IChhbmQgbm90IGFsdGVyIGR2IHN0YXRlIG1hbmFnZW1lbnQpXG4gICAgICAgIC8vIHJlY3VycmluZyBSZXN1bHRTZXQgZGF0YSByZXNvbHV0aW9ucyBzaG91bGQga25vdyBpbnRlcm5hbGx5IGl0cyBhbHJlYWR5IHVwIHRvIGRhdGUuXG4gICAgICAgIC8vIGZvciBwZXJzaXN0ZW50IGRhdGEgdGhpcyB3aWxsIG5vdCB1cGRhdGUgcmVzdWx0ZGF0YSBub3IgZmlyZSByZWJ1aWxkIGV2ZW50LlxuICAgICAgICBpZiAodGhpcy5fcmVzdWx0RGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdERhdGEgPSB0aGlzLl9yZXN1bHRTZXQuZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRTZXQuY291bnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYW5kIHBlbmRpbmcgZmlsdGVyaW5nIGFuZCBzb3J0aW5nLCB0aGVuIHJldHVybnMgZG9jdW1lbnQgYXJyYXkgYXMgcmVzdWx0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uYWwgcGFyYW1ldGVycyB0byBwYXNzIHRvIFJlc3VsdFNldC5kYXRhKCkgaWYgbm9uLXBlcnNpc3RlbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlQ2xvbmVzXSAtIEFsbG93cyBmb3JjaW5nIHRoZSByZXR1cm4gb2YgY2xvbmVkIG9iamVjdHMgZXZlbiB3aGVuXG4gICAgICogICAgICAgIHRoZSBjb2xsZWN0aW9uIGlzIG5vdCBjb25maWd1cmVkIGZvciBjbG9uZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZvcmNlQ2xvbmVNZXRob2RdIC0gQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWQgY2xvbmluZyBtZXRob2QuXG4gICAgICogICAgICAgIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlICdwYXJzZS1zdHJpbmdpZnknLCAnanF1ZXJ5LWV4dGVuZC1kZWVwJywgJ3NoYWxsb3cnLCAnc2hhbGxvdy1hc3NpZ24nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZW1vdmVNZXRhXSAtIHdpbGwgZm9yY2UgY2xvbmVzIGFuZCBzdHJpcCAkbG9raSBhbmQgbWV0YSBwcm9wZXJ0aWVzIGZyb20gZG9jdW1lbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGRvY3VtZW50cyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgRHluYW1pY1ZpZXcgY29udGVudHMuXG4gICAgICovXG4gICAgZGF0YShvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gdXNpbmcgZmluYWwgc29ydCBwaGFzZSBhcyAnY2F0Y2ggYWxsJyBmb3IgYSBmZXcgdXNlIGNhc2VzIHdoaWNoIHJlcXVpcmUgZnVsbCByZWJ1aWxkXG4gICAgICAgIGlmICh0aGlzLl9zb3J0RGlydHkgfHwgdGhpcy5fcmVzdWx0RGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1Tb3J0UGhhc2Uoe1xuICAgICAgICAgICAgICAgIHN1cHByZXNzUmVidWlsZEV2ZW50OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX3BlcnNpc3RlbnQpID8gKHRoaXMuX3Jlc3VsdERhdGEpIDogKHRoaXMuX3Jlc3VsdFNldC5kYXRhKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgdmlldyBpcyBub3Qgc29ydGVkIHdlIG1heSBzdGlsbCB3aXNoIHRvIGJlIG5vdGlmaWVkIG9mIHJlYnVpbGQgZXZlbnRzLlxuICAgICAqIFRoaXMgZXZlbnQgd2lsbCB0aHJvdHRsZSBhbmQgcXVldWUgYSBzaW5nbGUgcmVidWlsZCBldmVudCB3aGVuIGJhdGNoZXMgb2YgdXBkYXRlcyBhZmZlY3QgdGhlIHZpZXcuXG4gICAgICovXG4gICAgX3F1ZXVlUmVidWlsZEV2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVidWlsZFBlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWJ1aWxkUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlYnVpbGRQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVidWlsZFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWJ1aWxkXCIsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9taW5SZWJ1aWxkSW50ZXJ2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdmlldyBpcyBzb3J0ZWQgd2Ugd2lsbCB0aHJvdHRsZSBzb3J0aW5nIHRvIGVpdGhlciA6XG4gICAgICogKDEpIHBhc3NpdmUgLSB3aGVuIHRoZSB1c2VyIGNhbGxzIGRhdGEoKSwgb3JcbiAgICAgKiAoMikgYWN0aXZlIC0gb25jZSB0aGV5IHN0b3AgdXBkYXRpbmcgYW5kIHlpZWxkIGpzIHRocmVhZCBjb250cm9sXG4gICAgICovXG4gICAgX3F1ZXVlU29ydFBoYXNlKCkge1xuICAgICAgICAvLyBhbHJlYWR5IHF1ZXVlZD8gZXhpdCB3aXRob3V0IHF1ZXVpbmcgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMuX3NvcnREaXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvcnREaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9zb3J0UHJpb3JpdHkgPT09IFwiYWN0aXZlXCIpIHtcbiAgICAgICAgICAgIC8vIGFjdGl2ZSBzb3J0aW5nLi4uIG9uY2UgdGhleSBhcmUgZG9uZSBhbmQgeWllbGQganMgdGhyZWFkLCBydW4gYXN5bmMgcGVyZm9ybVNvcnRQaGFzZSgpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtU29ydFBoYXNlKCk7XG4gICAgICAgICAgICB9LCB0aGlzLl9taW5SZWJ1aWxkSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbXVzdCBiZSBwYXNzaXZlIHNvcnRpbmcuLi4gc2luY2Ugbm90IGNhbGxpbmcgcGVyZm9ybVNvcnRQaGFzZSAodW50aWwgZGF0YSBjYWxsKSwgbGV0cyB1c2UgcXVldWVSZWJ1aWxkRXZlbnQgdG9cbiAgICAgICAgICAgIC8vIHBvdGVudGlhbGx5IG5vdGlmeSB1c2VyIHRoYXQgZGF0YSBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlUmVidWlsZEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm91c2x5IHRvIHBlcmZvcm0gZmluYWwgc29ydCBwaGFzZSAoaWYgbmVlZGVkKVxuICAgICAqL1xuICAgIF9wZXJmb3JtU29ydFBoYXNlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBhc3luYyBjYWxsIHRvIHRoaXMgbWF5IGhhdmUgYmVlbiBwcmUtZW1wdGVkIGJ5IHN5bmNocm9ub3VzIGNhbGwgdG8gZGF0YSBiZWZvcmUgYXN5bmMgY291bGQgZmlyZVxuICAgICAgICBpZiAoIXRoaXMuX3NvcnREaXJ0eSAmJiAhdGhpcy5fcmVzdWx0RGlydHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc29ydERpcnR5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc29ydEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0U2V0LnNvcnQodGhpcy5fc29ydEZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3NvcnRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdFNldC5jb21wb3VuZHNvcnQodGhpcy5fc29ydENyaXRlcmlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3NvcnRDcml0ZXJpYVNpbXBsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdFNldC5zaW1wbGVzb3J0KHRoaXMuX3NvcnRDcml0ZXJpYVNpbXBsZS5maWVsZCwgdGhpcy5fc29ydENyaXRlcmlhU2ltcGxlLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc29ydEJ5U2NvcmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdFNldC5zb3J0QnlTY29yaW5nKHRoaXMuX3NvcnRCeVNjb3JpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc29ydERpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgIC8vIHBlcnNpc3RlbnQgdmlldywgcmVidWlsZCBsb2NhbCByZXN1bHRkYXRhIGFycmF5XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHREYXRhID0gdGhpcy5fcmVzdWx0U2V0LmRhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdERpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN1cHByZXNzUmVidWlsZEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWJ1aWxkXCIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIChSZSlldmFsdWF0aW5nIGRvY3VtZW50IGluY2x1c2lvbi5cbiAgICAgKiBDYWxsZWQgYnkgOiBjb2xsZWN0aW9uLmluc2VydCgpIGFuZCBjb2xsZWN0aW9uLnVwZGF0ZSgpLlxuICAgICAqIEBwYXJhbSB7aW50fSBvYmpJbmRleCAtIGluZGV4IG9mIGRvY3VtZW50IHRvIChyZSlydW4gdGhyb3VnaCBmaWx0ZXIgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc05ldyAtIHRydWUgaWYgdGhlIGRvY3VtZW50IHdhcyBqdXN0IGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfZXZhbHVhdGVEb2N1bWVudChvYmpJbmRleCwgaXNOZXcpIHtcbiAgICAgICAgLy8gaWYgbm8gZmlsdGVyIGFwcGxpZWQgeWV0LCB0aGUgcmVzdWx0ICdzZXQnIHNob3VsZCByZW1haW4gJ2V2ZXJ5dGhpbmcnXG4gICAgICAgIGlmICghdGhpcy5fcmVzdWx0U2V0Ll9maWx0ZXJJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHREYXRhID0gdGhpcy5fcmVzdWx0U2V0LmRhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gcmUtc29ydCB0byBzb3J0IG5ldyBkb2N1bWVudFxuICAgICAgICAgICAgaWYgKHRoaXMuX3NvcnRGdW5jdGlvbiB8fCB0aGlzLl9zb3J0Q3JpdGVyaWEgfHwgdGhpcy5fc29ydENyaXRlcmlhU2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVTb3J0UGhhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlUmVidWlsZEV2ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZyID0gdGhpcy5fcmVzdWx0U2V0Ll9maWx0ZXJlZFJvd3M7XG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IChpc05ldykgPyAoLTEpIDogKG9mci5pbmRleE9mKCtvYmpJbmRleCkpO1xuICAgICAgICBjb25zdCBvbGRsZW4gPSBvZnIubGVuZ3RoO1xuICAgICAgICAvLyBjcmVhdGluZyBhIDEtZWxlbWVudCBSZXN1bHRTZXQgdG8gcnVuIGZpbHRlciBjaGFpbiBvcHMgb24gdG8gc2VlIGlmIHRoYXQgZG9jIHBhc3NlcyBmaWx0ZXJzO1xuICAgICAgICAvLyBtb3N0bHkgZWZmaWNpZW50IGFsZ29yaXRobSwgc2xpZ2h0IHN0YWNrIG92ZXJoZWFkIHByaWNlICh0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpbnNlcnRzIGFuZCB1cGRhdGVzKVxuICAgICAgICBjb25zdCBldmFsUmVzdWx0U2V0ID0gbmV3IHJlc3VsdF9zZXRfUmVzdWx0U2V0KHRoaXMuX2NvbGxlY3Rpb24pO1xuICAgICAgICBldmFsUmVzdWx0U2V0Ll9maWx0ZXJlZFJvd3MgPSBbb2JqSW5kZXhdO1xuICAgICAgICBldmFsUmVzdWx0U2V0Ll9maWx0ZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGxldCBmaWx0ZXI7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDAsIGxlbiA9IHRoaXMuX2ZpbHRlclBpcGVsaW5lLmxlbmd0aDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgICAgICAgZmlsdGVyID0gdGhpcy5fZmlsdGVyUGlwZWxpbmVbaWR4XTtcbiAgICAgICAgICAgIGV2YWxSZXN1bHRTZXRbZmlsdGVyLnR5cGVdKGZpbHRlci52YWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBhIHRydWUgcG9zaXRpb24sIGJ1dCAtMSBpZiBub3QgcGFzcyBvdXIgZmlsdGVyKHMpLCAwIGlmIHBhc3NlZCBmaWx0ZXIocylcbiAgICAgICAgY29uc3QgbmV3UG9zID0gKGV2YWxSZXN1bHRTZXQuX2ZpbHRlcmVkUm93cy5sZW5ndGggPT09IDApID8gLTEgOiAwO1xuICAgICAgICAvLyB3YXNuJ3QgaW4gb2xkLCBzaG91bGRuJ3QgYmUgbm93Li4uIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKG9sZFBvcyA9PT0gLTEgJiYgbmV3UG9zID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gd2Fzbid0IGluIFJlc3VsdFNldCwgc2hvdWxkIGJlIG5vdy4uLiBhZGRcbiAgICAgICAgaWYgKG9sZFBvcyA9PT0gLTEgJiYgbmV3UG9zICE9PSAtMSkge1xuICAgICAgICAgICAgb2ZyLnB1c2gob2JqSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHREYXRhLnB1c2godGhpcy5fY29sbGVjdGlvbi5fZGF0YVtvYmpJbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmVlZCB0byByZS1zb3J0IHRvIHNvcnQgbmV3IGRvY3VtZW50XG4gICAgICAgICAgICBpZiAodGhpcy5fc29ydEZ1bmN0aW9uIHx8IHRoaXMuX3NvcnRDcml0ZXJpYSB8fCB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZVNvcnRQaGFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVSZWJ1aWxkRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YXMgaW4gUmVzdWx0U2V0LCBzaG91bGRuJ3QgYmUgbm93Li4uIGRlbGV0ZVxuICAgICAgICBpZiAob2xkUG9zICE9PSAtMSAmJiBuZXdQb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAob2xkUG9zIDwgb2xkbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgIG9mci5zcGxpY2Uob2xkUG9zLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHREYXRhLnNwbGljZShvbGRQb3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mci5sZW5ndGggPSBvbGRsZW4gLSAxO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdERhdGEubGVuZ3RoID0gb2xkbGVuIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbiBjYXNlIGNoYW5nZXMgdG8gZGF0YSBhbHRlcmVkIGEgc29ydCBjb2x1bW5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zb3J0RnVuY3Rpb24gfHwgdGhpcy5fc29ydENyaXRlcmlhIHx8IHRoaXMuX3NvcnRDcml0ZXJpYVNpbXBsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlU29ydFBoYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZVJlYnVpbGRFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhcyBpbiBSZXN1bHRTZXQsIHNob3VsZCBzdGlsbCBiZSBub3cuLi4gKHVwZGF0ZSBwZXJzaXN0ZW50IG9ubHk/KVxuICAgICAgICBpZiAob2xkUG9zICE9PSAtMSAmJiBuZXdQb3MgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVudCkge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgZG9jdW1lbnQgY2hhbmdlZCwgcmVwbGFjZSBwZXJzaXN0ZW50IHZpZXcgZGF0YSB3aXRoIHRoZSBsYXRlc3QgY29sbGVjdGlvbi5fZGF0YSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdERhdGFbb2xkUG9zXSA9IHRoaXMuX2NvbGxlY3Rpb24uX2RhdGFbb2JqSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW4gY2FzZSBjaGFuZ2VzIHRvIGRhdGEgYWx0ZXJlZCBhIHNvcnQgY29sdW1uXG4gICAgICAgICAgICBpZiAodGhpcy5fc29ydEZ1bmN0aW9uIHx8IHRoaXMuX3NvcnRDcml0ZXJpYSB8fCB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZVNvcnRQaGFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVSZWJ1aWxkRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgb24gY29sbGVjdGlvbi5kZWxldGUoKS5cbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgX3JlbW92ZURvY3VtZW50KG9iakluZGV4KSB7XG4gICAgICAgIC8vIGlmIG5vIGZpbHRlciBhcHBsaWVkIHlldCwgdGhlIHJlc3VsdCAnc2V0JyBzaG91bGQgcmVtYWluICdldmVyeXRoaW5nJ1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc3VsdFNldC5fZmlsdGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0RGF0YSA9IHRoaXMuX3Jlc3VsdFNldC5kYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbiBjYXNlIGNoYW5nZXMgdG8gZGF0YSBhbHRlcmVkIGEgc29ydCBjb2x1bW5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zb3J0RnVuY3Rpb24gfHwgdGhpcy5fc29ydENyaXRlcmlhIHx8IHRoaXMuX3NvcnRDcml0ZXJpYVNpbXBsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlU29ydFBoYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZVJlYnVpbGRFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mciA9IHRoaXMuX3Jlc3VsdFNldC5fZmlsdGVyZWRSb3dzO1xuICAgICAgICBjb25zdCBvbGRQb3MgPSBvZnIuaW5kZXhPZigrb2JqSW5kZXgpO1xuICAgICAgICBsZXQgb2xkbGVuID0gb2ZyLmxlbmd0aDtcbiAgICAgICAgaWYgKG9sZFBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBsYXN0IHJvdyBpbiByZXN1bHRkYXRhLCBzd2FwIGxhc3QgdG8gaG9sZSBhbmQgdHJ1bmNhdGUgbGFzdCByb3dcbiAgICAgICAgICAgIGlmIChvbGRQb3MgPCBvbGRsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgb2ZyW29sZFBvc10gPSBvZnJbb2xkbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgb2ZyLmxlbmd0aCA9IG9sZGxlbiAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0RGF0YVtvbGRQb3NdID0gdGhpcy5fcmVzdWx0RGF0YVtvbGRsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0RGF0YS5sZW5ndGggPSBvbGRsZW4gLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxhc3Qgcm93LCBzbyBqdXN0IHRydW5jYXRlIGxhc3Qgcm93XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZnIubGVuZ3RoID0gb2xkbGVuIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHREYXRhLmxlbmd0aCA9IG9sZGxlbiAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW4gY2FzZSBjaGFuZ2VzIHRvIGRhdGEgYWx0ZXJlZCBhIHNvcnQgY29sdW1uXG4gICAgICAgICAgICBpZiAodGhpcy5fc29ydEZ1bmN0aW9uIHx8IHRoaXMuX3NvcnRDcml0ZXJpYSB8fCB0aGlzLl9zb3J0Q3JpdGVyaWFTaW1wbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZVNvcnRQaGFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVSZWJ1aWxkRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgdXNpbmcgZmlsdGVyZWRSb3dzIHRvIHN0b3JlIGRhdGEgYXJyYXkgcG9zaXRpb25zXG4gICAgICAgIC8vIGlmIHRoZXkgcmVtb3ZlIGEgZG9jdW1lbnQgKHdoZXRoZXIgaW4gb3VyIHZpZXcgb3Igbm90KSxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBhZGp1c3QgYXJyYXkgcG9zaXRpb25zIC0xIGZvciBhbGwgZG9jdW1lbnQgYXJyYXkgcmVmZXJlbmNlcyBhZnRlciB0aGF0IHBvc2l0aW9uXG4gICAgICAgIG9sZGxlbiA9IG9mci5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IG9sZGxlbjsgaWR4KyspIHtcbiAgICAgICAgICAgIGlmIChvZnJbaWR4XSA+IG9iakluZGV4KSB7XG4gICAgICAgICAgICAgICAgb2ZyW2lkeF0tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhIHRyYW5zZm9ybWF0aW9uIHZpYSB1c2VyIHN1cHBsaWVkIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZ1bmN0aW9uIC0gdGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgc2luZ2xlIGRvY3VtZW50IGZvciB5b3UgdG8gdHJhbnNmb3JtIGFuZCByZXR1cm5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWR1Y2VGdW5jdGlvbiAtIHRoaXMgZnVuY3Rpb24gYWNjZXB0cyBtYW55IChhcnJheSBvZiBtYXAgb3V0cHV0cykgYW5kIHJldHVybnMgc2luZ2xlIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIG91dHB1dCBvZiB5b3VyIHJlZHVjZUZ1bmN0aW9uXG4gICAgICovXG4gICAgbWFwUmVkdWNlKG1hcEZ1bmN0aW9uLCByZWR1Y2VGdW5jdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZUZ1bmN0aW9uKHRoaXMuZGF0YSgpLm1hcChtYXBGdW5jdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3BhY2thZ2VzL2xva2kvc3JjL3JhbmdlZF9pbmRleGVzLnRzICsgMSBtb2R1bGVzXG52YXIgcmFuZ2VkX2luZGV4ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vcGFja2FnZXMvY29tbW9uL3BsdWdpbi50c1xudmFyIGNvbW1vbl9wbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2xva2kvc3JjL2NvbGxlY3Rpb24udHNcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29sbGVjdGlvbl9Db2xsZWN0aW9uOyB9KTtcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBhdmVyYWdlKGFycmF5KSB7XG4gICAgcmV0dXJuIChhcnJheS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSkgLyBhcnJheS5sZW5ndGg7XG59XG5mdW5jdGlvbiBzdGFuZGFyZERldmlhdGlvbih2YWx1ZXMpIHtcbiAgICBjb25zdCBhdmcgPSBhdmVyYWdlKHZhbHVlcyk7XG4gICAgY29uc3Qgc3F1YXJlRGlmZnMgPSB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBkaWZmID0gdmFsdWUgLSBhdmc7XG4gICAgICAgIHJldHVybiBkaWZmICogZGlmZjtcbiAgICB9KTtcbiAgICBjb25zdCBhdmdTcXVhcmVEaWZmID0gYXZlcmFnZShzcXVhcmVEaWZmcyk7XG4gICAgcmV0dXJuIE1hdGguc3FydChhdmdTcXVhcmVEaWZmKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB2YWx1ZSBvZiBhIG5lc3RlZCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcyBpZiB0aGUgbmVzdGVkIHByb3BlcnR5IGlzIGFjcm9zcyBjaGlsZCBhcnJheXMuXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aCAtIHRoZSBwYXRoIG9mIHRoZSBuZXN0ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7YW55W119IGFycmF5IC0gdGhlIHJlc3VsdCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHBhdGhJZHggLSB0aGUgY3VycmVudCBwYXRoIGlkeFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbmVzdGVkIHByb3BlcnR5IGlzIGFjcm9zcyBjaGlsZCBhcnJheXMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBnZXROZXN0ZWRQcm9wZXJ0eVZhbHVlKG9iaiwgcGF0aCwgYXJyYXksIHBhdGhJZHggPSAwKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhdGhJZHggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgICBhcnJheS5wdXNoKG9ialtwYXRoW3BhdGhJZHhdXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY3VyciA9IG9ialtwYXRoW3BhdGhJZHhdXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdldE5lc3RlZFByb3BlcnR5VmFsdWUoY3VycltpXSwgcGF0aCwgYXJyYXksIHBhdGhJZHggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXROZXN0ZWRQcm9wZXJ0eVZhbHVlKGN1cnIsIHBhdGgsIGFycmF5LCBwYXRoSWR4ICsgMSk7XG4gICAgfVxufVxuLyoqXG4gKiBDb2xsZWN0aW9uIGNsYXNzIHRoYXQgaGFuZGxlcyBkb2N1bWVudHMgb2Ygc2FtZSB0eXBlXG4gKiBAZXh0ZW5kcyBMb2tpRXZlbnRFbWl0dGVyXG4gKiBAcGFyYW0gPFREYXRhPiAtIHRoZSBkYXRhIHR5cGVcbiAqIEBwYXJhbSA8VE5lc3RlZD4gLSBuZXN0ZWQgcHJvcGVydGllcyBvZiBkYXRhIHR5cGVcbiAqL1xuY2xhc3MgY29sbGVjdGlvbl9Db2xsZWN0aW9uIGV4dGVuZHMgZXZlbnRfZW1pdHRlcltcImFcIiAvKiBMb2tpRXZlbnRFbWl0dGVyICovXSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBjb2xsZWN0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0geyhvYmplY3QpfSBbb3B0aW9ucz17fV0gLSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMudW5pcXVlPVtdXSAtIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRvIGRlZmluZSB1bmlxdWUgY29uc3RyYWludHMgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuZXhhY3Q9W11dIC0gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgdG8gZGVmaW5lIGV4YWN0IGNvbnN0cmFpbnRzIGZvclxuICAgICAqIEBwYXJhbSB7UmFuZ2VkSW5kZXhPcHRpb25zfSBbb3B0aW9ucy5yYW5nZWRJbmRleGVzXSAtIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciByYW5nZWQgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXN5bmNMaXN0ZW5lcnM9ZmFsc2VdIC0gd2hldGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQgYXN5bmNocm9ub3VzbHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRpc2FibGVNZXRhPWZhbHNlXSAtIHNldCB0byB0cnVlIHRvIGRpc2FibGUgbWV0YSBwcm9wZXJ0eSBvbiBkb2N1bWVudHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRpc2FibGVDaGFuZ2VzQXBpPXRydWVdIC0gc2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBDaGFuZ2VzIEFQSVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZURlbHRhQ2hhbmdlc0FwaT10cnVlXSAtIHNldCB0byBmYWxzZSB0byBlbmFibGUgRGVsdGEgQ2hhbmdlcyBBUEkgKHJlcXVpcmVzIENoYW5nZXMgQVBJLCBmb3JjZXMgY2xvbmluZylcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb25lPWZhbHNlXSAtIHNwZWNpZnkgd2hldGhlciBpbnNlcnRzIGFuZCBxdWVyaWVzIGNsb25lIHRvL2Zyb20gdXNlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VyaWFsaXphYmxlSW5kZXhlcz10cnVlXSAtIGNvbnZlcnRzIGRhdGUgdmFsdWVzIG9uIGJpbmFyeSBpbmRleGVkIHByb3BlcnR5IHZhbHVlcyBhcmUgc2VyaWFsaXphYmxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsb25lTWV0aG9kPVwiZGVlcFwiXSAtIHRoZSBjbG9uZSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHJhbnNhY3Rpb25hbD1mYWxzZV0gLSA/XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bD1dIC0gYWdlIG9mIGRvY3VtZW50IChpbiBtcy4pIGJlZm9yZSBkb2N1bWVudCBpcyBjb25zaWRlcmVkIGFnZWQvc3RhbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bEludGVydmFsPV0gLSB0aW1lIGludGVydmFsIGZvciBjbGVhcmluZyBvdXQgJ2FnZWQnIGRvY3VtZW50czsgbm90IHNldCBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVuaW5kZXhlZFNvcnRDb21wYXJhdG9yPVwianNcIl0gXCJqc1wiLCBcImFic3RyYWN0XCIsIFwiYWJzdHJhY3QtZGF0ZVwiLCBcImxva2lcIiBvciBvdGhlciByZWdpc3RlcmVkIGNvbXBhcmF0b3IgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0TG9raU9wZXJhdG9yUGFja2FnZT1cImpzXCJdIFwianNcIiwgXCJsb2tpXCIsIFwiY29tcGFyYXRvclwiIChvciB1c2VyIGRlZmluZWQpIHF1ZXJ5IG9wcyBwYWNrYWdlXG4gICAgICogQHBhcmFtIHtGdWxsVGV4dFNlYXJjaC5GaWVsZE9wdGlvbnN9IFtvcHRpb25zLmZ1bGxUZXh0U2VhcmNoPV0gLSB0aGUgZnVsbC10ZXh0IHNlYXJjaCBvcHRpb25zXG4gICAgICogQHNlZSB7QGxpbmsgTG9raSNhZGRDb2xsZWN0aW9ufSBmb3Igbm9ybWFsIGNyZWF0aW9uIG9mIGNvbGxlY3Rpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHRoZSBkYXRhIGhlbGQgYnkgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgICAgICAvLyBpbmRleCBvZiBpZFxuICAgICAgICB0aGlzLl9pZEluZGV4ID0gW107XG4gICAgICAgIC8vIHVzZXIgZGVmaW5lZCBpbmRleGVzXG4gICAgICAgIHRoaXMuX3JhbmdlZEluZGV4ZXMgPSB7fTtcbiAgICAgICAgLy8gbG9raSBvYmogbWFwXG4gICAgICAgIHRoaXMuX2xva2ltYXAgPSB7fTtcbiAgICAgICAgLy8gZGVmYXVsdCBjb21wYXJhdG9yIG5hbWUgdG8gdXNlIGZvciB1bmluZGV4ZWQgc29ydGluZ1xuICAgICAgICB0aGlzLl91bmluZGV4ZWRTb3J0Q29tcGFyYXRvciA9IFwianNcIjtcbiAgICAgICAgLy8gZGVmYXVsdCBMb2tpT3BlcmF0b3JQYWNrYWdlICgnZGVmYXVsdCcgdXNlcyBmYXN0ZXN0ICdqYXZhc2NyaXB0JyBjb21wYXJpc29ucylcbiAgICAgICAgdGhpcy5fZGVmYXVsdExva2lPcGVyYXRvclBhY2thZ2UgPSBcImpzXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlxdWUgY29uc3RyYWludHMgY29udGFpbiBkdXBsaWNhdGUgb2JqZWN0IHJlZmVyZW5jZXMsIHNvIHRoZXkgYXJlIG5vdCBwZXJzaXN0ZWQuXG4gICAgICAgICAqIFdlIHdpbGwga2VlcCB0cmFjayBvZiBwcm9wZXJ0aWVzIHdoaWNoIGhhdmUgdW5pcXVlIGNvbnN0cmFpbnRzIGFwcGxpZWQgaGVyZSwgYW5kIHJlZ2VuZXJhdGUgb24gbG9hZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0geyB1bmlxdWU6IHt9IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2Zvcm1zIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBmcmVxdWVudGx5IHVzZWQgcXVlcnkgY2hhaW5zIGFzIGEgc2VyaWVzIG9mIHN0ZXBzIHdoaWNoIGl0c2VsZiBjYW4gYmUgc3RvcmVkIGFsb25nXG4gICAgICAgICAqIHdpdGggdGhlIGRhdGFiYXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4gYXV0b3NhdmUgc2NlbmFyaW9zIHdlIHdpbGwgdXNlIGNvbGxlY3Rpb24gbGV2ZWwgZGlydHkgZmxhZ3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgc2F2ZSBpcyBuZWVkZWQuXG4gICAgICAgICAqIGN1cnJlbnRseSwgaWYgYW55IGNvbGxlY3Rpb24gaXMgZGlydHkgd2Ugd2lsbCBhdXRvc2F2ZSB0aGUgd2hvbGUgZGF0YWJhc2UgaWYgYXV0b3NhdmUgaXMgY29uZmlndXJlZC5cbiAgICAgICAgICogRGVmYXVsdGluZyB0byB0cnVlIHNpbmNlIHRoaXMgaXMgY2FsbGVkIGZyb20gYWRkQ29sbGVjdGlvbiBhbmQgYWRkaW5nIGEgY29sbGVjdGlvbiBzaG91bGQgdHJpZ2dlciBzYXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICAvLyBwcml2YXRlIGhvbGRlciBmb3IgY2FjaGVkIGRhdGFcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgcGF0aCBvZiB1c2VkIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVzdGVkUHJvcGVydGllcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uIHRvIGFjdGl2YXRlIGEgY2xlYW5lciBkYWVtb24gLSBjbGVhcnMgXCJhZ2VkXCIgZG9jdW1lbnRzIGF0IHNldCBpbnRlcnZhbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90dGwgPSB7XG4gICAgICAgICAgICBhZ2U6IG51bGwsXG4gICAgICAgICAgICB0dGxJbnRlcnZhbDogbnVsbCxcbiAgICAgICAgICAgIGRhZW1vbjogbnVsbFxuICAgICAgICB9O1xuICAgICAgICAvLyBjdXJyZW50TWF4SWQgLSBjaGFuZ2UgbWFudWFsbHkgYXQgeW91ciBvd24gcGVyaWwhXG4gICAgICAgIHRoaXMuX21heElkID0gMDtcbiAgICAgICAgdGhpcy5fZHluYW1pY1ZpZXdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIGFyZSB0cmFja2VkIGJ5IGNvbGxlY3Rpb24gYW5kIGFnZ3JlZ2F0ZWQgYnkgdGhlIGRiLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2hhbmdlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogc3RhZ2VzOiBhIG1hcCBvZiB1bmlxdWVseSBpZGVudGlmaWVkICdzdGFnZXMnLCB3aGljaCBob2xkIGNvcGllcyBvZiBvYmplY3RzIHRvIGJlXG4gICAgICAgICAqIG1hbmlwdWxhdGVkIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBkYXRhIGluIHRoZSBvcmlnaW5hbCBjb2xsZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGFnZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tbWl0TG9nID0gW107XG4gICAgICAgIC8vIENvbnNpc3RlbmN5IGNoZWNrcy5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNhYmxlTWV0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZUNoYW5nZXNBcGkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzYWJsZU1ldGEgb3B0aW9uIGNhbm5vdCBiZSBwYXNzZWQgYXMgdHJ1ZSB3aGVuIGRpc2FibGVDaGFuZ2VzQXBpIGlzIHBhc3NlZCBhcyBmYWxzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVEZWx0YUNoYW5nZXNBcGkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzYWJsZU1ldGEgb3B0aW9uIGNhbm5vdCBiZSBwYXNzZWQgYXMgdHJ1ZSB3aGVuIGRpc2FibGVEZWx0YUNoYW5nZXNBcGkgaXMgcGFzc2VkIGFzIGZhbHNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnR0bCA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLnR0bCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNhYmxlTWV0YSBvcHRpb24gY2Fubm90IGJlIHBhc3NlZCBhcyB0cnVlIHdoZW4gdHRsIGlzIGVuYWJsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLyogT1BUSU9OUyAqL1xuICAgICAgICB0aGlzLl91bmluZGV4ZWRTb3J0Q29tcGFyYXRvciA9IG9wdGlvbnMudW5pbmRleGVkU29ydENvbXBhcmF0b3IgfHwgXCJqc1wiO1xuICAgICAgICB0aGlzLl9kZWZhdWx0TG9raU9wZXJhdG9yUGFja2FnZSA9IG9wdGlvbnMuZGVmYXVsdExva2lPcGVyYXRvclBhY2thZ2UgfHwgXCJqc1wiO1xuICAgICAgICAvLyBleGFjdCBtYXRjaCBhbmQgdW5pcXVlIGNvbnN0cmFpbnRzXG4gICAgICAgIGlmIChvcHRpb25zLnVuaXF1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy51bmlxdWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51bmlxdWUgPSBbb3B0aW9ucy51bmlxdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy51bmlxdWUuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzLnVuaXF1ZVtwcm9wXSA9IG5ldyBVbmlxdWVJbmRleChwcm9wKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZ1bGwgdGV4dCBzZWFyY2hcbiAgICAgICAgaWYgKGNvbW1vbl9wbHVnaW5bXCJhXCIgLyogUExVR0lOUyAqL11bXCJGdWxsVGV4dFNlYXJjaFwiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxsVGV4dFNlYXJjaCA9IG9wdGlvbnMuZnVsbFRleHRTZWFyY2ggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbmV3IChjb21tb25fcGx1Z2luW1wiYVwiIC8qIFBMVUdJTlMgKi9dW1wiRnVsbFRleHRTZWFyY2hcIl0pKG9wdGlvbnMuZnVsbFRleHRTZWFyY2gpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxUZXh0U2VhcmNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyAuXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uYWwgPSBvcHRpb25zLnRyYW5zYWN0aW9uYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudHJhbnNhY3Rpb25hbCA6IGZhbHNlO1xuICAgICAgICAvLyAuXG4gICAgICAgIHRoaXMuX2Nsb25lT2JqZWN0cyA9IG9wdGlvbnMuY2xvbmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvbmUgOiBmYWxzZTtcbiAgICAgICAgLy8gLlxuICAgICAgICB0aGlzLl9hc3luY0xpc3RlbmVycyA9IG9wdGlvbnMuYXN5bmNMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXN5bmNMaXN0ZW5lcnMgOiBmYWxzZTtcbiAgICAgICAgLy8gLlxuICAgICAgICB0aGlzLl9kaXNhYmxlTWV0YSA9IG9wdGlvbnMuZGlzYWJsZU1ldGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGlzYWJsZU1ldGEgOiBmYWxzZTtcbiAgICAgICAgLy8gLlxuICAgICAgICB0aGlzLl9kaXNhYmxlQ2hhbmdlc0FwaSA9IG9wdGlvbnMuZGlzYWJsZUNoYW5nZXNBcGkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGlzYWJsZUNoYW5nZXNBcGkgOiB0cnVlO1xuICAgICAgICAvLyAuXG4gICAgICAgIHRoaXMuX2Rpc2FibGVEZWx0YUNoYW5nZXNBcGkgPSBvcHRpb25zLmRpc2FibGVEZWx0YUNoYW5nZXNBcGkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGlzYWJsZURlbHRhQ2hhbmdlc0FwaSA6IHRydWU7XG4gICAgICAgIC8vIC5cbiAgICAgICAgdGhpcy5fY2xvbmVNZXRob2QgPSBvcHRpb25zLmNsb25lTWV0aG9kICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb25lTWV0aG9kIDogXCJkZWVwXCI7XG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlQ2hhbmdlc0FwaSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZURlbHRhQ2hhbmdlc0FwaSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLlxuICAgICAgICB0aGlzLl9zZXJpYWxpemFibGVJbmRleGVzID0gb3B0aW9ucy5zZXJpYWxpemFibGVJbmRleGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNlcmlhbGl6YWJsZUluZGV4ZXMgOiB0cnVlO1xuICAgICAgICAvLyAuXG4gICAgICAgIGlmIChvcHRpb25zLm5lc3RlZFByb3BlcnRpZXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubmVzdGVkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lc3RlZFByb3BlcnR5ID0gb3B0aW9ucy5uZXN0ZWRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdGVkUHJvcGVydHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVzdGVkUHJvcGVydGllcy5wdXNoKHsgbmFtZTogbmVzdGVkUHJvcGVydHksIHBhdGg6IG5lc3RlZFByb3BlcnR5LnNwbGl0KFwiLlwiKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25lc3RlZFByb3BlcnRpZXMucHVzaChuZXN0ZWRQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VFRMKG9wdGlvbnMudHRsIHx8IC0xLCBvcHRpb25zLnR0bEludGVydmFsKTtcbiAgICAgICAgLy8gZXZlbnRzXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgICAgICAgIFwiaW5zZXJ0XCI6IFtdLFxuICAgICAgICAgICAgXCJ1cGRhdGVcIjogW10sXG4gICAgICAgICAgICBcInByZS1pbnNlcnRcIjogW10sXG4gICAgICAgICAgICBcInByZS11cGRhdGVcIjogW10sXG4gICAgICAgICAgICBcImNsb3NlXCI6IFtdLFxuICAgICAgICAgICAgXCJmbHVzaGJ1ZmZlclwiOiBbXSxcbiAgICAgICAgICAgIFwiZXJyb3JcIjogW10sXG4gICAgICAgICAgICBcImRlbGV0ZVwiOiBbXSxcbiAgICAgICAgICAgIFwid2FybmluZ1wiOiBbXVxuICAgICAgICB9O1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBpZCBpbmRleFxuICAgICAgICB0aGlzLl9lbnN1cmVJZCgpO1xuICAgICAgICBsZXQgcmFuZ2VkSW5kZXhlcyA9IG9wdGlvbnMucmFuZ2VkSW5kZXhlcyB8fCB7fTtcbiAgICAgICAgZm9yIChsZXQgcmkgaW4gcmFuZ2VkSW5kZXhlcykge1xuICAgICAgICAgICAgLy8gVG9kbzogYW55IHdheSB0byB0eXBlIGFubm90YXRlIHRoaXMgYXMgdHlwZXNhZmUgZ2VuZXJpYz9cbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUmFuZ2VkSW5kZXgocmksIHJhbmdlZEluZGV4ZXNbcmldLmluZGV4VHlwZU5hbWUsIHJhbmdlZEluZGV4ZXNbcmldLmNvbXBhcmF0b3JOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENoYW5nZXNBcGkodGhpcy5fZGlzYWJsZUNoYW5nZXNBcGksIHRoaXMuX2Rpc2FibGVEZWx0YUNoYW5nZXNBcGkpO1xuICAgICAgICAvLyBmb3IgZGUtc2VyaWFsaXphdGlvbiBwdXJwb3Nlc1xuICAgICAgICB0aGlzLmZsdXNoQ2hhbmdlcygpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB1bmluZGV4ZWRTb3J0Q29tcGFyYXRvcjogdGhpcy5fdW5pbmRleGVkU29ydENvbXBhcmF0b3IsXG4gICAgICAgICAgICBkZWZhdWx0TG9raU9wZXJhdG9yUGFja2FnZTogdGhpcy5fZGVmYXVsdExva2lPcGVyYXRvclBhY2thZ2UsXG4gICAgICAgICAgICBfZHluYW1pY1ZpZXdzOiB0aGlzLl9keW5hbWljVmlld3MsXG4gICAgICAgICAgICB1bmlxdWVOYW1lczogT2JqZWN0LmtleXModGhpcy5fY29uc3RyYWludHMudW5pcXVlKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybXM6IHRoaXMuX3RyYW5zZm9ybXMsXG4gICAgICAgICAgICByYW5nZWRJbmRleGVzOiB0aGlzLl9yYW5nZWRJbmRleGVzLFxuICAgICAgICAgICAgX2RhdGE6IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICBpZEluZGV4OiB0aGlzLl9pZEluZGV4LFxuICAgICAgICAgICAgbWF4SWQ6IHRoaXMuX21heElkLFxuICAgICAgICAgICAgX2RpcnR5OiB0aGlzLl9kaXJ0eSxcbiAgICAgICAgICAgIF9uZXN0ZWRQcm9wZXJ0aWVzOiB0aGlzLl9uZXN0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25hbDogdGhpcy5fdHJhbnNhY3Rpb25hbCxcbiAgICAgICAgICAgIGFzeW5jTGlzdGVuZXJzOiB0aGlzLl9hc3luY0xpc3RlbmVycyxcbiAgICAgICAgICAgIGRpc2FibGVNZXRhOiB0aGlzLl9kaXNhYmxlTWV0YSxcbiAgICAgICAgICAgIGRpc2FibGVDaGFuZ2VzQXBpOiB0aGlzLl9kaXNhYmxlQ2hhbmdlc0FwaSxcbiAgICAgICAgICAgIGRpc2FibGVEZWx0YUNoYW5nZXNBcGk6IHRoaXMuX2Rpc2FibGVEZWx0YUNoYW5nZXNBcGksXG4gICAgICAgICAgICBjbG9uZU9iamVjdHM6IHRoaXMuX2Nsb25lT2JqZWN0cyxcbiAgICAgICAgICAgIGNsb25lTWV0aG9kOiB0aGlzLl9jbG9uZU1ldGhvZCxcbiAgICAgICAgICAgIGNoYW5nZXM6IHRoaXMuX2NoYW5nZXMsXG4gICAgICAgICAgICBfZnVsbFRleHRTZWFyY2g6IHRoaXMuX2Z1bGxUZXh0U2VhcmNoXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTk9iamVjdChvYmosIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gaW5zdGFudGlhdGUgY29sbGVjdGlvbiB3aXRoIG9wdGlvbnMgbmVlZGVkIGJ5IGNvbnN0cnVjdG9yXG4gICAgICAgIGxldCBjb2xsID0gbmV3IGNvbGxlY3Rpb25fQ29sbGVjdGlvbihvYmoubmFtZSwge1xuICAgICAgICAgICAgZGlzYWJsZUNoYW5nZXNBcGk6IG9iai5kaXNhYmxlQ2hhbmdlc0FwaSxcbiAgICAgICAgICAgIGRpc2FibGVEZWx0YUNoYW5nZXNBcGk6IG9iai5kaXNhYmxlRGVsdGFDaGFuZ2VzQXBpLFxuICAgICAgICAgICAgdW5pbmRleGVkU29ydENvbXBhcmF0b3I6IG9iai51bmluZGV4ZWRTb3J0Q29tcGFyYXRvcixcbiAgICAgICAgICAgIGRlZmF1bHRMb2tpT3BlcmF0b3JQYWNrYWdlOiBvYmouZGVmYXVsdExva2lPcGVyYXRvclBhY2thZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbGwuX3RyYW5zYWN0aW9uYWwgPSBvYmoudHJhbnNhY3Rpb25hbDtcbiAgICAgICAgY29sbC5fYXN5bmNMaXN0ZW5lcnMgPSBvYmouYXN5bmNMaXN0ZW5lcnM7XG4gICAgICAgIGNvbGwuX2Rpc2FibGVNZXRhID0gb2JqLmRpc2FibGVNZXRhO1xuICAgICAgICBjb2xsLl9kaXNhYmxlQ2hhbmdlc0FwaSA9IG9iai5kaXNhYmxlQ2hhbmdlc0FwaTtcbiAgICAgICAgY29sbC5fY2xvbmVPYmplY3RzID0gb2JqLmNsb25lT2JqZWN0cztcbiAgICAgICAgY29sbC5fY2xvbmVNZXRob2QgPSBvYmouY2xvbmVNZXRob2QgfHwgXCJkZWVwXCI7XG4gICAgICAgIGNvbGwuX2NoYW5nZXMgPSBvYmouY2hhbmdlcztcbiAgICAgICAgY29sbC5fbmVzdGVkUHJvcGVydGllcyA9IG9iai5fbmVzdGVkUHJvcGVydGllcztcbiAgICAgICAgY29sbC5fcmFuZ2VkSW5kZXhlcyA9IG9iai5yYW5nZWRJbmRleGVzIHx8IHt9O1xuICAgICAgICBjb2xsLl9kaXJ0eSA9IChvcHRpb25zICYmIG9wdGlvbnMucmV0YWluRGlydHlGbGFncyA9PT0gdHJ1ZSkgPyBvYmouX2RpcnR5IDogZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VMb2FkZXIoY29sbCkge1xuICAgICAgICAgICAgY29uc3QgY29sbE9wdGlvbnMgPSBvcHRpb25zW2NvbGwubmFtZV07XG4gICAgICAgICAgICBpZiAoY29sbE9wdGlvbnMucHJvdG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZsYXRlciA9IGNvbGxPcHRpb25zLmluZmxhdGUgfHwgKChzcmMsIGRlc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RbcHJvcF0gPSBzcmNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbE9iaiA9IG5ldyAoY29sbE9wdGlvbnMucHJvdG8pKCk7XG4gICAgICAgICAgICAgICAgICAgIGluZmxhdGVyKGRhdGEsIGNvbGxPYmopO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbE9iajtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbGxPcHRpb25zLmluZmxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9hZCBlYWNoIGVsZW1lbnQgaW5kaXZpZHVhbGx5XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbb2JqLm5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBsb2FkZXIgPSBtYWtlTG9hZGVyKG9iaik7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9iai5fZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbGwuX2RhdGFbal0gPSBjb2xsLl9kZWZpbmVOZXN0ZWRQcm9wZXJ0aWVzKGxvYWRlcihvYmouX2RhdGFbal0pKTtcbiAgICAgICAgICAgICAgICAvLyByZWdlbmVyYXRlIGxva2ltYXBcbiAgICAgICAgICAgICAgICBjb2xsLl9sb2tpbWFwW2NvbGwuX2RhdGFbal0uJGxva2ldID0gY29sbC5fZGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb2JqLl9kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29sbC5fZGF0YVtqXSA9IGNvbGwuX2RlZmluZU5lc3RlZFByb3BlcnRpZXMob2JqLl9kYXRhW2pdKTtcbiAgICAgICAgICAgICAgICAvLyByZWdlbmVyYXRlIGxva2ltYXBcbiAgICAgICAgICAgICAgICBjb2xsLl9sb2tpbWFwW2NvbGwuX2RhdGFbal0uJGxva2ldID0gY29sbC5fZGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2xsLl9tYXhJZCA9IChvYmoubWF4SWQgPT09IHVuZGVmaW5lZCkgPyAwIDogb2JqLm1heElkO1xuICAgICAgICBjb2xsLl9pZEluZGV4ID0gb2JqLmlkSW5kZXg7XG4gICAgICAgIGlmIChvYmoudHJhbnNmb3JtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2xsLl90cmFuc2Zvcm1zID0gb2JqLnRyYW5zZm9ybXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5mbGF0ZSByYW5nZWRpbmRleGVzXG4gICAgICAgIGZvciAobGV0IHJpIGluIG9iai5yYW5nZWRJbmRleGVzKSB7XG4gICAgICAgICAgICAvLyBzaG9ydGN1dCByZWZlcmVuY2UgdG8gc2VyaWFsaXplZCBtZXRhXG4gICAgICAgICAgICBsZXQgc3JpID0gb2JqLnJhbmdlZEluZGV4ZXNbcmldO1xuICAgICAgICAgICAgLy8gbG9va3VwIGluZGV4IGZhY3RvcnkgZnVuY3Rpb24gaW4gbWFwIGJhc2VkIG9uIGluZGV4IHR5cGUgbmFtZVxuICAgICAgICAgICAgbGV0IHJpZiA9IHJhbmdlZF9pbmRleGVzW1wiYVwiIC8qIFJhbmdlZEluZGV4RmFjdG9yeU1hcCAqL11bc3JpLmluZGV4VHlwZU5hbWVdO1xuICAgICAgICAgICAgLy8gbG9va3VwIGNvbXBhcmF0b3IgZnVuY3Rpb24gaW4gbWFwIGJhc2VkIG9uIGNvbXBhcmF0b3IgbmFtZVxuICAgICAgICAgICAgbGV0IHJpY21wID0gY29tcGFyYXRvcnNbXCJhXCIgLyogQ29tcGFyYXRvck1hcCAqL11bc3JpLmNvbXBhcmF0b3JOYW1lXTtcbiAgICAgICAgICAgIC8vIHVzaW5nIGluZGV4IHR5cGUgKGZyb20gbWV0YSksIGluZGV4IGZhY3RvcnkgYW5kIGNvbXBhcmF0b3IuLi4gY3JlYXRlIGluc3RhbmNlIG9mIHJhbmdlZCBpbmRleFxuICAgICAgICAgICAgbGV0IHJpaSA9IHJpZihyaSwgcmljbXApO1xuICAgICAgICAgICAgLy8gbm93IGFzayBuZXcgaW5kZXggaW5zdGFuY2UgdG8gaW5mbGF0ZSBmcm9tIHBsYWluIG9iamVjdFxuICAgICAgICAgICAgcmlpLnJlc3RvcmUoc3JpLmluZGV4KTtcbiAgICAgICAgICAgIC8vIGF0dGFjaCBjbGFzcyBpbnN0YW5jZSB0byBvdXIgY29sbGVjdGlvbidzIHJhbmdlZCBpbmRleCdzIChpbmRleCkgaW5zdGFuY2UgcHJvcGVydHlcbiAgICAgICAgICAgIGNvbGwuX3JhbmdlZEluZGV4ZXNbcmldLmluZGV4ID0gcmlpO1xuICAgICAgICB9XG4gICAgICAgIGNvbGwuX2Vuc3VyZUlkKCk7XG4gICAgICAgIC8vIHJlZ2VuZXJhdGUgdW5pcXVlIGluZGV4ZXNcbiAgICAgICAgaWYgKG9iai51bmlxdWVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9iai51bmlxdWVOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbGwuZW5zdXJlVW5pcXVlSW5kZXgob2JqLnVuaXF1ZU5hbWVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbiBjYXNlIHRoZXkgYXJlIGxvYWRpbmcgYSBkYXRhYmFzZSBjcmVhdGVkIGJlZm9yZSB3ZSBhZGRlZCBkeW5hbWljIHZpZXdzLCBoYW5kbGUgdW5kZWZpbmVkXG4gICAgICAgIGlmIChvYmouX2R5bmFtaWNWaWV3cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZWluZmxhdGUgRHluYW1pY1ZpZXdzIGFuZCBhdHRhY2hlZCBSZXN1bHRTZXRzXG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBvYmouX2R5bmFtaWNWaWV3cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgY29sbC5fZHluYW1pY1ZpZXdzLnB1c2goZHluYW1pY192aWV3X0R5bmFtaWNWaWV3LmZyb21KU09OT2JqZWN0KGNvbGwsIG9iai5fZHluYW1pY1ZpZXdzW2lkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLl9mdWxsVGV4dFNlYXJjaCkge1xuICAgICAgICAgICAgY29sbC5fZnVsbFRleHRTZWFyY2ggPSBjb21tb25fcGx1Z2luW1wiYVwiIC8qIFBMVUdJTlMgKi9dW1wiRnVsbFRleHRTZWFyY2hcIl0uZnJvbUpTT05PYmplY3Qob2JqLl9mdWxsVGV4dFNlYXJjaCwgb3B0aW9ucy5mdWxsVGV4dFNlYXJjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuYW1lZCBjb2xsZWN0aW9uIHRyYW5zZm9ybSB0byB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge2FycmF5fSB0cmFuc2Zvcm0gLSBhbiBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbiAnc3RlcCcgb2JqZWN0cyB0byBzYXZlIGludG8gdGhlIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBhZGRUcmFuc2Zvcm0obmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm1zW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImEgdHJhbnNmb3JtIGJ5IHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1zW25hbWVdID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBuYW1lZCB0cmFuc2Zvcm0gZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIHRyYW5zZm9ybSB0byBsb29rdXAuXG4gICAgICovXG4gICAgZ2V0VHJhbnNmb3JtKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybXNbbmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBuYW1lZCBjb2xsZWN0aW9uIHRyYW5zZm9ybSB0byB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdHJhbnNmb3JtIC0gYSB0cmFuc2Zvcm1hdGlvbiBvYmplY3QgdG8gc2F2ZSBpbnRvIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBzZXRUcmFuc2Zvcm0obmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybXNbbmFtZV0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBuYW1lZCBjb2xsZWN0aW9uIHRyYW5zZm9ybSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIGNvbGxlY3Rpb24gdHJhbnNmb3JtIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIHJlbW92ZVRyYW5zZm9ybShuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc2Zvcm1zW25hbWVdO1xuICAgIH1cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgIHwgVFRMICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgc2V0VFRMKGFnZSwgaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKGFnZSA8IDApIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdHRsLmRhZW1vbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90dGwuYWdlID0gYWdlO1xuICAgICAgICAgICAgdGhpcy5fdHRsLnR0bEludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLl90dGwuZGFlbW9uID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9SZW1vdmUgPSB0aGlzLmNoYWluKCkud2hlcmUoKG1lbWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBtZW1iZXIubWV0YS51cGRhdGVkIHx8IG1lbWJlci5tZXRhLmNyZWF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBub3cgLSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90dGwuYWdlIDwgZGlmZjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0b1JlbW92ZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgIHwgSU5ERVhJTkcgICAgICAgICAgICAgICAgICAgfFxuICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcm93IGZpbHRlciB0aGF0IGNvdmVycyBhbGwgZG9jdW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIF9wcmVwYXJlRnVsbERvY0luZGV4KCkge1xuICAgICAgICBjb25zdCBpbmRleGVzID0gbmV3IEFycmF5KHRoaXMuX2RhdGEubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleGVzW2ldID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHJhbmdlZEluZGV4IG9mIGEgZmllbGQuXG4gICAgICogQHBhcmFtIGZpZWxkXG4gICAgICogQHBhcmFtIGluZGV4VHlwZU5hbWVcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvck5hbWVcbiAgICAgKi9cbiAgICBlbnN1cmVJbmRleChmaWVsZCwgaW5kZXhUeXBlTmFtZSwgY29tcGFyYXRvck5hbWUpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSYW5nZWRJbmRleChmaWVsZCwgaW5kZXhUeXBlTmFtZSwgY29tcGFyYXRvck5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgcmFuZ2VkSW5kZXggb2YgYSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gZmllbGQgUHJvcGVydHkgdG8gY3JlYXRlIGFuIGluZGV4IG9uIChuZWVkIHRvIGxvb2sgaW50byBjb250cmFpbmluZyBvbiBrZXlvZiBUKVxuICAgICAqIEBwYXJhbSBpbmRleFR5cGVOYW1lIE5hbWUgb2YgSW5kZXhUeXBlIGZhY3Rvcnkgd2l0aGluIChnbG9iYWw/KSBoYXNobWFwIHRvIGNyZWF0ZSBJUmFuZ2VkSW5kZXggZnJvbVxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yTmFtZSBOYW1lIG9mIENvbXBhcmF0b3Igd2l0aGluIChnbG9iYWw/KSBoYXNobWFwXG4gICAgICovXG4gICAgZW5zdXJlUmFuZ2VkSW5kZXgoZmllbGQsIGluZGV4VHlwZU5hbWUsIGNvbXBhcmF0b3JOYW1lKSB7XG4gICAgICAgIGluZGV4VHlwZU5hbWUgPSBpbmRleFR5cGVOYW1lIHx8IFwiYXZsXCI7XG4gICAgICAgIGNvbXBhcmF0b3JOYW1lID0gY29tcGFyYXRvck5hbWUgfHwgXCJsb2tpXCI7XG4gICAgICAgIGlmICghcmFuZ2VkX2luZGV4ZXNbXCJhXCIgLyogUmFuZ2VkSW5kZXhGYWN0b3J5TWFwICovXVtpbmRleFR5cGVOYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5zdXJlUmFuZ2VkSW5kZXg6IFVua25vd24gcmFuZ2UgaW5kZXggdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBhcmF0b3JzW1wiYVwiIC8qIENvbXBhcmF0b3JNYXAgKi9dW2NvbXBhcmF0b3JOYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5zdXJlUmFuZ2VkSW5kZXg6IFVua25vd24gY29tcGFyYXRvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmlmID0gcmFuZ2VkX2luZGV4ZXNbXCJhXCIgLyogUmFuZ2VkSW5kZXhGYWN0b3J5TWFwICovXVtpbmRleFR5cGVOYW1lXTtcbiAgICAgICAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yc1tcImFcIiAvKiBDb21wYXJhdG9yTWFwICovXVtjb21wYXJhdG9yTmFtZV07XG4gICAgICAgIHRoaXMuX3JhbmdlZEluZGV4ZXNbZmllbGRdID0ge1xuICAgICAgICAgICAgaW5kZXg6IHJpZihmaWVsZCwgY29tcGFyYXRvciksXG4gICAgICAgICAgICBpbmRleFR5cGVOYW1lOiBpbmRleFR5cGVOYW1lLFxuICAgICAgICAgICAgY29tcGFyYXRvck5hbWU6IGNvbXBhcmF0b3JOYW1lXG4gICAgICAgIH07XG4gICAgICAgIGxldCByaWkgPSB0aGlzLl9yYW5nZWRJbmRleGVzW2ZpZWxkXS5pbmRleDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaWkuaW5zZXJ0KHRoaXMuX2RhdGFbaV0uJGxva2ksIHRoaXMuX2RhdGFbaV1bZmllbGRdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnN1cmVVbmlxdWVJbmRleChmaWVsZCkge1xuICAgICAgICBsZXQgaW5kZXggPSBuZXcgVW5pcXVlSW5kZXgoZmllbGQpO1xuICAgICAgICAvLyBpZiBpbmRleCBhbHJlYWR5IGV4aXN0ZWQsIChyZSlsb2FkaW5nIGl0IHdpbGwgbGlrZWx5IGNhdXNlIGNvbGxpc2lvbnMsIHJlYnVpbGQgYWx3YXlzXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzLnVuaXF1ZVtmaWVsZF0gPSBpbmRleDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleC5zZXQodGhpcy5fZGF0YVtpXS4kbG9raSwgdGhpcy5fZGF0YVtpXVtmaWVsZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2tseSBkZXRlcm1pbmUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiBjb2xsZWN0aW9uIChvciBxdWVyeSlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnkgLSAob3B0aW9uYWwpIHF1ZXJ5IG9iamVjdCB0byBjb3VudCByZXN1bHRzIG9mXG4gICAgICogQHJldHVybnMge251bWJlcn0gbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqL1xuICAgIGNvdW50KHF1ZXJ5KSB7XG4gICAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbigpLmZpbmQocXVlcnkpLl9maWx0ZXJlZFJvd3MubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWJ1aWxkIGlkSW5kZXhcbiAgICAgKi9cbiAgICBfZW5zdXJlSWQoKSB7XG4gICAgICAgIHRoaXMuX2lkSW5kZXggPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9pZEluZGV4LnB1c2godGhpcy5fZGF0YVtpXS4kbG9raSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgZHluYW1pYyB2aWV3IHRvIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIGR5bmFtaWMgdmlldyB0byBhZGRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIChvcHRpb25hbCkgb3B0aW9ucyB0byBjb25maWd1cmUgZHluYW1pYyB2aWV3IHdpdGhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcnNpc3RlbnQ9ZmFsc2VdIC0gaW5kaWNhdGVzIGlmIHZpZXcgaXMgdG8gbWFpbiBpbnRlcm5hbCByZXN1bHRzIGFycmF5IGluICdyZXN1bHRkYXRhJ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3J0UHJpb3JpdHk9U29ydFByaW9yaXR5LlBBU1NJVkVdIC0gdGhlIHNvcnQgcHJpb3JpdHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5taW5SZWJ1aWxkSW50ZXJ2YWwgLSBtaW5pbXVtIHJlYnVpbGQgaW50ZXJ2YWwgKG5lZWQgY2xhcmlmaWNhdGlvbiB0byBkb2NzIGhlcmUpXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSByZWZlcmVuY2UgdG8gdGhlIGR5bmFtaWMgdmlldyBhZGRlZFxuICAgICAqKi9cbiAgICBhZGREeW5hbWljVmlldyhuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGR2ID0gbmV3IGR5bmFtaWNfdmlld19EeW5hbWljVmlldyh0aGlzLCBuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZHluYW1pY1ZpZXdzLnB1c2goZHYpO1xuICAgICAgICByZXR1cm4gZHY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGR5bmFtaWMgdmlldyBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIGR5bmFtaWMgdmlldyB0byByZW1vdmVcbiAgICAgKiovXG4gICAgcmVtb3ZlRHluYW1pY1ZpZXcobmFtZSkge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9keW5hbWljVmlld3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2R5bmFtaWNWaWV3c1tpZHhdLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljVmlld3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9vayB1cCBkeW5hbWljIHZpZXcgcmVmZXJlbmNlIGZyb20gd2l0aGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIGR5bmFtaWMgdmlldyB0byByZXRyaWV2ZSByZWZlcmVuY2Ugb2ZcbiAgICAgKiBAcmV0dXJucyB7RHluYW1pY1ZpZXd9IEEgcmVmZXJlbmNlIHRvIHRoZSBkeW5hbWljIHZpZXcgd2l0aCB0aGF0IG5hbWVcbiAgICAgKiovXG4gICAgZ2V0RHluYW1pY1ZpZXcobmFtZSkge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9keW5hbWljVmlld3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2R5bmFtaWNWaWV3c1tpZHhdLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZHluYW1pY1ZpZXdzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSAnbW9uZ28tbGlrZScgZmluZCBxdWVyeSBvYmplY3QgYW5kIHBhc3NlcyBhbGwgcmVzdWx0cyB0byBhbiB1cGRhdGUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZpbHRlck9iamVjdCAtIHRoZSAnbW9uZ28tbGlrZScgcXVlcnkgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gdXBkYXRlRnVuY3Rpb24gLSB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZmluZEFuZFVwZGF0ZShmaWx0ZXJPYmplY3QsIHVwZGF0ZUZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2hhaW4oKS5maW5kKGZpbHRlck9iamVjdCkudXBkYXRlKHVwZGF0ZUZ1bmN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhICdtb25nby1saWtlJyBmaW5kIHF1ZXJ5IG9iamVjdCByZW1vdmVzIGFsbCBkb2N1bWVudHMgd2hpY2ggbWF0Y2ggdGhhdCBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZpbHRlck9iamVjdCAtICdtb25nby1saWtlJyBxdWVyeSBvYmplY3RcbiAgICAgKi9cbiAgICBmaW5kQW5kUmVtb3ZlKGZpbHRlck9iamVjdCkge1xuICAgICAgICB0aGlzLmNoYWluKCkuZmluZChmaWx0ZXJPYmplY3QpLnJlbW92ZSgpO1xuICAgIH1cbiAgICBpbnNlcnQoZG9jKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkb2MpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRPbmUoZG9jKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBob2xkZXIgdG8gdGhlIGNsb25lIG9mIHRoZSBvYmplY3QgaW5zZXJ0ZWQgaWYgY29sbGVjdGlvbnMgaXMgc2V0IHRvIGNsb25lIG9iamVjdHNcbiAgICAgICAgbGV0IG9iajtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbWl0KFwicHJlLWluc2VydFwiLCBkb2MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqID0gdGhpcy5pbnNlcnRPbmUoZG9jW2ldLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoZSAnYmF0Y2gnIGxldmVsLCBpZiBjbG9uZSBvcHRpb24gaXMgdHJ1ZSB0aGVuIGVtaXR0ZWQgZG9jcyBhcmUgY2xvbmVzXG4gICAgICAgIHRoaXMuZW1pdChcImluc2VydFwiLCByZXN1bHRzKTtcbiAgICAgICAgLy8gaWYgY2xvbmUgb3B0aW9uIGlzIHNldCwgY2xvbmUgcmV0dXJuIHZhbHVlc1xuICAgICAgICByZXN1bHRzID0gdGhpcy5fY2xvbmVPYmplY3RzID8gY2xvbmUocmVzdWx0cywgdGhpcy5fY2xvbmVNZXRob2QpIDogcmVzdWx0cztcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMubGVuZ3RoID09PSAxID8gcmVzdWx0c1swXSA6IHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzaW5nbGUgb2JqZWN0LCBlbnN1cmVzIGl0IGhhcyBtZXRhIHByb3BlcnRpZXMsIGNsb25lIGl0IGlmIG5lY2Vzc2FyeSwgZXRjLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkb2MgLSB0aGUgZG9jdW1lbnQgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJ1bGtJbnNlcnQgLSBxdWlldCBwcmUtaW5zZXJ0IGFuZCBpbnNlcnQgZXZlbnQgZW1pdHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBkb2N1bWVudCBvciAndW5kZWZpbmVkJyBpZiB0aGVyZSB3YXMgYSBwcm9ibGVtIGluc2VydGluZyBpdFxuICAgICAqL1xuICAgIGluc2VydE9uZShkb2MsIGJ1bGtJbnNlcnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZXJyID0gbnVsbDtcbiAgICAgICAgbGV0IHJldHVybk9iajtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2MgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBUeXBlRXJyb3IoXCJEb2N1bWVudCBuZWVkcyB0byBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jID09PSBudWxsKSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGNhbm5vdCBiZSBudWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY29uZmlndXJlZCB0byBjbG9uZSwgZG8gc28gbm93Li4uIG90aGVyd2lzZSBqdXN0IHVzZSBzYW1lIG9iaiByZWZlcmVuY2VcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5fZGVmaW5lTmVzdGVkUHJvcGVydGllcyh0aGlzLl9jbG9uZU9iamVjdHMgPyBjbG9uZShkb2MsIHRoaXMuX2Nsb25lTWV0aG9kKSA6IGRvYyk7XG4gICAgICAgIGlmICghdGhpcy5fZGlzYWJsZU1ldGEgJiYgb2JqLm1ldGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLm1ldGEgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICByZXZpc2lvbjogMCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGJvdGggJ3ByZS1pbnNlcnQnIGFuZCAnaW5zZXJ0JyBldmVudHMgYXJlIHBhc3NlZCBpbnRlcm5hbCBkYXRhIHJlZmVyZW5jZSBldmVuIHdoZW4gY2xvbmluZ1xuICAgICAgICAvLyBpbnNlcnQgbmVlZHMgaW50ZXJuYWwgcmVmZXJlbmNlIGJlY2F1c2UgdGhhdCBpcyB3aGVyZSBsb2tpIGl0c2VsZiBsaXN0ZW5zIHRvIGFkZCBtZXRhXG4gICAgICAgIGlmICghYnVsa0luc2VydCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicHJlLWluc2VydFwiLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fYWRkKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIG1ldGEgYW5kIHN0b3JlIGNoYW5nZXMgaWYgQ2hhbmdlc0FQSSBpcyBlbmFibGVkXG4gICAgICAgIC8vIChtb3ZlZCBmcm9tIFwiaW5zZXJ0XCIgZXZlbnQgbGlzdGVuZXIgdG8gYWxsb3cgaW50ZXJuYWwgcmVmZXJlbmNlIHRvIGJlIHVzZWQpXG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlQ2hhbmdlc0FwaSkge1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0TWV0YShvYmopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0TWV0YVdpdGhDaGFuZ2Uob2JqKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjbG9uaW5nIGlzIGVuYWJsZWQsIGVtaXQgaW5zZXJ0IGV2ZW50IHdpdGggY2xvbmUgb2YgbmV3IG9iamVjdFxuICAgICAgICByZXR1cm5PYmogPSB0aGlzLl9jbG9uZU9iamVjdHMgPyBjbG9uZShvYmosIHRoaXMuX2Nsb25lTWV0aG9kKSA6IG9iajtcbiAgICAgICAgaWYgKCFidWxrSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJpbnNlcnRcIiwgcmV0dXJuT2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuT2JqO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZlcnMgbmVzdGVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IHRvIHRoZSByb290IG9mIGl0LlxuICAgICAqIEBwYXJhbSB7VH0gZGF0YSAtIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7VCAmIFROZXN0ZWR9IHRoZSBvYmplY3Qgd2l0aCBuZXN0ZWQgcHJvcGVydGllc1xuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfZGVmaW5lTmVzdGVkUHJvcGVydGllcyhkYXRhKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmVzdGVkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX25lc3RlZFByb3BlcnRpZXNbaV0ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLl9uZXN0ZWRQcm9wZXJ0aWVzW2ldLnBhdGg7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgbmVzdGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TmVzdGVkUHJvcGVydHlWYWx1ZSh0aGlzLCBwYXRoLCBhcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIG9mIHRoZSBuZXN0ZWQgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAxKS5yZWR1Y2UoKG9iaiwgcGFydCkgPT4gKG9iaiAmJiBvYmpbcGFydF0pID8gb2JqW3BhcnRdIDogbnVsbCwgdGhpcylbcGF0aFtwYXRoLmxlbmd0aCAtIDFdXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlSW5kaWNlcz1mYWxzZV0gLSByZW1vdmUgaW5kaWNlc1xuICAgICAqL1xuICAgIGNsZWFyKHsgcmVtb3ZlSW5kaWNlczogcmVtb3ZlSW5kaWNlcyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICAgIHRoaXMuX2lkSW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWF4SWQgPSAwO1xuICAgICAgICB0aGlzLl9keW5hbWljVmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICAvLyBpZiByZW1vdmluZyBpbmRpY2VzIGVudGlyZWx5XG4gICAgICAgIGlmIChyZW1vdmVJbmRpY2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZWRJbmRleGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IHtcbiAgICAgICAgICAgICAgICB1bmlxdWU6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIGluZGljZXMgYnV0IGxlYXZlIGRlZmluaXRpb25zIGluIHBsYWNlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmUtaW5zdGFuY2UgcmFuZ2VkIGluZGV4ZXNcbiAgICAgICAgICAgIGZvciAobGV0IHJpIGluIHRoaXMuX3JhbmdlZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVJhbmdlZEluZGV4KHJpLCB0aGlzLl9yYW5nZWRJbmRleGVzW3JpXS5pbmRleFR5cGVOYW1lLCB0aGlzLl9yYW5nZWRJbmRleGVzW3JpXS5jb21wYXJhdG9yTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBlbnRpcmUgdW5pcXVlIGluZGljZXMgZGVmaW5pdGlvblxuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jb25zdHJhaW50cy51bmlxdWUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmlxdWVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzLnVuaXF1ZVt1bmlxdWVOYW1lc1tpXV0uY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZnVsbFRleHRTZWFyY2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxUZXh0U2VhcmNoLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBvYmplY3QgYW5kIG5vdGlmaWVzIGNvbGxlY3Rpb24gdGhhdCB0aGUgZG9jdW1lbnQgaGFzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRvYyAtIGRvY3VtZW50IHRvIHVwZGF0ZSB3aXRoaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICB1cGRhdGUoZG9jKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoZG9jW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJpZnkgb2JqZWN0IGlzIGEgcHJvcGVybHkgZm9ybWVkIGRvY3VtZW50LlxuICAgICAgICBpZiAoZG9jLiRsb2tpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgdW5zeW5jZWQgZG9jdW1lbnQuIFBsZWFzZSBzYXZlIHRoZSBkb2N1bWVudCBmaXJzdCBieSB1c2luZyBpbnNlcnQoKSBvciBhZGRNYW55KClcIik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgYXJyID0gdGhpcy5nZXQoZG9jLiRsb2tpLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghYXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIHVwZGF0ZSBhIGRvY3VtZW50IG5vdCBpbiBjb2xsZWN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZiB0byBleGlzdGluZyBvYmpcbiAgICAgICAgICAgIGxldCBvbGRJbnRlcm5hbCA9IGFyclswXTsgLy8gLWludGVybmFsLSBvYmogcmVmXG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBhcnJbMV07IC8vIHBvc2l0aW9uIGluIGRhdGEgYXJyYXlcbiAgICAgICAgICAgIC8vIHJlZiB0byBuZXcgaW50ZXJuYWwgb2JqXG4gICAgICAgICAgICAvLyBpZiBjb25maWd1cmVkIHRvIGNsb25lLCBkbyBzbyBub3cuLi4gb3RoZXJ3aXNlIGp1c3QgdXNlIHNhbWUgb2JqIHJlZmVyZW5jZVxuICAgICAgICAgICAgbGV0IG5ld0ludGVybmFsID0gdGhpcy5fZGVmaW5lTmVzdGVkUHJvcGVydGllcyh0aGlzLl9jbG9uZU9iamVjdHMgfHwgIXRoaXMuX2Rpc2FibGVEZWx0YUNoYW5nZXNBcGkgPyBjbG9uZShkb2MsIHRoaXMuX2Nsb25lTWV0aG9kKSA6IGRvYyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwcmUtdXBkYXRlXCIsIGRvYyk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9jb25zdHJhaW50cy51bmlxdWUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzLnVuaXF1ZVtrZXldLnVwZGF0ZShuZXdJbnRlcm5hbC4kbG9raSwgbmV3SW50ZXJuYWxba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIG9wZXJhdGUgdGhlIHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5fZGF0YVtwb3NpdGlvbl0gPSBuZXdJbnRlcm5hbDtcbiAgICAgICAgICAgIHRoaXMuX2xva2ltYXBbZG9jLiRsb2tpXSA9IG5ld0ludGVybmFsO1xuICAgICAgICAgICAgLy8gbm93IHRoYXQgd2UgY2FuIGVmZmljaWVudGx5IGRldGVybWluZSB0aGUgZGF0YVtdIHBvc2l0aW9uIG9mIG5ld2x5IGFkZGVkIGRvY3VtZW50LFxuICAgICAgICAgICAgLy8gc3VibWl0IGl0IGZvciBhbGwgcmVnaXN0ZXJlZCBEeW5hbWljVmlld3MgdG8gZXZhbHVhdGUgZm9yIGluY2x1c2lvbi9leGNsdXNpb25cbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuX2R5bmFtaWNWaWV3cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY1ZpZXdzW2lkeF0uX2V2YWx1YXRlRG9jdW1lbnQocG9zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgcmFuZ2VkIGluZGV4ZXMgb2YgKHBvc3NpYmxlKSB2YWx1ZSB1cGRhdGVcbiAgICAgICAgICAgIGZvciAobGV0IHJpIGluIHRoaXMuX3JhbmdlZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZWRJbmRleGVzW3JpXS5pbmRleC51cGRhdGUoZG9jLiRsb2tpLCBkb2NbcmldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2lkSW5kZXhbcG9zaXRpb25dID0gbmV3SW50ZXJuYWwuJGxva2k7XG4gICAgICAgICAgICAvLyBGdWxsVGV4dFNlYXJjaC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mdWxsVGV4dFNlYXJjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxUZXh0U2VhcmNoLnVwZGF0ZURvY3VtZW50KGRvYywgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTsgLy8gZm9yIGF1dG9zYXZlIHNjZW5hcmlvc1xuICAgICAgICAgICAgLy8gdXBkYXRlIG1ldGEgYW5kIHN0b3JlIGNoYW5nZXMgaWYgQ2hhbmdlc0FQSSBpcyBlbmFibGVkXG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzYWJsZUNoYW5nZXNBcGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNZXRhKG5ld0ludGVybmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1ldGFXaXRoQ2hhbmdlKG5ld0ludGVybmFsLCBvbGRJbnRlcm5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmV0dXJuT2JqID0gbmV3SW50ZXJuYWw7XG4gICAgICAgICAgICAvLyBpZiBjbG9uaW5nIGlzIGVuYWJsZWQsIGVtaXQgJ3VwZGF0ZScgZXZlbnQgYW5kIHJldHVybiB3aXRoIGNsb25lIG9mIG5ldyBvYmplY3RcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9uZU9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5PYmogPSBjbG9uZShuZXdJbnRlcm5hbCwgdGhpcy5fY2xvbmVNZXRob2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHJldHVybk9iaiwgb2xkSW50ZXJuYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucm9sbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICB0aHJvdyAoZXJyKTsgLy8gcmUtdGhyb3cgZXJyb3Igc28gdXNlciBkb2VzIG5vdCB0aGluayBpdCBzdWNjZWVkZWRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgb2JqZWN0IHRvIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBfYWRkKG9iaikge1xuICAgICAgICAvLyBpZiBwYXJhbWV0ZXIgaXNuJ3Qgb2JqZWN0IGV4aXQgd2l0aCB0aHJvd1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9iaikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBiZWluZyBhZGRlZCBuZWVkcyB0byBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgb2JqZWN0IHlvdSBhcmUgYWRkaW5nIGFscmVhZHkgaGFzIGlkIGNvbHVtbiBpdCBpcyBlaXRoZXIgYWxyZWFkeSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAvLyBvciB0aGUgb2JqZWN0IGlzIGNhcnJ5aW5nIGl0cyBvd24gJ2lkJyBwcm9wZXJ0eS4gIElmIGl0IGFsc28gaGFzIGEgbWV0YSBwcm9wZXJ0eSxcbiAgICAgICAgLy8gdGhlbiB0aGlzIGlzIGFscmVhZHkgaW4gY29sbGVjdGlvbiBzbyB0aHJvdyBlcnJvciwgb3RoZXJ3aXNlIHJlbmFtZSB0byBvcmlnaW5hbElkIGFuZCBjb250aW51ZSBhZGRpbmcuXG4gICAgICAgIGlmIChvYmpbXCIkbG9raVwiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb2N1bWVudCBpcyBhbHJlYWR5IGluIGNvbGxlY3Rpb24sIHBsZWFzZSB1c2UgdXBkYXRlKClcIik7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogdHJ5IGFkZGluZyBvYmplY3QgdG8gY29sbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fbWF4SWQrKztcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLl9tYXhJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhJZCA9ICh0aGlzLl9kYXRhW3RoaXMuX2RhdGEubGVuZ3RoIC0gMV0uJGxva2kgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld0RvYyA9IG9iajtcbiAgICAgICAgICAgIG5ld0RvYy4kbG9raSA9IHRoaXMuX21heElkO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXNhYmxlTWV0YSkge1xuICAgICAgICAgICAgICAgIG5ld0RvYy5tZXRhLnZlcnNpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29uc3RyVW5pcXVlID0gdGhpcy5fY29uc3RyYWludHMudW5pcXVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29uc3RyVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0clVuaXF1ZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyVW5pcXVlW2tleV0uc2V0KG5ld0RvYy4kbG9raSwgbmV3RG9jW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBuZXcgb2JqIGlkIHRvIGlkSW5kZXhcbiAgICAgICAgICAgIHRoaXMuX2lkSW5kZXgucHVzaChuZXdEb2MuJGxva2kpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGxva2ltYXBcbiAgICAgICAgICAgIHRoaXMuX2xva2ltYXBbbmV3RG9jLiRsb2tpXSA9IG5ld0RvYztcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgb2JqZWN0XG4gICAgICAgICAgICB0aGlzLl9kYXRhLnB1c2gobmV3RG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkUG9zID0gdGhpcy5fZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgLy8gbm93IHRoYXQgd2UgY2FuIGVmZmljaWVudGx5IGRldGVybWluZSB0aGUgZGF0YVtdIHBvc2l0aW9uIG9mIG5ld2x5IGFkZGVkIGRvY3VtZW50LFxuICAgICAgICAgICAgLy8gc3VibWl0IGl0IGZvciBhbGwgcmVnaXN0ZXJlZCBEeW5hbWljVmlld3MgdG8gZXZhbHVhdGUgZm9yIGluY2x1c2lvbi9leGNsdXNpb25cbiAgICAgICAgICAgIGNvbnN0IGR2bGVuID0gdGhpcy5fZHluYW1pY1ZpZXdzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHZsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNWaWV3c1tpXS5fZXZhbHVhdGVEb2N1bWVudChhZGRlZFBvcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgaWQvdmFsIGt2cCB0byByYW5nZWQgaW5kZXhcbiAgICAgICAgICAgIGZvciAobGV0IHJpIGluIHRoaXMuX3JhbmdlZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgRGF0ZXMgYXJlIGNvbnZlcnRlZCB0byB1bml4IGVwb2NoIHRpbWUgaWYgc2VyaWFsaXphYmxlSW5kZXhlcyBpcyB0cnVlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlcmlhbGl6YWJsZUluZGV4ZXMgJiYgbmV3RG9jW3JpXSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RG9jW3JpXSA9IG5ld0RvY1tyaV0uZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZWRJbmRleGVzW3JpXS5pbmRleC5pbnNlcnQob2JqW1wiJGxva2lcIl0sIG9ialtyaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRnVsbFRleHRTZWFyY2guXG4gICAgICAgICAgICBpZiAodGhpcy5fZnVsbFRleHRTZWFyY2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsVGV4dFNlYXJjaC5hZGREb2N1bWVudChuZXdEb2MsIGFkZGVkUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7IC8vIGZvciBhdXRvc2F2ZSBzY2VuYXJpb3NcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fY2xvbmVPYmplY3RzKSA/IChjbG9uZShuZXdEb2MsIHRoaXMuX2Nsb25lTWV0aG9kKSkgOiAobmV3RG9jKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJvbGxiYWNrKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgKGVycik7IC8vIHJlLXRocm93IGVycm9yIHNvIHVzZXIgZG9lcyBub3QgdGhpbmsgaXQgc3VjY2VlZGVkXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIGZpbHRlciBmdW5jdGlvbiBhbmQgcGFzc2VzIGFsbCByZXN1bHRzIHRvIGFuIHVwZGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmaWx0ZXJGdW5jdGlvbiAtIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB1cGRhdGVGdW5jdGlvbiAtIHRoZSB1cGRhdGUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1cGRhdGVXaGVyZShmaWx0ZXJGdW5jdGlvbiwgdXBkYXRlRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMud2hlcmUoZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUodXBkYXRlRnVuY3Rpb24ocmVzdWx0c1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucm9sbGJhY2soKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGRvY3VtZW50cyBtYXRjaGluZyBzdXBwbGllZCBmaWx0ZXIgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZmlsdGVyRnVuY3Rpb24gLSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlV2hlcmUoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5fZGF0YS5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pKTtcbiAgICB9XG4gICAgcmVtb3ZlRGF0YU9ubHkoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKHRoaXMuX2RhdGEuc2xpY2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGRvY3VtZW50IGZyb20gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IGRvYyAtIGRvY3VtZW50IHRvIHJlbW92ZSBmcm9tIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICByZW1vdmUoZG9jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBkb2MgPSB0aGlzLmdldChkb2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICAgICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGRvYy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGs7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGRvY1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvYy4kbG9raSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3QgaXMgbm90IGEgZG9jdW1lbnQgc3RvcmVkIGluIHRoZSBjb2xsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0KGRvYy4kbG9raSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGFyclsxXTtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgY29udmVydGVkIGJ1dCBsZXQncyBuYXJyb3cgdG8gbWFrZSB0eXBlc2NyaXB0IGhhcHB5XG4gICAgICAgICAgICBsZXQgYURvYyA9ICh0eXBlb2YgZG9jID09PSBcIm51bWJlclwiKSA/IHRoaXMuZ2V0KGRvYykgOiBkb2M7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9jb25zdHJhaW50cy51bmlxdWUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gYURvYykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdHJhaW50cy51bmlxdWVba2V5XS5yZW1vdmUoYURvYy4kbG9raSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBub3cgdGhhdCB3ZSBjYW4gZWZmaWNpZW50bHkgZGV0ZXJtaW5lIHRoZSBkYXRhW10gcG9zaXRpb24gb2YgbmV3bHkgYWRkZWQgZG9jdW1lbnQsXG4gICAgICAgICAgICAvLyBzdWJtaXQgaXQgZm9yIGFsbCByZWdpc3RlcmVkIER5bmFtaWNWaWV3cyB0byByZW1vdmVcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuX2R5bmFtaWNWaWV3cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY1ZpZXdzW2lkeF0uX3JlbW92ZURvY3VtZW50KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RhdGEuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpZCBmcm9tIGlkSW5kZXhcbiAgICAgICAgICAgIHRoaXMuX2lkSW5kZXguc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIGxva2ltYXBcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2tpbWFwW2RvYy4kbG9raV07XG4gICAgICAgICAgICAvLyByZW1vdmUgaWQvdmFsIGt2cCBmcm9tIGJpbmFyeSB0cmVlIGluZGV4XG4gICAgICAgICAgICBmb3IgKGxldCByaSBpbiB0aGlzLl9yYW5nZWRJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VkSW5kZXhlc1tyaV0uaW5kZXgucmVtb3ZlKGRvYy4kbG9raSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGdWxsVGV4dFNlYXJjaC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mdWxsVGV4dFNlYXJjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxUZXh0U2VhcmNoLnJlbW92ZURvY3VtZW50KGRvYywgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTsgLy8gZm9yIGF1dG9zYXZlIHNjZW5hcmlvc1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXNhYmxlQ2hhbmdlc0FwaSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNoYW5nZSh0aGlzLm5hbWUsIFwiUlwiLCBhcnJbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVsZXRlXCIsIGFyclswXSk7XG4gICAgICAgICAgICBkZWxldGUgZG9jLiRsb2tpO1xuICAgICAgICAgICAgZGVsZXRlIGRvYy5tZXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucm9sbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyotLS0tLS0tLS0tLS0rXG4gICAgIHwgQ2hhbmdlIEFQSSB8XG4gICAgICstLS0tLS0tLS0tLS0qL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNoYW5nZXMuXG4gICAgICogQHJldHVybnMge0NvbGxlY3Rpb24uQ2hhbmdlW119XG4gICAgICovXG4gICAgZ2V0Q2hhbmdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgY2hhbmdlcyBhcGkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlQ2hhbmdlc0FwaVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZURlbHRhQ2hhbmdlc0FwaVxuICAgICAqL1xuICAgIHNldENoYW5nZXNBcGkoZGlzYWJsZUNoYW5nZXNBcGksIGRpc2FibGVEZWx0YUNoYW5nZXNBcGkgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVDaGFuZ2VzQXBpID0gZGlzYWJsZUNoYW5nZXNBcGk7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVEZWx0YUNoYW5nZXNBcGkgPSBkaXNhYmxlQ2hhbmdlc0FwaSA/IHRydWUgOiBkaXNhYmxlRGVsdGFDaGFuZ2VzQXBpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHRoZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGZsdXNoQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBfZ2V0T2JqZWN0RGVsdGEob2xkT2JqZWN0LCBuZXdPYmplY3QpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lcyA9IG5ld09iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2YgbmV3T2JqZWN0ID09PSBcIm9iamVjdFwiID8gT2JqZWN0LmtleXMobmV3T2JqZWN0KSA6IG51bGw7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWVzICYmIHByb3BlcnR5TmFtZXMubGVuZ3RoICYmIFtcInN0cmluZ1wiLCBcImJvb2xlYW5cIiwgXCJudW1iZXJcIl0uaW5kZXhPZih0eXBlb2YgKG5ld09iamVjdCkpIDwgMCkge1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5ld09iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2xkT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgfHwgdGhpcy5fY29uc3RyYWludHMudW5pcXVlW3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgcHJvcGVydHlOYW1lID09PSBcIiRsb2tpXCIgfHwgcHJvcGVydHlOYW1lID09PSBcIm1ldGFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFbcHJvcGVydHlOYW1lXSA9IG5ld09iamVjdFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlEZWx0YSA9IHRoaXMuX2dldE9iamVjdERlbHRhKG9sZE9iamVjdFtwcm9wZXJ0eU5hbWVdLCBuZXdPYmplY3RbcHJvcGVydHlOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlEZWx0YSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnR5RGVsdGEgIT09IHt9KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGVsdGEpLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9sZE9iamVjdCA9PT0gbmV3T2JqZWN0ID8gdW5kZWZpbmVkIDogbmV3T2JqZWN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgY2hhbmdlZCBvYmplY3QgKHdoaWNoIGlzIGEgZm9yY2VkIGNsb25lKSB3aXRoIGV4aXN0aW5nIG9iamVjdCBhbmQgcmV0dXJuIHRoZSBkZWx0YVxuICAgICAqL1xuICAgIF9nZXRDaGFuZ2VEZWx0YShvYmosIG9sZCkge1xuICAgICAgICBpZiAob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T2JqZWN0RGVsdGEob2xkLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IHN0YXR1cyBvZiBhbiBvYmplY3QgYW5kIGFzc29jaWF0ZXMgb3BlcmF0aW9uIGFuZCBjb2xsZWN0aW9uIG5hbWUsXG4gICAgICogc28gdGhlIHBhcmVudCBkYiBjYW4gYWdncmVnYXRlIGFuZCBnZW5lcmF0ZSBhIGNoYW5nZXMgb2JqZWN0IGZvciB0aGUgZW50aXJlIGRiXG4gICAgICovXG4gICAgX2NyZWF0ZUNoYW5nZShuYW1lLCBvcCwgb2JqLCBvbGQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvcGVyYXRpb246IG9wLFxuICAgICAgICAgICAgb2JqOiBvcCA9PT0gXCJVXCIgJiYgIXRoaXMuX2Rpc2FibGVEZWx0YUNoYW5nZXNBcGlcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2dldENoYW5nZURlbHRhKG9iaiwgb2xkKVxuICAgICAgICAgICAgICAgIDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NyZWF0ZUluc2VydENoYW5nZShvYmopIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQ2hhbmdlKHRoaXMubmFtZSwgXCJJXCIsIG9iaik7XG4gICAgfVxuICAgIF9jcmVhdGVVcGRhdGVDaGFuZ2Uob2JqLCBvbGQpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQ2hhbmdlKHRoaXMubmFtZSwgXCJVXCIsIG9iaiwgb2xkKTtcbiAgICB9XG4gICAgX2luc2VydE1ldGFXaXRoQ2hhbmdlKG9iaikge1xuICAgICAgICB0aGlzLl9pbnNlcnRNZXRhKG9iaik7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUluc2VydENoYW5nZShvYmopO1xuICAgIH1cbiAgICBfdXBkYXRlTWV0YVdpdGhDaGFuZ2Uob2JqLCBvbGQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlTWV0YShvYmopO1xuICAgICAgICB0aGlzLl9jcmVhdGVVcGRhdGVDaGFuZ2Uob2JqLCBvbGQpO1xuICAgIH1cbiAgICBfaW5zZXJ0TWV0YShvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvYmoubWV0YSkge1xuICAgICAgICAgICAgb2JqLm1ldGEgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICByZXZpc2lvbjogMCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG9iai5tZXRhLmNyZWF0ZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICBvYmoubWV0YS5yZXZpc2lvbiA9IDA7XG4gICAgfVxuICAgIF91cGRhdGVNZXRhKG9iaikge1xuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZU1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvYmoubWV0YS51cGRhdGVkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgb2JqLm1ldGEucmV2aXNpb24gKz0gMTtcbiAgICB9XG4gICAgZ2V0KGlkLCByZXR1cm5Qb3NpdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghcmV0dXJuUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGxldCBkb2MgPSB0aGlzLl9sb2tpbWFwW2lkXTtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2lkSW5kZXg7XG4gICAgICAgIGxldCBtYXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBtaW4gPSAwO1xuICAgICAgICBsZXQgbWlkID0gKG1pbiArIG1heCkgPj4gMTtcbiAgICAgICAgaWQgPSB0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIgPyBpZCA6IHBhcnNlSW50KGlkLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihpZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXNzZWQgaWQgaXMgbm90IGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRhdGFbbWluXSA8IGRhdGFbbWF4XSkge1xuICAgICAgICAgICAgbWlkID0gKG1pbiArIG1heCkgPj4gMTtcbiAgICAgICAgICAgIGlmIChkYXRhW21pZF0gPCBpZCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCA9PT0gbWluICYmIGRhdGFbbWluXSA9PT0gaWQpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5Qb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5fZGF0YVttaW5dLCBtaW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbWluXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgZG9jIGJ5IFVuaXF1ZSBpbmRleFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIG5hbWUgb2YgdW5pcXVlbHkgaW5kZXhlZCBwcm9wZXJ0eSB0byB1c2Ugd2hlbiBkb2luZyBsb29rdXBcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSB1bmlxdWUgdmFsdWUgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGRvY3VtZW50IG1hdGNoaW5nIHRoZSB2YWx1ZSBwYXNzZWRcbiAgICAgKi9cbiAgICBieShmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgLy8gZm9yIGxlYXN0IGFtb3VudCBvZiBvdmVyaGVhZCwgd2Ugd2lsbCBkaXJlY3RseVxuICAgICAgICAvLyBhY2Nlc3MgaW5kZXggcmF0aGVyIHRoYW4gdXNlIGZpbmQgY29kZXBhdGhcbiAgICAgICAgbGV0IGxva2lJZCA9IHRoaXMuX2NvbnN0cmFpbnRzLnVuaXF1ZVtmaWVsZF0uZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jbG9uZU9iamVjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2tpbWFwW2xva2lJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmUodGhpcy5fbG9raW1hcFtsb2tpSWRdLCB0aGlzLl9jbG9uZU1ldGhvZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBvbmUgb2JqZWN0IGJ5IGluZGV4IHByb3BlcnR5LCBieSBwcm9wZXJ0eSBlcXVhbCB0byB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeSAtIHF1ZXJ5IG9iamVjdCB1c2VkIHRvIHBlcmZvcm0gc2VhcmNoIHdpdGhcbiAgICAgKiBAcmV0dXJucyB7KG9iamVjdHxudWxsKX0gRmlyc3QgbWF0Y2hpbmcgZG9jdW1lbnQsIG9yIG51bGwgaWYgbm9uZVxuICAgICAqL1xuICAgIGZpbmRPbmUocXVlcnkpIHtcbiAgICAgICAgcXVlcnkgPSBxdWVyeSB8fCB7fTtcbiAgICAgICAgLy8gSW5zdGFudGlhdGUgUmVzdWx0U2V0IGFuZCBleGVjIGZpbmQgb3AgcGFzc2luZyBmaXJzdE9ubHkgPSB0cnVlIHBhcmFtXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2hhaW4oKS5maW5kKHF1ZXJ5LCB0cnVlKS5kYXRhKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nsb25lT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUocmVzdWx0WzBdLCB0aGlzLl9jbG9uZU1ldGhvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhaW4gbWV0aG9kLCB1c2VkIGZvciBiZWdpbm5pbmcgYSBzZXJpZXMgb2YgY2hhaW5lZCBmaW5kKCkgYW5kL29yIHZpZXcoKSBvcGVyYXRpb25zXG4gICAgICogb24gYSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gdHJhbnNmb3JtIC0gT3JkZXJlZCBhcnJheSBvZiB0cmFuc2Zvcm0gc3RlcCBvYmplY3RzIHNpbWlsYXIgdG8gY2hhaW5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1ldGVycyAtIE9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgcmVwcmVzZW50aW5nIHBhcmFtZXRlcnMgdG8gc3Vic3RpdHV0ZVxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTZXR9ICh0aGlzKSBSZXN1bHRTZXQsIG9yIGRhdGEgYXJyYXkgaWYgYW55IG1hcCBvciBqb2luIGZ1bmN0aW9ucyB3aGVyZSBjYWxsZWRcbiAgICAgKi9cbiAgICBjaGFpbih0cmFuc2Zvcm0sIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgcnMgPSBuZXcgcmVzdWx0X3NldF9SZXN1bHRTZXQodGhpcyk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBycy50cmFuc2Zvcm0odHJhbnNmb3JtLCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBtZXRob2QsIGFwaSBpcyBzaW1pbGFyIHRvIG1vbmdvZGIuXG4gICAgICogZm9yIG1vcmUgY29tcGxleCBxdWVyaWVzIHVzZSBbY2hhaW4oKV17QGxpbmsgQ29sbGVjdGlvbiNjaGFpbn0gb3IgW3doZXJlKClde0BsaW5rIENvbGxlY3Rpb24jd2hlcmV9LlxuICAgICAqIEBleGFtcGxlIHtAdHV0b3JpYWwgUXVlcnkgRXhhbXBsZXN9XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXJ5IC0gJ21vbmdvLWxpa2UnIHF1ZXJ5IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgbWF0Y2hpbmcgZG9jdW1lbnRzXG4gICAgICovXG4gICAgZmluZChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbigpLmZpbmQocXVlcnkpLmRhdGEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBvYmplY3QgYnkgdW5pbmRleGVkIGZpZWxkIGJ5IHByb3BlcnR5IGVxdWFsIHRvIHZhbHVlLFxuICAgICAqIHNpbXBseSBpdGVyYXRlcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBtYXRjaGluZyB0aGUgcXVlcnlcbiAgICAgKi9cbiAgICBmaW5kT25lVW5pbmRleGVkKHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5fZGF0YS5sZW5ndGg7XG4gICAgICAgIGxldCBkb2M7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhW2ldW3Byb3BdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRvYyA9IHRoaXMuX2RhdGFbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNhY3Rpb24gbWV0aG9kc1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIHN0YXJ0IHRoZSB0cmFuc2F0aW9uXG4gICAgICovXG4gICAgc3RhcnRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uYWwpIHtcbiAgICAgICAgICAgIC8vIGJhY2t1cCBhbnkgcmFuZ2VkIGluZGV4ZXNcbiAgICAgICAgICAgIGxldCByaWIgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IHJpIGluIHRoaXMuX3JhbmdlZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICByaWJbcmldLmluZGV4VHlwZU5hbWUgPSB0aGlzLl9yYW5nZWRJbmRleGVzW3JpXS5pbmRleFR5cGVOYW1lO1xuICAgICAgICAgICAgICAgIHJpYltyaV0uY29tcGFyYXRvck5hbWUgPSB0aGlzLl9yYW5nZWRJbmRleGVzW3JpXS5jb21wYXJhdG9yTmFtZTtcbiAgICAgICAgICAgICAgICByaWJbcmldLmluZGV4ID0gdGhpcy5fcmFuZ2VkSW5kZXhlc1tyaV0uaW5kZXguYmFja3VwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWQgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuX2lkSW5kZXgsXG4gICAgICAgICAgICAgICAgZGF0YTogY2xvbmUodGhpcy5fZGF0YSwgdGhpcy5fY2xvbmVNZXRob2QpLFxuICAgICAgICAgICAgICAgIHJhbmdlZEluZGV4ZXM6IHJpYixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgc3RhcnRUcmFuc2FjdGlvbiB0byBkeW5hbWljIHZpZXdzXG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9keW5hbWljVmlld3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNWaWV3c1tpZHhdLnN0YXJ0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21taXQgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgY29tbWl0IHRvIGR5bmFtaWMgdmlld3NcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuX2R5bmFtaWNWaWV3cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY1ZpZXdzW2lkeF0uY29tbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUm9sbGJhY2sgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHJvbGxiYWNrKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkSW5kZXggPSB0aGlzLl9jYWNoZWQuaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2NhY2hlZC5kYXRhO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW2ldID0gdGhpcy5fZGVmaW5lTmVzdGVkUHJvcGVydGllcyh0aGlzLl9kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSByYW5nZWQgaW5kZXhlc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJpIGluIHRoaXMuX2NhY2hlZC5yYW5nZWRJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3J0Y3V0IHJlZmVyZW5jZSB0byBzZXJpYWxpemVkIG1ldGFcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNyaSA9IHRoaXMuX2NhY2hlZC5yYW5nZWRJbmRleGVzW3JpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9va3VwIGluZGV4IGZhY3RvcnkgZnVuY3Rpb24gaW4gbWFwIGJhc2VkIG9uIGluZGV4IHR5cGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmlmID0gcmFuZ2VkX2luZGV4ZXNbXCJhXCIgLyogUmFuZ2VkSW5kZXhGYWN0b3J5TWFwICovXVtzcmkuaW5kZXhUeXBlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2t1cCBjb21wYXJhdG9yIGZ1bmN0aW9uIGluIG1hcCBiYXNlZCBvbiBjb21wYXJhdG9yIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpY21wID0gY29tcGFyYXRvcnNbXCJhXCIgLyogQ29tcGFyYXRvck1hcCAqL11bc3JpLmNvbXBhcmF0b3JOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgaW5kZXggdHlwZSAoZnJvbSBtZXRhKSwgaW5kZXggZmFjdG9yeSBhbmQgY29tcGFyYXRvci4uLiBjcmVhdGUgaW5zdGFuY2Ugb2YgcmFuZ2VkIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIGxldCByaWkgPSByaWYocmksIHJpY21wKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm93IGFzayBuZXcgaW5kZXggaW5zdGFuY2UgdG8gaW5mbGF0ZSBmcm9tIHBsYWluIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICByaWkucmVzdG9yZShzcmkuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2ggY2xhc3MgaW5zdGFuY2UgdG8gb3VyIGNvbGxlY3Rpb24ncyByYW5nZWQgaW5kZXgncyAoaW5kZXgpIGluc3RhbmNlIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhbmdlZEluZGV4ZXNbcmldLmluZGV4ID0gcmlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgcm9sbGJhY2sgdG8gZHluYW1pYyB2aWV3c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuX2R5bmFtaWNWaWV3cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNWaWV3c1tpZHhdLnJvbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHRoZSBjb2xsZWN0aW9uIGJ5IHN1cHBseWluZyBhIGphdmFzY3JpcHQgZmlsdGVyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IHJlc3VsdHMgPSBjb2xsLndoZXJlKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICogICByZXR1cm4gb2JqLmxlZ3MgPT09IDg7XG4gICAgICAgKiB9KTtcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW4gLSBmaWx0ZXIgZnVuY3Rpb24gdG8gcnVuIGFnYWluc3QgYWxsIGNvbGxlY3Rpb24gZG9jc1xuICAgICAqIEByZXR1cm5zIHthcnJheX0gYWxsIGRvY3VtZW50cyB3aGljaCBwYXNzIHlvdXIgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgd2hlcmUoZnVuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYWluKCkud2hlcmUoZnVuKS5kYXRhKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcCBSZWR1Y2Ugb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRnVuY3Rpb24gLSBmdW5jdGlvbiB0byB1c2UgYXMgbWFwIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVkdWNlRnVuY3Rpb24gLSBmdW5jdGlvbiB0byB1c2UgYXMgcmVkdWNlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2RhdGF9IFRoZSByZXN1bHQgb2YgeW91ciBtYXBSZWR1Y2Ugb3BlcmF0aW9uXG4gICAgICovXG4gICAgbWFwUmVkdWNlKG1hcEZ1bmN0aW9uLCByZWR1Y2VGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gcmVkdWNlRnVuY3Rpb24odGhpcy5fZGF0YS5tYXAobWFwRnVuY3Rpb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiB0d28gY29sbGVjdGlvbnMgb24gc3BlY2lmaWVkIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBqb2luRGF0YSAtIGFycmF5IG9mIGRvY3VtZW50cyB0byAnam9pbicgdG8gdGhpcyBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRKb2luUHJvcCAtIHByb3BlcnR5IG5hbWUgaW4gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodEpvaW5Qcm9wIC0gcHJvcGVydHkgbmFtZSBpbiBqb2luRGF0YVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZ1biAtIChPcHRpb25hbCkgbWFwIGZ1bmN0aW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSBkYXRhT3B0aW9ucyAtIG9wdGlvbnMgdG8gZGF0YSgpIGJlZm9yZSBpbnB1dCB0byB5b3VyIG1hcCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBbZGF0YU9wdGlvbnMucmVtb3ZlTWV0YV0gLSBhbGxvd3MgcmVtb3ZpbmcgbWV0YSBiZWZvcmUgY2FsbGluZyBtYXBGdW5cbiAgICAgKiBAcGFyYW0gW2RhdGFPcHRpb25zLmZvcmNlQ2xvbmVzXSAtIGZvcmNpbmcgdGhlIHJldHVybiBvZiBjbG9uZWQgb2JqZWN0cyB0byB5b3VyIG1hcCBvYmplY3RcbiAgICAgKiBAcGFyYW0gW2RhdGFPcHRpb25zLmZvcmNlQ2xvbmVNZXRob2RdIC0gYWxsb3dzIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWQgY2xvbmluZyBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0U2V0fSBSZXN1bHQgb2YgdGhlIG1hcHBpbmcgb3BlcmF0aW9uXG4gICAgICovXG4gICAgZXFKb2luKGpvaW5EYXRhLCBsZWZ0Sm9pblByb3AsIHJpZ2h0Sm9pblByb3AsIG1hcEZ1biwgZGF0YU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZXN1bHRfc2V0X1Jlc3VsdFNldCh0aGlzKS5lcUpvaW4oam9pbkRhdGEsIGxlZnRKb2luUHJvcCwgcmlnaHRKb2luUHJvcCwgbWFwRnVuLCBkYXRhT3B0aW9ucyk7XG4gICAgfVxuICAgIC8qIC0tLS0tLSBTVEFHSU5HIEFQSSAtLS0tLS0tLSAqL1xuICAgIC8qKlxuICAgICAqIChTdGFnaW5nIEFQSSkgY3JlYXRlIGEgc3RhZ2UgYW5kL29yIHJldHJpZXZlIGl0XG4gICAgICovXG4gICAgZ2V0U3RhZ2UobmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YWdlc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhZ2VzW25hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWdlc1tuYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgcmVjb3JkaW5nIHRoZSBjaGFuZ2VzIGFwcGxpZWQgdGhyb3VnaCBhIGNvbW1taXRTdGFnZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIChTdGFnaW5nIEFQSSkgY3JlYXRlIGEgY29weSBvZiBhbiBvYmplY3QgYW5kIGluc2VydCBpdCBpbnRvIGEgc3RhZ2VcbiAgICAgKi9cbiAgICBzdGFnZShzdGFnZU5hbWUsIG9iaikge1xuICAgICAgICBjb25zdCBjb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICAgICAgdGhpcy5nZXRTdGFnZShzdGFnZU5hbWUpW29iai4kbG9raV0gPSBjb3B5O1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogKFN0YWdpbmcgQVBJKSByZS1hdHRhY2ggYWxsIG9iamVjdHMgdG8gdGhlIG9yaWdpbmFsIGNvbGxlY3Rpb24sIHNvIGluZGV4ZXMgYW5kIHZpZXdzIGNhbiBiZSByZWJ1aWx0XG4gICAgICogdGhlbiBjcmVhdGUgYSBtZXNzYWdlIHRvIGJlIGluc2VydGVkIGluIHRoZSBjb21taXRsb2dcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhZ2VOYW1lIC0gbmFtZSBvZiBzdGFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgY29tbWl0U3RhZ2Uoc3RhZ2VOYW1lLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHN0YWdlID0gdGhpcy5nZXRTdGFnZShzdGFnZU5hbWUpO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHN0YWdlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShzdGFnZVtwcm9wXSk7XG4gICAgICAgICAgICB0aGlzLl9jb21taXRMb2cucHVzaCh7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGFnZVtwcm9wXSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFnZXNbc3RhZ2VOYW1lXSA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB2YWx1ZXMgb2YgYSBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgLSB0aGUgZmllbGQgbmFtZVxuICAgICAqIEByZXR1cm4ge2FueX06IHRoZSBhcnJheSBvZiB2YWx1ZXNcbiAgICAgKi9cbiAgICBleHRyYWN0KGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX2RhdGFbaV1bZmllbGRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIHRoZSBmaWVsZCBuYW1lXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgbWluaW11bSB2YWx1ZVxuICAgICAqL1xuICAgIG1pbihmaWVsZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkobnVsbCwgdGhpcy5leHRyYWN0TnVtZXJpY2FsKGZpZWxkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgZmllbGQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIC0gdGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICovXG4gICAgbWF4KGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLmV4dHJhY3ROdW1lcmljYWwoZmllbGQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG1pbmltdW0gdmFsdWUgYW5kIGl0cyBpbmRleCBvZiBhIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIHRoZSBmaWVsZCBuYW1lXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAtIGluZGV4IGFuZCB2YWx1ZVxuICAgICAqL1xuICAgIG1pblJlY29yZChmaWVsZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IHRoaXMuX2RhdGFbMF0uJGxva2k7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5fZGF0YVswXVtmaWVsZF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHBhcnNlRmxvYXQodGhpcy5fZGF0YVtpXVtmaWVsZF0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSA+IHZhbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXggPSB0aGlzLl9kYXRhW2ldLiRsb2tpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBtYXhpbXVtIHZhbHVlIGFuZCBpdHMgaW5kZXggb2YgYSBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgLSB0aGUgZmllbGQgbmFtZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gLSBpbmRleCBhbmQgdmFsdWVcbiAgICAgKi9cbiAgICBtYXhSZWNvcmQoZmllbGQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbmRleCA9IG51bGw7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuaW5kZXggPSB0aGlzLl9kYXRhWzBdLiRsb2tpO1xuICAgICAgICByZXN1bHQudmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuX2RhdGFbMF1bZmllbGRdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl9kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBwYXJzZUZsb2F0KHRoaXMuX2RhdGFbaV1bZmllbGRdKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUgPCB2YWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ID0gdGhpcy5fZGF0YVtpXS4kbG9raTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB2YWx1ZXMgb2YgYSBmaWVsZCBhcyBudW1iZXJzIChpZiBwb3NzaWJsZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIC0gdGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gLSB0aGUgbnVtYmVyIGFycmF5XG4gICAgICovXG4gICAgZXh0cmFjdE51bWVyaWNhbChmaWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0KGZpZWxkKS5tYXAocGFyc2VGbG9hdCkuZmlsdGVyKE51bWJlcikuZmlsdGVyKChuKSA9PiAhKGlzTmFOKG4pKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGF2ZXJhZ2UgbnVtZXJpY2FsIHZhbHVlIG9mIGEgZmllbGRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgLSB0aGUgZmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGF2ZXJhZ2Ugb2YgcHJvcGVydHkgaW4gYWxsIGRvY3MgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBhdmcoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGF2ZXJhZ2UodGhpcy5leHRyYWN0TnVtZXJpY2FsKGZpZWxkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGEgZmllbGQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIC0gdGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBzdGFuZGFyZCBkZXZpYXRpb25cbiAgICAgKi9cbiAgICBzdGREZXYoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHN0YW5kYXJkRGV2aWF0aW9uKHRoaXMuZXh0cmFjdE51bWVyaWNhbChmaWVsZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBtb2RlIG9mIGEgZmllbGQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIC0gdGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBtb2RlXG4gICAgICovXG4gICAgbW9kZShmaWVsZCkge1xuICAgICAgICBjb25zdCBkaWN0ID0ge307XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmV4dHJhY3ROdW1lcmljYWwoZmllbGQpO1xuICAgICAgICBsZXQgbW9kZSA9IGRhdGFbMF07XG4gICAgICAgIGxldCBtYXhDb3VudCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGRhdGFbaV07XG4gICAgICAgICAgICBpZiAoZGljdFtlbF0pIHtcbiAgICAgICAgICAgICAgICBkaWN0W2VsXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGljdFtlbF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpY3RbZWxdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBtb2RlID0gZWw7XG4gICAgICAgICAgICAgICAgbWF4Q291bnQgPSBkaWN0W2VsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbWVkaWFuIG9mIGEgZmllbGQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIC0gdGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBtZWRpYW5cbiAgICAgKi9cbiAgICBtZWRpYW4oZmllbGQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5leHRyYWN0TnVtZXJpY2FsKGZpZWxkKTtcbiAgICAgICAgdmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgY29uc3QgaGFsZiA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaGFsZl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlc1toYWxmIC0gMV0gKyB2YWx1ZXNbaGFsZl0pIC8gMi4wO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9sb2tpL3NyYy9hdmxfaW5kZXgudHNcbi8qKlxuICogTG9raURCIEFWTCBCYWxhbmNlZCBCaW5hcnkgVHJlZSBJbmRleCBpbXBsZW1lbnRhdGlvbi5cbiAqIFRvIHN1cHBvcnQgZHVwbGljYXRlcywgd2UgdXNlIHNpYmxpbmdzIChhcnJheSkgaW4gdHJlZSBub2Rlcy5cbiAqIEJhc2ljIEFWTCBjb21wb25lbnRzIGd1aWRlZCBieSBXaWxsaWFtIEZpc2V0IHR1dG9yaWFscyBhdCA6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2lsbGlhbWZpc2V0L2RhdGEtc3RydWN0dXJlcy9ibG9iL21hc3Rlci9jb20vd2lsbGlhbWZpc2V0L2RhdGFzdHJ1Y3R1cmVzL2JhbGFuY2VkdHJlZS9BVkxUcmVlUmVjdXJzaXZlLmphdmFcbiAqIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9ZzR5Mmg3MEQ2TmsmbGlzdD1QTERWMVplaDJOUnNEMDZ4NTlmeGN6ZFdMaEREc3pVSEt0XG4gKi9cbmNsYXNzIEF2bFRyZWVJbmRleCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgaW5kZXggd2l0aCBwcm9wZXJ0eSBuYW1lIGFuZCBhIGNvbXBhcmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLmFwZXggPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIH1cbiAgICBiYWNrdXAoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgQXZsVHJlZUluZGV4KHRoaXMubmFtZSwgdGhpcy5jb21wYXJhdG9yKTtcbiAgICAgICAgcmVzdWx0Lm5vZGVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLm5vZGVzKSk7XG4gICAgICAgIHJlc3VsdC5hcGV4ID0gdGhpcy5hcGV4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXN0b3JlKHRyZWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gdHJlZS5uYW1lO1xuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSB0cmVlLmNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMubm9kZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRyZWUubm9kZXMpKTtcbiAgICAgICAgdGhpcy5hcGV4ID0gdHJlZS5hcGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBpbnNlcnRpbmcgYSBuZXcgdmFsdWUgaW50byB0aGUgQmluYXJ5VHJlZUluZGV4XG4gICAgICogQHBhcmFtIGlkIFVuaXF1ZSBJZCAoc3VjaCBhcyAkbG9raSkgdG8gYXNzb2NpYXRlIHdpdGggdmFsdWVcbiAgICAgKiBAcGFyYW0gdmFsIFZhbHVlIHRvIGJlIGluZGV4ZWQgYW5kIGluc2VydGVkIGludG8gYmluYXJ5IHRyZWVcbiAgICAgKi9cbiAgICBpbnNlcnQoaWQsIHZhbCkge1xuICAgICAgICBpZiAoaWQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXZsIGluZGV4IGlkcyBhcmUgcmVxdWlyZWQgdG8gYmUgbnVtYmVycyBncmVhdGVyIHRoYW4gemVyb1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZXNbaWRdID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGJhbGFuY2U6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBsZWZ0OiBudWxsLFxuICAgICAgICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICAgICAgICBzaWJsaW5nczogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmFwZXgpIHtcbiAgICAgICAgICAgIHRoaXMuYXBleCA9IGlkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zZXJ0Tm9kZSh0aGlzLm5vZGVzW3RoaXMuYXBleF0sIG5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBpbnNlcnRzIGEgdHJlZW5vZGUgYW5kIHJlLWJhbGFuY2VzIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0gY3VycmVudFxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICovXG4gICAgaW5zZXJ0Tm9kZShjdXJyZW50LCBub2RlKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb21wYXJhdG9yKG5vZGUudmFsdWUsIGN1cnJlbnQudmFsdWUpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gZXFcbiAgICAgICAgICAgICAgICBjdXJyZW50LnNpYmxpbmdzLnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXJyZW50LmlkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIGd0XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb2RlKHRoaXMubm9kZXNbY3VycmVudC5yaWdodF0sIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJhbGFuY2UoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnJpZ2h0ID0gbm9kZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXJyZW50LmlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJhbGFuY2UoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAvLyBsdFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb2RlKHRoaXMubm9kZXNbY3VycmVudC5sZWZ0XSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQmFsYW5jZShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubGVmdCA9IG5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gY3VycmVudC5pZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCYWxhbmNlKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29tcGFyYXRvciByZXN1bHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQuYmFsYW5jZSA8IC0xKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5zZXJ0Tm9kZS5iYWxhbmNlKCkgOiBsZWZ0IGNoaWxkIHNob3VsZCBub3QgYmUgbnVsbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2N1cnJlbnQubGVmdF0uYmFsYW5jZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0TGVmdENhc2UoY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnRSaWdodENhc2UoY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQuYmFsYW5jZSA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5zZXJ0Tm9kZS5iYWxhbmNlKCkgOiByaWdodCBjaGlsZCBzaG91bGQgbm90IGJlIG51bGxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tjdXJyZW50LnJpZ2h0XS5iYWxhbmNlID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0UmlnaHRDYXNlKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodExlZnRDYXNlKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50LmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBoZWlnaHQgYW5kIGJhbGFuY2UgKGNhbGN1bGF0aW9uKSBmb3IgdHJlZSBub2RlXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICB1cGRhdGVCYWxhbmNlKG5vZGUpIHtcbiAgICAgICAgbGV0IGhsID0gbm9kZS5sZWZ0ID8gdGhpcy5ub2Rlc1tub2RlLmxlZnRdLmhlaWdodCA6IC0xO1xuICAgICAgICBsZXQgaHIgPSBub2RlLnJpZ2h0ID8gdGhpcy5ub2Rlc1tub2RlLnJpZ2h0XS5oZWlnaHQgOiAtMTtcbiAgICAgICAgLy9ub2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChobCwgaHIpO1xuICAgICAgICBub2RlLmhlaWdodCA9IChobCA+IGhyKSA/IDEgKyBobCA6IDEgKyBocjtcbiAgICAgICAgbm9kZS5iYWxhbmNlID0gaHIgLSBobDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFsYW5jZSB0aGUgJ2RvdWJsZSBsZWZ0LWhlYXZ5JyBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIGxlZnRMZWZ0Q2FzZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZVJpZ2h0KG5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYWxhbmNlIHRoZSAnKHBhcmVudCkgbGVmdCBoZWF2eSwgKGNoaWxkKSByaWdodCBoZWF2eScgY29uZGl0aW9uXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICBsZWZ0UmlnaHRDYXNlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLmxlZnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxlZnRSaWdodENhc2U6IGxlZnQgY2hpbGQgbm90IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmxlZnQgPSB0aGlzLnJvdGF0ZUxlZnQodGhpcy5ub2Rlc1tub2RlLmxlZnRdKS5pZDtcbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlUmlnaHQobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhbGFuY2UgdGhlICdkb3VibGUgcmlnaHQtaGVhdnknIGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICovXG4gICAgcmlnaHRSaWdodENhc2Uobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVMZWZ0KG5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYWxhbmNlIHRoZSAnKHBhcmVudCkgcmlnaHQgaGVhdnksIChjaGlsZCkgbGVmdCBoZWF2eScgY29uZGl0aW9uXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICByaWdodExlZnRDYXNlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLnJpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyaWdodExlZnRDYXNlOiByaWdodCBjaGlsZCBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnJvdGF0ZVJpZ2h0KHRoaXMubm9kZXNbbm9kZS5yaWdodF0pLmlkO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVMZWZ0KG5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWZ0IHJvdGF0aW9uIG9mIG5vZGUuIFN3YXBzIHJpZ2h0IGNoaWxkIGludG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIHJvdGF0ZUxlZnQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJvdGF0ZUxlZnQ6IHJpZ2h0IGNoaWxkIHdhcyB1bmF2YWlsYWJsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IChub2RlLnBhcmVudCkgPyB0aGlzLm5vZGVzW25vZGUucGFyZW50XSA6IG51bGw7XG4gICAgICAgIGxldCByaWdodCA9IHRoaXMubm9kZXNbbm9kZS5yaWdodF07XG4gICAgICAgIC8vIGFzc3VtZSByaWdodHMgKG9sZCkgbGVmdCBicmFuY2ggYXMgb3VyIChuZXcpIHJpZ2h0IGJyYW5jaFxuICAgICAgICBub2RlLnJpZ2h0ID0gcmlnaHQubGVmdDtcbiAgICAgICAgaWYgKG5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbbm9kZS5yaWdodF0ucGFyZW50ID0gbm9kZS5pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyByaWdodCB3aWxsIGJlIG5ldyBwYXJlbnQgdG8gbm9kZSBhbmQgYXNzdW1lIG9sZCBub2RlJ3MgcGFyZW50XG4gICAgICAgIHJpZ2h0LmxlZnQgPSBub2RlLmlkO1xuICAgICAgICByaWdodC5wYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSByaWdodC5pZDtcbiAgICAgICAgLy8gcmVtYXAgcGFyZW50IGNoaWxkIHBvaW50ZXIgdG8gcmlnaHRcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5sZWZ0ID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByaWdodC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5yaWdodCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJpZ2h0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicm90YXRlTGVmdCgpIDogYXR0ZW1wdCB0byByZW1hcCBwYXJlbnQgYmFjayB0byBjaGlsZCBmYWlsZWQuLi4gbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBleCAhPT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJpZ2h0Um90YXRlIGV4cGVjdGluZyBwYXJlbnRsZXNzIG5vZGUgdG8gYmUgYXBleFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBleCA9IHJpZ2h0LmlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlY2FsY3VsYXRlIGhlaWdodCBhbmQgYmFsYW5jZSBmb3Igc3dhcHBlZCBub2Rlc1xuICAgICAgICB0aGlzLnVwZGF0ZUJhbGFuY2Uobm9kZSk7XG4gICAgICAgIHRoaXMudXBkYXRlQmFsYW5jZShyaWdodCk7XG4gICAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmlnaHQgcm90YXRpb24gb2Ygbm9kZS4gU3dhcHMgbGVmdCBjaGlsZCBpbnRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICByb3RhdGVSaWdodChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyb3RhdGVSaWdodCA6IGxlZnQgY2hpbGQgdW5hdmFpbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IChub2RlLnBhcmVudCkgPyB0aGlzLm5vZGVzW25vZGUucGFyZW50XSA6IG51bGw7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5ub2Rlc1tub2RlLmxlZnRdO1xuICAgICAgICAvLyBhc3N1bWUgbGVmdCdzIChvbGQpIHJpZ2h0IGJyYW5jaCBhcyBvdXIgKG5ldykgbGVmdCBicmFuY2hcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdC5yaWdodDtcbiAgICAgICAgaWYgKGxlZnQucmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbbGVmdC5yaWdodF0ucGFyZW50ID0gbm9kZS5pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyAnbm9kZScgd2lsbCBiZSByaWdodCBjaGlsZCBvZiBsZWZ0XG4gICAgICAgIGxlZnQucmlnaHQgPSBub2RlLmlkO1xuICAgICAgICBsZWZ0LnBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICBub2RlLnBhcmVudCA9IGxlZnQuaWQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQubGVmdCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gbGVmdC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IGxlZnQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGV4ICE9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmlnaHRSb3RhdGUgZXhwZWN0aW5nIHBhcmVudGxlc3Mgbm9kZSB0byBiZSBhcGV4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcGV4ID0gbGVmdC5pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNhbGN1bGF0ZSBoZWlnaHQgYW5kIGJhbGFuY2UgZm9yIHN3YXBwZWQgbm9kZXNcbiAgICAgICAgdGhpcy51cGRhdGVCYWxhbmNlKG5vZGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJhbGFuY2UobGVmdCk7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaWFnbm9zdGljIG1ldGhvZCBmb3IgZXhhbWluaW5nIHRyZWUgY29udGVudHMgYW5kIHN0cnVjdHVyZVxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICovXG4gICAgZ2V0VmFsdWVzQXNUcmVlKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBleCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBub2RlID0gbm9kZSB8fCB0aGlzLm5vZGVzW3RoaXMuYXBleF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgIHZhbDogbm9kZS52YWx1ZSxcbiAgICAgICAgICAgIHNpYmxpbmdzOiBub2RlLnNpYmxpbmdzLFxuICAgICAgICAgICAgYmFsYW5jZTogbm9kZS5iYWxhbmNlLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IG5vZGUubGVmdCA/IHRoaXMuZ2V0VmFsdWVzQXNUcmVlKHRoaXMubm9kZXNbbm9kZS5sZWZ0XSkgOiBudWxsLFxuICAgICAgICAgICAgcmlnaHQ6IG5vZGUucmlnaHQgPyB0aGlzLmdldFZhbHVlc0FzVHJlZSh0aGlzLm5vZGVzW25vZGUucmlnaHRdKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSB2YWx1ZSwgcG9zc2libHkgcmVsb2NhdGluZyBpdCwgd2l0aGluIGJpbmFyeSB0cmVlXG4gICAgICogQHBhcmFtIGlkIFVuaXF1ZSBJZCAoc3VjaCBhcyAkbG9raSkgdG8gYXNzb2NpYXRlIHdpdGggdmFsdWVcbiAgICAgKiBAcGFyYW0gdmFsIE5ldyB2YWx1ZSB0byBiZSBpbmRleGVkIHdpdGhpbiBiaW5hcnkgdHJlZVxuICAgICAqL1xuICAgIHVwZGF0ZShpZCwgdmFsKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2Rlc1tpZF07XG4gICAgICAgIGxldCBjbXAgPSB0aGlzLmNvbXBhcmF0b3Iobm9kZS52YWx1ZSwgdmFsKTtcbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGRpZCBub3QgY2hhbmdlLCBvciBjaGFuZ2VkIHRvIHZhbHVlIGNvbnNpZGVyZWQgZXF1YWwgdG8gaXRzZWxmLCByZXR1cm4uXG4gICAgICAgIGlmIChjbXAgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVtb3ZlKGlkKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoaWQsIHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBiaW5hcnkgdHJlZSBpbmRleFxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqL1xuICAgIHJlbW92ZShpZCkge1xuICAgICAgICBpZiAoIXRoaXMuYXBleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVtb3ZlKCkgOiBhdHRlbXB0aW5nIHJlbW92ZSB3aGVuIHRyZWUgaGFzIG5vIGFwZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlKHRoaXMubm9kZXNbdGhpcy5hcGV4XSwgaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgbm9kZSByZW1vdmFsIGFuZCByZWJhbGFuY2VyXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZShub2RlLCBpZCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZXNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW1vdmVOb2RlOiBhdHRlbXB0aW5nIHRvIHJlbW92ZSBhIG5vZGUgd2hpY2ggaXMgbm90IGluIGhhc2htYXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbCA9IHRoaXMubm9kZXNbaWRdLnZhbHVlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY29tcGFyYXRvcih2YWwsIG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gZXEgLSBoYW5kbGUgc2libGluZ3MgaWYgcHJlc2VudFxuICAgICAgICAgICAgICAgIGlmIChub2RlLnNpYmxpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm9kZSB0byByZW1vdmUgaXMgYWxwaGEgc2libGluZy4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBmaXJzdCBzaWJsaW5nIGFzIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWxwaGFTaWJsaW5nSWQgPSBub2RlLnNpYmxpbmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWxwaGFTaWJsaW5nID0gdGhpcy5ub2Rlc1thbHBoYVNpYmxpbmdJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1hcCBhbGwgcHJvcGVydGllcyBidXQgaWQgYW5kIHZhbHVlIGZyb20gbm9kZSBvbnRvIGFscGhhc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFTaWJsaW5nLnBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZExpbmsobm9kZS5wYXJlbnQsIGlkLCBhbHBoYVNpYmxpbmdJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tub2RlLmxlZnRdLnBhcmVudCA9IGFscGhhU2libGluZ0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW25vZGUucmlnaHRdLnBhcmVudCA9IGFscGhhU2libGluZ0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFTaWJsaW5nLmxlZnQgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYVNpYmxpbmcucmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFTaWJsaW5nLnNpYmxpbmdzID0gbm9kZS5zaWJsaW5ncztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhU2libGluZy5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhU2libGluZy5iYWxhbmNlID0gbm9kZS5iYWxhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBleCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwZXggPSBhbHBoYVNpYmxpbmdJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBhbGwgcmVtYWluaW5nIHNpYmxpbmdzIGFscGhhU2libGluZyAobmV3IHBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNpIG9mIGFscGhhU2libGluZy5zaWJsaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbc2ldLnBhcmVudCA9IGFscGhhU2libGluZ0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9sZCBub2RlIGZyb20gbm9kZXMgYW5kIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugd2UgYXJlIGlubmVyIHNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gbm9kZS5zaWJsaW5ncy5pbmRleE9mKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlbW92ZSBzaWJsaW5nIGZyb20gcGFyZW50ZWQgc2libGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2libGluZ3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZWxzZSB3ZSBoYXZlIG5vIHNpYmxpbmdzLCBub2RlIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub2RlIHRvIGRlbGV0ZSBoYXMgbm8gY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQgJiYgIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBwYXJlbnQsIHJlbW92ZSB1cyBmcm9tIGVpdGhlciBsZWZ0IG9yIHJpZ2h0IGNoaWxkIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRMaW5rKG5vZGUucGFyZW50LCBub2RlLmlkLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gdGhpcy5hcGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub2RlIHRvIGRlbGV0ZSBoYXMgb25seSBvbmUgY2hpbGQgd2UgY2FuIGRvIHNpbXBsZSBjb3B5L3JlcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQgfHwgIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21vdGVDaGlsZChub2RlLCB0aGlzLm5vZGVzW25vZGUubGVmdF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwZXggPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBleCA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbW90ZUNoaWxkKG5vZGUsIHRoaXMubm9kZXNbbm9kZS5yaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwZXggPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBleCA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgdG8gZGVsZXRlIGhhcyB0d28gY2hpbGRyZW4sIG5lZWQgc3dhcCB3aXRoIGlub3JkZXIgc3VjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBmaW5kIGlub3JkZXIgc3VjY2Vzc29yIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9tb3RlU3VjY2Vzc29yKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIGd0IC0gc2VhcmNoIHJpZ2h0IGJyYW5jaFxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW1vdmVOb2RlOiBVbmFibGUgdG8gZmluZCB2YWx1ZSBpbiB0cmVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUodGhpcy5ub2Rlc1tub2RlLnJpZ2h0XSwgaWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAvLyBsdCAtIHNlYXJjaCBsZWZ0IGJyYW5jaFxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZU5vZGU6IFVuYWJsZSB0byBmaW5kIHZhbHVlIGluIHRyZWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZSh0aGlzLm5vZGVzW25vZGUubGVmdF0sIGlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUJhbGFuY2Uobm9kZSk7XG4gICAgICAgIGlmIChub2RlLmJhbGFuY2UgPCAtMSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluc2VydE5vZGUuYmFsYW5jZSgpIDogbGVmdCBjaGlsZCBzaG91bGQgbm90IGJlIG51bGxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tub2RlLmxlZnRdLmJhbGFuY2UgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdExlZnRDYXNlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0UmlnaHRDYXNlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmJhbGFuY2UgPiAxKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluc2VydE5vZGUuYmFsYW5jZSgpIDogcmlnaHQgY2hpbGQgc2hvdWxkIG5vdCBiZSBudWxsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbbm9kZS5yaWdodF0uYmFsYW5jZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodFJpZ2h0Q2FzZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHRMZWZ0Q2FzZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgdXBkYXRpbmcgYSBwYXJlbnQncyBjaGlsZCBsaW5rIHdoZW4gaXQgY2hhbmdlc1xuICAgICAqIEBwYXJhbSBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSBvbGRDaGlsZElkXG4gICAgICogQHBhcmFtIG5ld0NoaWxkSWRcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZExpbmsocGFyZW50SWQsIG9sZENoaWxkSWQsIG5ld0NoaWxkSWQpIHtcbiAgICAgICAgaWYgKHBhcmVudElkID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5ub2Rlc1twYXJlbnRJZF07XG4gICAgICAgIGlmIChwYXJlbnQubGVmdCA9PT0gb2xkQ2hpbGRJZCkge1xuICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBuZXdDaGlsZElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudC5yaWdodCA9PT0gb2xkQ2hpbGRJZCkge1xuICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gbmV3Q2hpbGRJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHJlbW92aW5nIGEgcGFyZW50IHdpdGggb25seSBjaGlsZCwgdGhpcyBkb2VzIHNpbXBsZSByZW1hcCBvZiBjaGlsZCB0byBncmFuZFBhcmVudC5cbiAgICAgKiBAcGFyYW0gZ3JhbmRQYXJlbnQgTmV3IHBhcmVudCBvZiAnY2hpbGQnLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgTm9kZSBiZWluZyByZW1vdmVkLlxuICAgICAqIEBwYXJhbSBjaGlsZCBOb2RlIHRvIHJlcGFyZW50IHRvIGdyYW5kUGFyZW50LlxuICAgICAqL1xuICAgIHByb21vdGVDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgIGxldCBncElkID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgaWYgKGdwSWQpIHtcbiAgICAgICAgICAgIGxldCBncCA9IHRoaXMubm9kZXNbZ3BJZF07XG4gICAgICAgICAgICBpZiAoZ3AubGVmdCA9PT0gcGFyZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgZ3AubGVmdCA9IGNoaWxkLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZ3AucmlnaHQgPT09IHBhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgIGdwLnJpZ2h0ID0gY2hpbGQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtYXAgKGdyYW5kKSBjaGlsZCdzIHBhcmVudCBwb2ludGVyIHRvIGdyYW5kcGFyZW50IChuZXcgcGFyZW50KSBvciBudWxsIGlmIG5ldyBhcGV4XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IGdwSWQ7XG4gICAgICAgIC8vIHJlbW92ZSBwYXJlbnQgZnJvbSBic3QgaGFzaG1hcFxuICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1twYXJlbnQuaWRdO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgc3VjY2Vzc29yIHRvIGEgbm9kZSBhbmQgcmVwbGFjZXMgdGhhdCBub2RlIHdpdGggaXQuXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICBwcm9tb3RlU3VjY2Vzc29yKG5vZGUpIHtcbiAgICAgICAgbGV0IG9sZElkID0gbm9kZS5pZDtcbiAgICAgICAgLy8gYXNzdW1lIHN1Y2Nlc3Nvci9yaWdodCBicmFuY2ggKGZvciBub3cpXG4gICAgICAgIGlmICghbm9kZS5yaWdodCB8fCAhbm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9tb3RlU3VjY2Vzc29yKCkgOiBub2RlIHRvIHJlcGxhY2UgZG9lcyBub3QgaGF2ZSB0d28gY2hpbGRyZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1Y2Nlc3NvciA9IG51bGw7XG4gICAgICAgIGxldCBnbHNJZDtcbiAgICAgICAgbGV0IGdsc1ZhbHVlO1xuICAgICAgICBsZXQgZ2xzU2libGluZ3M7XG4gICAgICAgIC8vIGlmIHRyZWUgaXMgYWxyZWFkeSBsZWZ0IGhlYXZ5LFxuICAgICAgICAvLyBsZXQncyByZXBsYWNlIHdpdGggcHJlZGVjZXNzb3IgKGdyZWF0ZXN0IHZhbCBpbiBsZWZ0IGJyYW5jaClcbiAgICAgICAgaWYgKG5vZGUuYmFsYW5jZSA8IDApIHtcbiAgICAgICAgICAgIGxldCBsY2hpbGQgPSB0aGlzLm5vZGVzW25vZGUubGVmdF07XG4gICAgICAgICAgICBzdWNjZXNzb3IgPSB0aGlzLmZpbmRHcmVhdGVyTGVhZihsY2hpbGQpO1xuICAgICAgICAgICAgZ2xzSWQgPSBzdWNjZXNzb3IuaWQ7XG4gICAgICAgICAgICBnbHNWYWx1ZSA9IHN1Y2Nlc3Nvci52YWx1ZTtcbiAgICAgICAgICAgIGdsc1NpYmxpbmdzID0gc3VjY2Vzc29yLnNpYmxpbmdzO1xuICAgICAgICAgICAgc3VjY2Vzc29yLnNpYmxpbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUobGNoaWxkLCBnbHNJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSB0cmVlIGlzIGVpdGhlciBiYWxhbmNlZCBvciByaWdodCBoZWF2eSxcbiAgICAgICAgLy8gc28gbGV0J3MgdXNlIHN1Y2Vzc29yIChsZWFzdCB2YWx1ZSBpbiByaWdodCBicmFuY2gpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJjaGlsZCA9IHRoaXMubm9kZXNbbm9kZS5yaWdodF07XG4gICAgICAgICAgICBzdWNjZXNzb3IgPSB0aGlzLmZpbmRMZXNzZXJMZWFmKHJjaGlsZCk7XG4gICAgICAgICAgICBnbHNJZCA9IHN1Y2Nlc3Nvci5pZDtcbiAgICAgICAgICAgIGdsc1ZhbHVlID0gc3VjY2Vzc29yLnZhbHVlO1xuICAgICAgICAgICAgZ2xzU2libGluZ3MgPSBzdWNjZXNzb3Iuc2libGluZ3M7XG4gICAgICAgICAgICAvLyBkb250IGxlYXZlIGFueSBzaWJsaW5ncyB3aGVuIHdlICh0ZW1wb3JhcmlseSkgJ3JlbW92ZScgb3IgdGhleSB3aWxsIGFzc3VtZSBvd25lcnNoaXAgb2Ygb2xkIG5vZGVcbiAgICAgICAgICAgIHN1Y2Nlc3Nvci5zaWJsaW5ncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlKHJjaGlsZCwgZ2xzSWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBhbnkgcGFyZW50IHBvaW50ZXJzIHRvIG5vZGUgYmVpbmcgcmVwbGFjZWRcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICBsZXQgcCA9IHRoaXMubm9kZXNbbm9kZS5wYXJlbnRdO1xuICAgICAgICAgICAgaWYgKHAubGVmdCA9PT0gb2xkSWQpXG4gICAgICAgICAgICAgICAgcC5sZWZ0ID0gZ2xzSWQ7XG4gICAgICAgICAgICBpZiAocC5yaWdodCA9PT0gb2xkSWQpXG4gICAgICAgICAgICAgICAgcC5yaWdodCA9IGdsc0lkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBhbnkgY2hpbGQgcG9pbnRzIHRvIG5vZGUgYmVpbmcgcmVwbGFjZWRcbiAgICAgICAgaWYgKG5vZGUubGVmdClcbiAgICAgICAgICAgIHRoaXMubm9kZXNbbm9kZS5sZWZ0XS5wYXJlbnQgPSBnbHNJZDtcbiAgICAgICAgaWYgKG5vZGUucmlnaHQpXG4gICAgICAgICAgICB0aGlzLm5vZGVzW25vZGUucmlnaHRdLnBhcmVudCA9IGdsc0lkO1xuICAgICAgICAvLyB1cGRhdGUgKHJldXNlKSBub2RlIGluc3RhbmNlIGlkIGFuZCB2YWx1ZSB3aXRoIHRoYXQgb2Ygc3VjY2Vzc29yXG4gICAgICAgIG5vZGUuaWQgPSBnbHNJZDtcbiAgICAgICAgbm9kZS52YWx1ZSA9IGdsc1ZhbHVlO1xuICAgICAgICBub2RlLnNpYmxpbmdzID0gZ2xzU2libGluZ3M7XG4gICAgICAgIC8vIHVwZGF0ZSBoYXNobWFwXG4gICAgICAgIHRoaXMubm9kZXNbZ2xzSWRdID0gbm9kZTtcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbb2xkSWRdO1xuICAgICAgICAvLyBpZiBvbGQgd2FzIGFwZXgsIHVwZGF0ZSBhcGV4IHRvIHBvaW50IHRvIHN1Y2Nlc3NvclxuICAgICAgICBpZiAodGhpcy5hcGV4ID09PSBvbGRJZClcbiAgICAgICAgICAgIHRoaXMuYXBleCA9IGdsc0lkO1xuICAgICAgICB0aGlzLnVwZGF0ZUJhbGFuY2Uobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIGZvciBmaW5kaW5nIEluLU9yZGVyIHByZWRlY2Vzc29yIHRvIHRoZSBwcm92aWRlZCBub2RlXG4gICAgICogQHBhcmFtIG5vZGUgUGFyZW50IG5vZGUgdG8gZmluZCBsZWFmIG5vZGUgb2YgZ3JlYXRlc3QgJ3ZhbHVlJ1xuICAgICovXG4gICAgZmluZEdyZWF0ZXJMZWFmKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLnJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5maW5kR3JlYXRlckxlYWYodGhpcy5ub2Rlc1tub2RlLnJpZ2h0XSk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgZmluZGluZyBJbi1PcmRlciBzdWNjZXNzb3IgdG8gdGhlIHByb3ZpZGVkIG5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZSBQYXJlbnQgTm9kZSB0byBmaW5kIGxlYWYgbm9kZSBvZiBsZWFzdCAndmFsdWUnXG4gICAgICovXG4gICAgZmluZExlc3NlckxlYWYobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUubGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZmluZExlc3NlckxlYWYodGhpcy5ub2Rlc1tub2RlLmxlZnRdKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJbnRlcmZhY2UgbWV0aG9kIHRvIHN1cHBvcnQgcmFuZ2VkIHF1ZXJpZXMuICBSZXN1bHRzIHNvcnRlZCBieSBpbmRleCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgT3B0aW9ucyBmb3IgcmFuZ2VkIHJlcXVlc3QuXG4gICAgICovXG4gICAgcmFuZ2VSZXF1ZXN0KHJhbmdlKSB7XG4gICAgICAgIGlmICghdGhpcy5hcGV4KVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAvLyBpZiByZXF1ZXN0aW5nIGFsbCBpZCdzIHNvcnRlZCBieSB0aGVpciB2YWx1ZVxuICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXRlSWRzKHRoaXMubm9kZXNbdGhpcy5hcGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLm9wID09PSBcIiRlcVwiKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLmxvY2F0ZSh0aGlzLm5vZGVzW3RoaXMuYXBleF0sIHJhbmdlLnZhbCk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2guc2libGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFttYXRjaC5pZCwgLi4ubWF0Y2guc2libGluZ3NdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFttYXRjaC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY29sbGF0ZVJlcXVlc3QodGhpcy5ub2Rlc1t0aGlzLmFwZXhdLCByYW5nZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgcmFuZ2VkIHJlcXVlc3Qgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSByYW5nZVxuICAgICAqL1xuICAgIGNvbGxhdGVSZXF1ZXN0KG5vZGUsIHJhbmdlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHJhbmdlLm9wID09PSBcIiRlcVwiKSB7XG4gICAgICAgICAgICAvLyB3ZSB1c2UgbG9jYXRlIGluc3RlYWQgZm9yICRlcSByYW5nZSByZXF1ZXN0c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGF0ZVJlcXVlc3QgZG9lcyBub3Qgc3VwcG9ydCAkZXEgcmFuZ2UgcmVxdWVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY21wMSA9IHRoaXMuY29tcGFyYXRvcihub2RlLnZhbHVlLCByYW5nZS52YWwpO1xuICAgICAgICBsZXQgY21wMiA9IDA7XG4gICAgICAgIGlmIChyYW5nZS5vcCA9PT0gXCIkYmV0d2VlblwiKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UuaGlnaCA9PT0gbnVsbCB8fCByYW5nZS5oaWdoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb2xsYXRlUmVxdWVzdDogJGJldHdlZW4gcmVxdWVzdCBtaXNzaW5nIGhpZ2ggcmFuZ2UgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbXAyID0gdGhpcy5jb21wYXJhdG9yKG5vZGUudmFsdWUsIHJhbmdlLmhpZ2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxlZnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmFuZ2Uub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiJGx0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRsdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb2xsYXRlUmVxdWVzdCh0aGlzLm5vZGVzW25vZGUubGVmdF0sIHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRndFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIkZ3RlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG5vZGUgaXMgc3RpbGwgZ3JlYXRlciB0aGFuIGNvbXBhcmUgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgbGVmdCBjaGlsZCB3aWxsIGJlIHRvb1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21wMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb2xsYXRlUmVxdWVzdCh0aGlzLm5vZGVzW25vZGUubGVmdF0sIHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiJGJldHdlZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBwdXJzdWUgbGVmdCBwYXRoIGlmIGN1cnJlbnQgbm9kZSBncmVhdGVyIHRoYW4gKGxvdykgcmFuZ2UgdmFsXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbXAxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbGxhdGVSZXF1ZXN0KHRoaXMubm9kZXNbbm9kZS5sZWZ0XSwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4ubm9kZS5zaWJsaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJhbmdlLm9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRsdFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY21wMSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4ubm9kZS5zaWJsaW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRsdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtcDEgPT09IC0xIHx8IGNtcDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4ubm9kZS5zaWJsaW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRndFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY21wMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi5ub2RlLnNpYmxpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiJGd0ZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY21wMSA9PT0gMSB8fCBjbXAxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLm5vZGUuc2libGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCIkYmV0d2VlblwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY21wMSA+PSAwICYmIGNtcDIgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi5ub2RlLnNpYmxpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5yaWdodCkge1xuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLnRoaXMuY29sbGF0ZVJlcXVlc3QodGhpcy5ub2Rlc1tub2RlLnJpZ2h0XSwgcmFuZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmFuZ2Uub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiRsdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJGx0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBzdGlsbCBsZXNzIHRoYW4gY29tcGFyZSB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgcmlnaHQgY2hpbGQgd2lsbCBiZSB0b29cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbXAxID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLnRoaXMuY29sbGF0ZVJlcXVlc3QodGhpcy5ub2Rlc1tub2RlLnJpZ2h0XSwgcmFuZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiJGd0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIkZ3RlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi50aGlzLmNvbGxhdGVSZXF1ZXN0KHRoaXMubm9kZXNbbm9kZS5yaWdodF0sIHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiRiZXR3ZWVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHB1cnN1ZSByaWdodCBwYXRoIGlmIGN1cnJlbnQgbm9kZSBsZXNzIHRoYW4gKGhpZ2gpIHJhbmdlIHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtcDIgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4udGhpcy5jb2xsYXRlUmVxdWVzdCh0aGlzLm5vZGVzW25vZGUucmlnaHRdLCByYW5nZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIG9uIGEgYnJhbmNoIG5vZGUgdG8gcmV0dXJuIGFuIGFycmF5IG9mIGlkIHdpdGhpbiB0aGF0IGJyYW5jaCwgc29ydGVkIGJ5IHRoZWlyIHZhbHVlXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICBjb2xsYXRlSWRzKG5vZGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBkZWJ1ZyBkaWFnbm9zdGljXG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxlZnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29sbGF0ZUlkcyh0aGlzLm5vZGVzW25vZGUubGVmdF0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUuaWQpO1xuICAgICAgICByZXN1bHQucHVzaCguLi5ub2RlLnNpYmxpbmdzKTtcbiAgICAgICAgaWYgKG5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLnRoaXMuY29sbGF0ZUlkcyh0aGlzLm5vZGVzW25vZGUucmlnaHRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRyZWUgdG8gYSBub2RlIG1hdGNoaW5nIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cbiAgICAvKlxuICAgIHByaXZhdGUgbG9jYXRlKG5vZGU6IFRyZWVOb2RlPFQ+LCB2YWw6IGFueSk6IFRyZWVOb2RlPFQ+IHtcbiAgICAgICBzd2l0Y2ggKHRoaXMuY29tcGFyYXRvci5jb21wYXJlKHZhbCwgbm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBub2RlO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICBpZiAoIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2F0ZSh0aGlzLm5vZGVzW25vZGUucmlnaHRdLCB2YWwpO1xuICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2F0ZSh0aGlzLm5vZGVzW25vZGUubGVmdF0sIHZhbCk7XG4gICAgICAgfVxuICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIElubGluZS9Ob24tcmVjdXNpdmUgJ3NpbmdsZSB2YWx1ZScgKCRlcSkgbG9va3VwLlxuICAgICAqIFRyYXZlcnNlcyB0cmVlIHRvIGEgbm9kZSBtYXRjaGluZyB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG4gICAgbG9jYXRlKG5vZGUsIHZhbCkge1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmNvbXBhcmF0b3IodmFsLCBub2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGVzW25vZGUucmlnaHRdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMubm9kZXNbbm9kZS5sZWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGV4IGludGVncml0eSBjaGVjayAoSVJhbmdlZEluZGV4IGludGVyZmFjZSBmdW5jdGlvbilcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUluZGV4KCkge1xuICAgICAgICAvLyBoYW5kbGUgbnVsbCBhcGV4IGNvbmRpdGlvbiBhbmQgdmVyaWZ5IGVtcHR5IHRyZWUgYW5kIG5vZGVzXG4gICAgICAgIGlmICghdGhpcy5hcGV4KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5ub2RlcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIGFwZXggaGFzIG5vIHBhcmVudFxuICAgICAgICBpZiAodGhpcy5ub2Rlc1t0aGlzLmFwZXhdLnBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhpZ2ggbGV2ZWwgdmVyaWZpY2F0aW9uIC0gcmV0cmlldmUgYWxsIG5vZGUgaWRzIG9yZGVyZWQgYnkgdGhlaXIgdmFsdWVzXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbGxhdGVJZHModGhpcy5ub2Rlc1t0aGlzLmFwZXhdKTtcbiAgICAgICAgbGV0IG5jID0gT2JqZWN0LmtleXModGhpcy5ub2RlcykubGVuZ3RoO1xuICAgICAgICAvLyB2ZXJpZnkgdGhlIGlub3JkZXIgdHJhdmVyc2FsIHJldHVybmVkIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIG5vZGVzIGhhc2htYXBcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IG5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgb25seSBvbmUgcmVzdWx0XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tyZXN1bHRbMF1dLnBhcmVudCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tyZXN1bHRbMF1dLmxlZnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbcmVzdWx0WzBdXS5yaWdodCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdGVyYXRlIHJlc3VsdHMgYW5kIGVuc3VyZSBuZXh0IHZhbHVlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gY3VycmVudFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmF0b3IodGhpcy5ub2Rlc1tyZXN1bHRbaV1dLnZhbHVlLCB0aGlzLm5vZGVzW3Jlc3VsdFtpICsgMV1dLnZhbHVlKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU5vZGUodGhpcy5ub2Rlc1t0aGlzLmFwZXhdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlIE5vZGUgdmFsaWRhdGlvbiByb3V0aW5lXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICB2YWxpZGF0ZU5vZGUobm9kZSkge1xuICAgICAgICAvLyBzaG91bGQgbmV2ZXIgaGF2ZSBwYXJlbnQgb3IgY2hpbGQgcG9pbnRlcnMgcmVmZXJlbmNlIHNlbGZcbiAgICAgICAgaWYgKFtub2RlLnBhcmVudCwgbm9kZS5sZWZ0LCBub2RlLnJpZ2h0XS5pbmRleE9mKG5vZGUuaWQpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhbGlkYXRlIGhlaWdodCBhbmQgYmFsYW5jZVxuICAgICAgICBsZXQgaGwgPSAobm9kZS5sZWZ0KSA/IHRoaXMubm9kZXNbbm9kZS5sZWZ0XS5oZWlnaHQgOiAtMTtcbiAgICAgICAgbGV0IGhyID0gKG5vZGUucmlnaHQpID8gdGhpcy5ub2Rlc1tub2RlLnJpZ2h0XS5oZWlnaHQgOiAtMTtcbiAgICAgICAgbGV0IGVoID0gMSArIE1hdGgubWF4KGhsLCBocik7XG4gICAgICAgIGlmIChub2RlLmhlaWdodCAhPT0gZWgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5iYWxhbmNlICE9PSBociAtIGhsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmVyaWZ5IGFueSBzaWJsaW5ncyBwYXJlbnQgYmFjayB0byBzZWxmXG4gICAgICAgIGlmIChub2RlLnNpYmxpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNpZCBvZiBub2RlLnNpYmxpbmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbc2lkXS5wYXJlbnQgIT09IG5vZGUuaWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIGxlZnQgY2hpbGQsIHZlcmlmeSBpdCBwYXJlbnRzIHRvIHNlbGYgYW5kIHJlY3Vyc2UgaXRcbiAgICAgICAgaWYgKG5vZGUubGVmdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbbm9kZS5sZWZ0XS5wYXJlbnQgIT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVOb2RlKHRoaXMubm9kZXNbbm9kZS5sZWZ0XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSByaWdodCBjaGlsZCwgdmVyaWZ5IGl0IHBhcmVudHMgdG8gc2VsZiBhbmQgcmVjdXJzZSBpdFxuICAgICAgICBpZiAobm9kZS5yaWdodCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbbm9kZS5yaWdodF0ucGFyZW50ICE9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlTm9kZSh0aGlzLm5vZGVzW25vZGUucmlnaHRdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvbG9raS9zcmMvcmFuZ2VkX2luZGV4ZXMudHNcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUmFuZ2VkSW5kZXhGYWN0b3J5TWFwOyB9KTtcblxuLyoqIE1hcC9SZWdpc3RlciBvZiBuYW1lZCBmYWN0b3J5IGZ1bmN0aW9ucyByZXR1cm5pbmcgSVJhbmdlZEluZGV4IGluc3RhbmNlcyAqL1xubGV0IFJhbmdlZEluZGV4RmFjdG9yeU1hcCA9IHtcbiAgICBcImF2bFwiOiAobmFtZSwgY29tcGFyYXRvcikgPT4geyByZXR1cm4gbmV3IEF2bFRyZWVJbmRleChuYW1lLCBjb21wYXJhdG9yKTsgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExva2lFdmVudEVtaXR0ZXI7IH0pO1xuLyoqXG4gKiBMb2tpRXZlbnRFbWl0dGVyIGlzIGEgbWluaW1hbGlzdCB2ZXJzaW9uIG9mIEV2ZW50RW1pdHRlci4gSXQgZW5hYmxlcyBhbnlcbiAqIGNvbnN0cnVjdG9yIHRoYXQgaW5oZXJpdHMgRXZlbnRFbWl0dGVyIHRvIGVtaXQgZXZlbnRzIGFuZCB0cmlnZ2VyXG4gKiBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGV2ZW50IHRocm91Z2ggdGhlIG9uKGV2ZW50LCBjYWxsYmFjaykgbWV0aG9kXG4gKlxuICogQGNvbnN0cnVjdG9yIExva2lFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgTG9raUV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCwgd2l0aCBlYWNoIHByb3BlcnR5IGJlaW5nIGFuIGFycmF5IG9mIGNhbGxiYWNrcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsbGJhY2tzIGFzc29jaWF0ZWQgd2l0aCBlYWNoIGV2ZW50IHNob3VsZCBoYXBwZW4gaW4gYW4gYXN5bmMgZmFzaGlvbiBvciBub3QuXG4gICAgICAgICAqIERlZmF1bHQgaXMgZmFsc2UsIHdoaWNoIG1lYW5zIGV2ZW50cyBhcmUgc3luY2hyb25vdXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FzeW5jTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgcXVldWUgb2YgY2FsbGJhY2tzIGFzc29jaWF0ZWQgdG8gYW4gZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZXZlbnROYW1lIC0gdGhlIG5hbWUocykgb2YgdGhlIGV2ZW50KHMpIHRvIGxpc3RlbiB0b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gY2FsbGJhY2sgZnVuY3Rpb24gb2YgbGlzdGVuZXIgdG8gYXR0YWNoXG4gICAgICogQHJldHVybnMge2ludH0gdGhlIGluZGV4IG9mIHRoZSBjYWxsYmFjayBpbiB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIHBhcnRpY3VsYXIgZXZlbnRcbiAgICAgKi9cbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGxldCBldmVudDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgZXZlbnROYW1lLmZvckVhY2goKGN1cnJlbnRFdmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKGN1cnJlbnRFdmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50ID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIHBhcnRpY3VsYXIgZXZlbnRcbiAgICAgKiB3aXRoIHRoZSBvcHRpb24gb2YgcGFzc2luZyBvcHRpb25hbCBwYXJhbWV0ZXJzIHdoaWNoIGFyZSBnb2luZyB0byBiZSBwcm9jZXNzZWQgYnkgdGhlIGNhbGxiYWNrXG4gICAgICogcHJvdmlkZWQgc2lnbmF0dXJlcyBtYXRjaCAoaS5lLiBpZiBwYXNzaW5nIGVtaXQoZXZlbnQsIGFyZzAsIGFyZzEpIHRoZSBsaXN0ZW5lciBzaG91bGQgdGFrZSB0d28gcGFyYW1ldGVycylcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBvcHRpb25hbCBvYmplY3QgcGFzc2VkIHdpdGggdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdChldmVudE5hbWUsIC4uLmRhdGEpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAmJiB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0uZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXN5bmNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciguLi5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciguLi5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBFdmVudEVtaXR0ZXIub24oKS5cbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsaXN0ZW5lciBhdCBwb3NpdGlvbiAnaW5kZXgnIGZyb20gdGhlIGV2ZW50ICdldmVudE5hbWUnXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGV2ZW50TmFtZSAtIHRoZSBuYW1lKHMpIG9mIHRoZSBldmVudChzKSB3aGljaCB0aGUgbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIHRoZSBsaXN0ZW5lciBjYWxsYmFjayBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSBlbWl0dGVyXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBldmVudE5hbWUuZm9yRWFjaCgoY3VycmVudEV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoY3VycmVudEV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UobGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMb2tpOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29sbGVjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcGFyYXRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JhbmdlZF9pbmRleGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9vcGVyYXRvcl9wYWNrYWdlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldEVOVigpIHtcbiAgICBpZiAoZ2xvYmFsICE9PSB1bmRlZmluZWQgJiYgKGdsb2JhbFtcImFuZHJvaWRcIl0gfHwgZ2xvYmFsW1wiTlNPYmplY3RcIl0pKSB7XG4gICAgICAgIHJldHVybiBcIk5BVElWRVNDUklQVFwiO1xuICAgIH1cbiAgICBjb25zdCBpc05vZGUgPSBnbG9iYWwgIT09IHVuZGVmaW5lZCAmJiAoe30pLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIGlmIChnbG9iYWxbXCJ3aW5kb3dcIl0pIHtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVKU1wiOyAvL25vZGUtd2Via2l0XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFSlNcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuVVJMLmluZGV4T2YoXCJodHRwOi8vXCIpID09PSAtMSAmJiBkb2N1bWVudC5VUkwuaW5kZXhPZihcImh0dHBzOi8vXCIpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiQ09SRE9WQVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkJST1dTRVJcIjtcbiAgICB9XG4gICAgY29uc3QgaXNCcm93c2VyID0gd2luZG93ICE9PSB1bmRlZmluZWQgJiYgKHt9KS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09IFwiW29iamVjdCBXaW5kb3ddXCI7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gXCJCUk9XU0VSXCI7XG4gICAgfVxuICAgIHRocm93IFN5bnRheEVycm9yKFwiVW5rbm93biBlbnZpcm9ubWVudC4uLlwiKTtcbn1cbmNsYXNzIExva2kgZXh0ZW5kcyBfZXZlbnRfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIExva2lFdmVudEVtaXR0ZXIgKi8gXCJhXCJdIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIHRoZSBtYWluIGRhdGFiYXNlIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgc2F2ZWQgdG9cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIC0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TG9raS5FbnZpcm9ubWVudH0gW29wdGlvbnMuZW52XSAtIHRoZSBqYXZhc2NyaXB0IGVudmlyb25tZW50XG4gICAgICogQHBhcmFtIHtMb2tpLlNlcmlhbGl6YXRpb25NZXRob2R9IFtvcHRpb25zLnNlcmlhbGl6YXRpb25NZXRob2Q9Tk9STUFMXSAtIHRoZSBzZXJpYWxpemF0aW9uIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXN0cnVjdHVyZURlbGltaXRlcj1cIiQ8XFxuXCJdIC0gc3RyaW5nIGRlbGltaXRlciB1c2VkIGZvciBkZXN0cnVjdHVyZWQgc2VyaWFsaXphdGlvblxuICAgICAqIEBwYXJhbSB7SUNvbXBhcmF0b3JNYXB9IFtvcHRpb25zLmNvbXBhcmF0b3JNYXBdIGFsbG93cyBpbmplY3Rpbmcgb3Igb3ZlcnJpZGluZyByZWdpc3RlcmVkIGNvbXBhcmF0b3JzXG4gICAgICogQHBhcmFtIHtJUmFuZ2VkSW5kZXhGYWN0b3J5TWFwfSBbb3B0aW9ucy5yYW5nZWRJbmRleEZhY3RvcnlNYXBdIGFsbG93cyBpbmplY3Rpbmcgb3Igb3ZlcnJpZGluZyByZWdpc3RlcmVkIHJhbmdlZCBpbmRleCBmYWN0b3JpZXNcbiAgICAgKiBAcGFyYW0ge0lMb2tpT3BlcmF0b3JQYWNrYWdlTWFwfSBbb3B0aW9ucy5sb2tpT3BlcmF0b3JQYWNrYWdlTWFwXSBhbGxvd3MgaW5qZWN0aW5nIG9yIG92ZXJyaWRpbmcgcmVnaXN0ZXJlZCBsb2tpIG9wZXJhdG9yIHBhY2thZ2VzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmlsZW5hbWUgPSBcImxva2kuZGJcIiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHBlcnNpc3QgdmVyc2lvbiBvZiBjb2RlIHdoaWNoIGNyZWF0ZWQgdGhlIGRhdGFiYXNlIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAgICAgLy8gY291bGQgdXNlIGZvciB1cGdyYWRlIHNjZW5hcmlvc1xuICAgICAgICB0aGlzLmRhdGFiYXNlVmVyc2lvbiA9IDEuNTsgLy8gVE9ET1xuICAgICAgICB0aGlzLmVuZ2luZVZlcnNpb24gPSAxLjU7XG4gICAgICAgIC8vIHBlcnNpc3RlbmNlTWV0aG9kIGNvdWxkIGJlICdmcycsICdsb2NhbFN0b3JhZ2UnLCBvciAnYWRhcHRlcidcbiAgICAgICAgLy8gdGhpcyBpcyBvcHRpb25hbCBvcHRpb24gcGFyYW0sIG90aGVyd2lzZSBlbnZpcm9ubWVudCBkZXRlY3Rpb24gd2lsbCBiZSB1c2VkXG4gICAgICAgIC8vIGlmIHVzZXIgcGFzc2VzIHRoZWlyIG93biBhZGFwdGVyIHdlIHdpbGwgZm9yY2UgdGhpcyBtZXRob2QgdG8gJ2FkYXB0ZXInIGxhdGVyLCBzbyBubyBuZWVkIHRvIHBhc3MgbWV0aG9kIG9wdGlvbi5cbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VNZXRob2QgPSBudWxsO1xuICAgICAgICAvLyByZXRhaW4gcmVmZXJlbmNlIHRvIG9wdGlvbmFsIChub24tc2VyaWFsaXphYmxlKSBwZXJzaXN0ZW5jZUFkYXB0ZXIgJ2luc3RhbmNlJ1xuICAgICAgICB0aGlzLl9wZXJzaXN0ZW5jZUFkYXB0ZXIgPSBudWxsO1xuICAgICAgICAvLyBmbGFncyB1c2VkIHRvIHRocm90dGxlIHNhdmVzXG4gICAgICAgIHRoaXMuX3Rocm90dGxlZFNhdmVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdGhyb3R0bGVkU2F2ZVJ1bm5pbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl90aHJvdHRsZWRTYXZlUGVuZGluZyA9IG51bGw7XG4gICAgICAgIC8vIGF1dG9zYXZlIHN1cHBvcnQgKGRpc2FibGVkIGJ5IGRlZmF1bHQpXG4gICAgICAgIHRoaXMuX2F1dG9zYXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2F1dG9zYXZlSW50ZXJ2YWwgPSA1MDAwO1xuICAgICAgICB0aGlzLl9hdXRvc2F2ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXV0b3NhdmVIYW5kbGVyID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbnMgPSBbXTtcbiAgICAgICAgKHtcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25NZXRob2Q6IHRoaXMuX3NlcmlhbGl6YXRpb25NZXRob2QgPSBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgZGVzdHJ1Y3R1cmVEZWxpbWl0ZXI6IHRoaXMuX2Rlc3RydWN0dXJlRGVsaW1pdGVyID0gXCIkPFxcblwiLFxuICAgICAgICAgICAgZW52OiB0aGlzLl9lbnYgPSBnZXRFTlYoKVxuICAgICAgICB9ID0gb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgICAgICAgIFwiaW5pdFwiOiBbXSxcbiAgICAgICAgICAgIFwibG9hZGVkXCI6IFtdLFxuICAgICAgICAgICAgXCJmbHVzaENoYW5nZXNcIjogW10sXG4gICAgICAgICAgICBcImNsb3NlXCI6IFtdLFxuICAgICAgICAgICAgXCJjaGFuZ2VzXCI6IFtdLFxuICAgICAgICAgICAgXCJ3YXJuaW5nXCI6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIGFsbG93IHVzZXJzIHRvIGluamVjdCB0aGVpciBvd24gY29tcGFyYXRvcnNcbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvck1hcCkge1xuICAgICAgICAgICAgZm9yIChsZXQgYyBpbiBvcHRpb25zLmNvbXBhcmF0b3JNYXApIHtcbiAgICAgICAgICAgICAgICBfY29tcGFyYXRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBDb21wYXJhdG9yTWFwICovIFwiYVwiXVtjXSA9IG9wdGlvbnMuY29tcGFyYXRvck1hcFtjXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyB1c2VycyB0byByZWdpc3RlciB0aGVpciBvd24gcmFuZ2VkSW5kZXggZmFjdG9yeSBmdW5jdGlvbnNcbiAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2VkSW5kZXhGYWN0b3J5TWFwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByaWYgaW4gb3B0aW9ucy5yYW5nZWRJbmRleEZhY3RvcnlNYXApIHtcbiAgICAgICAgICAgICAgICBfcmFuZ2VkX2luZGV4ZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBSYW5nZWRJbmRleEZhY3RvcnlNYXAgKi8gXCJhXCJdW3JpZl0gPSBvcHRpb25zLnJhbmdlZEluZGV4RmFjdG9yeU1hcFtyaWZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IHVzZXJzIHRvIHJlZ2lzdGVyIHRoZWlyIG93biBMb2tpT3BlcmF0b3JQYWNrYWdlcyBvciBpbmplY3QgZnVuY3Rpb25hbGl0eSB3aXRoaW4gZXhpc3Rpbmcgb25lc1xuICAgICAgICBpZiAob3B0aW9ucy5sb2tpT3BlcmF0b3JQYWNrYWdlTWFwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsb3AgaW4gb3B0aW9ucy5sb2tpT3BlcmF0b3JQYWNrYWdlTWFwKSB7XG4gICAgICAgICAgICAgICAgX29wZXJhdG9yX3BhY2thZ2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogTG9raU9wZXJhdG9yUGFja2FnZU1hcCAqLyBcImFcIl1bbG9wXSA9IG9wdGlvbnMubG9raU9wZXJhdG9yUGFja2FnZU1hcFtsb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub24oXCJpbml0XCIsIHRoaXMuY2xlYXJDaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY29uZmlndXJlcyBvcHRpb25zIHJlbGF0ZWQgdG8gZGF0YWJhc2UgcGVyc2lzdGVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xva2kuUGVyc2lzdGVuY2VPcHRpb25zfSBbb3B0aW9ucz17fV0gLSBvcHRpb25zXG4gICAgICogQHBhcmFtIHthZGFwdGVyfSBbb3B0aW9ucy5hZGFwdGVyPWF1dG9dIC0gYW4gaW5zdGFuY2Ugb2YgYSBsb2tpIHBlcnNpc3RlbmNlIGFkYXB0ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9zYXZlPWZhbHNlXSAtIGVuYWJsZXMgYXV0b3NhdmVcbiAgICAgKiBAcGFyYW0ge2ludH0gW29wdGlvbnMuYXV0b3NhdmVJbnRlcnZhbD01MDAwXSAtIHRpbWUgaW50ZXJ2YWwgKGluIG1pbGxpc2Vjb25kcykgYmV0d2VlbiBzYXZlcyAoaWYgZGlydHkpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvbG9hZD1mYWxzZV0gLSBlbmFibGVzIGF1dG9sb2FkIG9uIGxva2kgaW5zdGFudGlhdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmluZmxhdGUgLSBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byBsb2FkRGF0YWJhc2UgaWYgYXV0b2xvYWQgZW5hYmxlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGhyb3R0bGVkU2F2ZXM9dHJ1ZV0gLSBpZiB0cnVlLCBpdCBiYXRjaGVzIG11bHRpcGxlIGNhbGxzIHRvIHRvIHNhdmVEYXRhYmFzZSByZWR1Y2luZyBudW1iZXIgb2ZcbiAgICAgKiAgIGRpc2sgSS9PIG9wZXJhdGlvbnMgYW5kIGd1YXJhbnRlZWluZyBwcm9wZXIgc2VyaWFsaXphdGlvbiBvZiB0aGUgY2FsbHMuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0xva2kuUGVyc2lzdGVuY2VNZXRob2R9IG9wdGlvbnMucGVyc2lzdGVuY2VNZXRob2QgLSBhIHBlcnNpc3RlbmNlIG1ldGhvZCB3aGljaCBzaG91bGQgYmUgdXNlZCAoRlNfU1RPUkFHRSwgTE9DQUxfU1RPUkFHRS4uLilcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYW5kIChpZiBlbmFibGVkKSBhdXRvbG9hZGluZyB0aGUgZGF0YWJhc2VcbiAgICAgKi9cbiAgICBpbml0aWFsaXplUGVyc2lzdGVuY2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBsb2FkZWQgPSB0aGlzLl9hdXRvc2F2ZURpc2FibGUoKTtcbiAgICAgICAgKHtcbiAgICAgICAgICAgIGF1dG9zYXZlOiB0aGlzLl9hdXRvc2F2ZSA9IGZhbHNlLFxuICAgICAgICAgICAgYXV0b3NhdmVJbnRlcnZhbDogdGhpcy5fYXV0b3NhdmVJbnRlcnZhbCA9IDUwMDAsXG4gICAgICAgICAgICBwZXJzaXN0ZW5jZU1ldGhvZDogdGhpcy5fcGVyc2lzdGVuY2VNZXRob2QsXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvL2luZmxhdGU6IHRoaXMub3B0aW9ucy5pbmZsYXRlLFxuICAgICAgICAgICAgdGhyb3R0bGVkU2F2ZXM6IHRoaXMuX3Rocm90dGxlZFNhdmVzID0gdHJ1ZVxuICAgICAgICB9ID0gb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IERFRkFVTFRfUEVSU0lTVEVOQ0UgPSB7XG4gICAgICAgICAgICBcIk5PREVKU1wiOiBbXCJmcy1zdG9yYWdlXCJdLFxuICAgICAgICAgICAgXCJCUk9XU0VSXCI6IFtcImxvY2FsLXN0b3JhZ2VcIiwgXCJpbmRleGVkLXN0b3JhZ2VcIl0sXG4gICAgICAgICAgICBcIkNPUkRPVkFcIjogW1wibG9jYWwtc3RvcmFnZVwiLCBcImluZGV4ZWQtc3RvcmFnZVwiXSxcbiAgICAgICAgICAgIFwiTUVNT1JZXCI6IFtcIm1lbW9yeS1zdG9yYWdlXCJdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IFBFUlNJU1RFTkNFX01FVEhPRFMgPSB7XG4gICAgICAgICAgICBcImZzLXN0b3JhZ2VcIjogX2NvbW1vbl9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBQTFVHSU5TICovIFwiYVwiXVtcIkZTU3RvcmFnZVwiXSxcbiAgICAgICAgICAgIFwibG9jYWwtc3RvcmFnZVwiOiBfY29tbW9uX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIFBMVUdJTlMgKi8gXCJhXCJdW1wiTG9jYWxTdG9yYWdlXCJdLFxuICAgICAgICAgICAgXCJpbmRleGVkLXN0b3JhZ2VcIjogX2NvbW1vbl9wbHVnaW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBQTFVHSU5TICovIFwiYVwiXVtcIkluZGV4ZWRTdG9yYWdlXCJdLFxuICAgICAgICAgICAgXCJtZW1vcnktc3RvcmFnZVwiOiBfY29tbW9uX3BsdWdpbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIFBMVUdJTlMgKi8gXCJhXCJdW1wiTWVtb3J5U3RvcmFnZVwiXVxuICAgICAgICB9O1xuICAgICAgICAvLyBwcm9jZXNzIHRoZSBvcHRpb25zXG4gICAgICAgIGlmICh0aGlzLl9wZXJzaXN0ZW5jZU1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIG1ldGhvZCBpcyBrbm93blxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoUEVSU0lTVEVOQ0VfTUVUSE9EU1t0aGlzLl9wZXJzaXN0ZW5jZU1ldGhvZF0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZXJzaXN0ZW5jZUFkYXB0ZXIgPSBuZXcgKFBFUlNJU1RFTkNFX01FVEhPRFNbdGhpcy5fcGVyc2lzdGVuY2VNZXRob2RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBwZXJzaXN0ZW5jZSBtZXRob2QuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHVzZXIgcGFzc2VzIGFkYXB0ZXIsIHNldCBwZXJzaXN0ZW5jZSBtb2RlIHRvIGFkYXB0ZXIgYW5kIHJldGFpbiBwZXJzaXN0ZW5jZSBhZGFwdGVyIGluc3RhbmNlXG4gICAgICAgIGlmIChvcHRpb25zLmFkYXB0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VNZXRob2QgPSBcImFkYXB0ZXJcIjtcbiAgICAgICAgICAgIHRoaXMuX3BlcnNpc3RlbmNlQWRhcHRlciA9IG9wdGlvbnMuYWRhcHRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBieSBub3cgdGhlcmUgaXMgbm8gYWRhcHRlciBzcGVjaWZpZWQgYnkgdXNlciBub3IgZGVyaXZlZCBmcm9tIHBlcnNpc3RlbmNlTWV0aG9kOiB1c2Ugc2Vuc2libGUgZGVmYXVsdHNcbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbmNlQWRhcHRlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHBvc3NpYmxlUGVyc2lzdGVuY2VNZXRob2RzID0gREVGQVVMVF9QRVJTSVNURU5DRVt0aGlzLl9lbnZdO1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUGVyc2lzdGVuY2VNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NzaWJsZVBlcnNpc3RlbmNlTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUEVSU0lTVEVOQ0VfTUVUSE9EU1twb3NzaWJsZVBlcnNpc3RlbmNlTWV0aG9kc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlcnNpc3RlbmNlTWV0aG9kID0gcG9zc2libGVQZXJzaXN0ZW5jZU1ldGhvZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZXJzaXN0ZW5jZUFkYXB0ZXIgPSBuZXcgKFBFUlNJU1RFTkNFX01FVEhPRFNbcG9zc2libGVQZXJzaXN0ZW5jZU1ldGhvZHNbaV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZXkgd2FudCB0byBsb2FkIGRhdGFiYXNlIG9uIGxva2kgaW5zdGFudGlhdGlvbiwgbm93IGlzIGEgZ29vZCB0aW1lIHRvIGxvYWQuLi4gYWZ0ZXIgYWRhcHRlciBzZXQgYW5kIGJlZm9yZVxuICAgICAgICAvLyBwb3NzaWJsZSBhdXRvc2F2ZSBpbml0aWF0aW9uXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9sb2FkKSB7XG4gICAgICAgICAgICBsb2FkZWQgPSBsb2FkZWQudGhlbigoKSA9PiB0aGlzLl9sb2FkRGF0YWJhc2Uob3B0aW9ucy5pbmZsYXRlLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRlZC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2F1dG9zYXZlRW5hYmxlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgJ3RoaXMnIGRhdGFiYXNlIGludG8gYSBuZXcgTG9raSBpbnN0YW5jZS4gT2JqZWN0IHJlZmVyZW5jZXMgYXJlIHNoYXJlZCB0byBtYWtlIGxpZ2h0d2VpZ2h0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5yZW1vdmVOb25TZXJpYWxpemFibGUgLSBudWxscyBwcm9wZXJ0aWVzIG5vdCBzYWZlIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGNvcHkob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlQ29weSA9IG5ldyBMb2tpKHRoaXMuZmlsZW5hbWUsIHsgZW52OiB0aGlzLl9lbnYgfSk7XG4gICAgICAgIC8vIGN1cnJlbnRseSBpbnZlcnRpbmcgYW5kIGxldHRpbmcgbG9hZEpTT05PYmplY3QgZG8gbW9zdCBvZiB0aGUgd29ya1xuICAgICAgICBkYXRhYmFzZUNvcHkubG9hZEpTT05PYmplY3QodGhpcywge1xuICAgICAgICAgICAgcmV0YWluRGlydHlGbGFnczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2luY2Ugb3VyIHRvSlNPTiBpcyBub3QgaW52b2tlZCBmb3IgcmVmZXJlbmNlIGRhdGFiYXNlIGFkYXB0ZXJzLCB0aGlzIHdpbGwgbGV0IHVzIG1pbWljXG4gICAgICAgIGlmIChvcHRpb25zLnJlbW92ZU5vblNlcmlhbGl6YWJsZSkge1xuICAgICAgICAgICAgZGF0YWJhc2VDb3B5Ll9wZXJzaXN0ZW5jZUFkYXB0ZXIgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZGF0YWJhc2VDb3B5Ll9jb2xsZWN0aW9ucy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VDb3B5Ll9jb2xsZWN0aW9uc1tpZHhdLl9jb25zdHJhaW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VDb3B5Ll9jb2xsZWN0aW9uc1tpZHhdLl90dGwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhYmFzZUNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb2xsZWN0aW9uIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIG5hbWUgb2YgY29sbGVjdGlvbiB0byBhZGRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIC0gb3B0aW9ucyB0byBjb25maWd1cmUgY29sbGVjdGlvbiB3aXRoLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnVuaXF1ZT1bXV0gLSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0byBkZWZpbmUgdW5pcXVlIGNvbnN0cmFpbnRzIGZvclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmV4YWN0PVtdXSAtIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRvIGRlZmluZSBleGFjdCBjb25zdHJhaW50cyBmb3JcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5pbmRpY2VzPVtdXSAtIGFycmF5IHByb3BlcnR5IG5hbWVzIHRvIGRlZmluZSBiaW5hcnkgaW5kZXhlcyBmb3JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFzeW5jTGlzdGVuZXJzPWZhbHNlXSAtIHdoZXRoZXIgbGlzdGVuZXJzIGFyZSBjYWxsZWQgYXN5bmNocm9ub3VzbHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRpc2FibGVNZXRhPWZhbHNlXSAtIHNldCB0byB0cnVlIHRvIGRpc2FibGUgbWV0YSBwcm9wZXJ0eSBvbiBkb2N1bWVudHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRpc2FibGVDaGFuZ2VzQXBpPXRydWVdIC0gc2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBDaGFuZ2VzIEFwaVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZURlbHRhQ2hhbmdlc0FwaT10cnVlXSAtIHNldCB0byBmYWxzZSB0byBlbmFibGUgRGVsdGEgQ2hhbmdlcyBBUEkgKHJlcXVpcmVzIENoYW5nZXMgQVBJLCBmb3JjZXMgY2xvbmluZylcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb25lPWZhbHNlXSAtIHNwZWNpZnkgd2hldGhlciBpbnNlcnRzIGFuZCBxdWVyaWVzIGNsb25lIHRvL2Zyb20gdXNlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbG9uZU1ldGhvZD1DbG9uZU1ldGhvZC5ERUVQXSAtIHRoZSBjbG9uZSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHRsPV0gLSBhZ2Ugb2YgZG9jdW1lbnQgKGluIG1zLikgYmVmb3JlIGRvY3VtZW50IGlzIGNvbnNpZGVyZWQgYWdlZC9zdGFsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50dGxJbnRlcnZhbD1dIC0gdGltZSBpbnRlcnZhbCBmb3IgY2xlYXJpbmcgb3V0ICdhZ2VkJyBkb2N1bWVudHM7IG5vdCBzZXQgYnkgZGVmYXVsdFxuICAgICAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufSBhIHJlZmVyZW5jZSB0byB0aGUgY29sbGVjdGlvbiB3aGljaCB3YXMganVzdCBhZGRlZFxuICAgICAqL1xuICAgIGFkZENvbGxlY3Rpb24obmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIFJldHVybiBhbiBleGlzdGluZyBjb2xsZWN0aW9uIGlmIGEgY29sbGVjdGlvbiB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uc1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb25zW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIG90aGVyd2lzZS5cbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IG5ldyBfY29sbGVjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIENvbGxlY3Rpb24gKi8gXCJhXCJdKG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9jb2xsZWN0aW9ucy5wdXNoKGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgbG9hZENvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoIWNvbGxlY3Rpb24ubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sbGVjdGlvbiBtdXN0IGhhdmUgYSBuYW1lIHByb3BlcnR5IHRvIGJlIGxvYWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb2xsZWN0aW9ucy5wdXNoKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgcmVmZXJlbmNlIHRvIGEgY29sbGVjdGlvbiBieSBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbmFtZSBvZiBjb2xsZWN0aW9uIHRvIGxvb2sgdXBcbiAgICAgKiBAcmV0dXJucyB7Q29sbGVjdGlvbn0gUmVmZXJlbmNlIHRvIGNvbGxlY3Rpb24gaW4gZGF0YWJhc2UgYnkgdGhhdCBuYW1lLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldENvbGxlY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbnNbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBubyBzdWNoIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5lbWl0KFwid2FybmluZ1wiLCBcImNvbGxlY3Rpb24gXCIgKyBuYW1lICsgXCIgbm90IGZvdW5kXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuYW1lcyBhbiBleGlzdGluZyBsb2tpIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkTmFtZSAtIG5hbWUgb2YgY29sbGVjdGlvbiB0byByZW5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIG5ldyBuYW1lIG9mIGNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Q29sbGVjdGlvbn0gcmVmZXJlbmNlIHRvIHRoZSBuZXdseSByZW5hbWVkIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICByZW5hbWVDb2xsZWN0aW9uKG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29sbGVjdGlvbihvbGROYW1lKTtcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIGMubmFtZSA9IG5ld05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGxpc3RDb2xsZWN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgY29sbHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29sbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5fY29sbGVjdGlvbnNbaV0ubmFtZSxcbiAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5fY29sbGVjdGlvbnNbaV0uY291bnQoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29sbGVjdGlvbiBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbk5hbWUgLSBuYW1lIG9mIGNvbGxlY3Rpb24gdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlQ29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbnNbaV0ubmFtZSA9PT0gY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bXBjb2wgPSBuZXcgX2NvbGxlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBDb2xsZWN0aW9uICovIFwiYVwiXShjb2xsZWN0aW9uTmFtZSwge30pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cmNvbCA9IHRoaXMuX2NvbGxlY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjdXJjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cmNvbFtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIHRtcGNvbFtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJjb2xbcHJvcF0gPSB0bXBjb2xbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgZGF0YWJhc2UgdG8gYSBzdHJpbmcgd2hpY2ggY2FuIGJlIGxvYWRlZCB2aWEge0BsaW5rIExva2kjbG9hZEpTT059XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbG9raSBkYXRhYmFzZS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNlcmlhbGl6YXRpb25NZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zZXJpYWxpemF0aW9uTWV0aG9kID0gdGhpcy5fc2VyaWFsaXphdGlvbk1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMuc2VyaWFsaXphdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcIm5vcm1hbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgXCJwcmV0dHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcywgbnVsbCwgMik7XG4gICAgICAgICAgICBjYXNlIFwiZGVzdHJ1Y3R1cmVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVzdHJ1Y3R1cmVkKCk7IC8vIHVzZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsaWFzIG9mIHNlcmlhbGl6ZVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9lbnY6IHRoaXMuX2VudixcbiAgICAgICAgICAgIF9zZXJpYWxpemF0aW9uTWV0aG9kOiB0aGlzLl9zZXJpYWxpemF0aW9uTWV0aG9kLFxuICAgICAgICAgICAgX2F1dG9zYXZlOiB0aGlzLl9hdXRvc2F2ZSxcbiAgICAgICAgICAgIF9hdXRvc2F2ZUludGVydmFsOiB0aGlzLl9hdXRvc2F2ZUludGVydmFsLFxuICAgICAgICAgICAgX2NvbGxlY3Rpb25zOiB0aGlzLl9jb2xsZWN0aW9ucyxcbiAgICAgICAgICAgIGRhdGFiYXNlVmVyc2lvbjogdGhpcy5kYXRhYmFzZVZlcnNpb24sXG4gICAgICAgICAgICBlbmdpbmVWZXJzaW9uOiB0aGlzLmVuZ2luZVZlcnNpb24sXG4gICAgICAgICAgICBmaWxlbmFtZTogdGhpcy5maWxlbmFtZSxcbiAgICAgICAgICAgIF9wZXJzaXN0ZW5jZUFkYXB0ZXI6IHRoaXMuX3BlcnNpc3RlbmNlQWRhcHRlcixcbiAgICAgICAgICAgIF9wZXJzaXN0ZW5jZU1ldGhvZDogdGhpcy5fcGVyc2lzdGVuY2VNZXRob2QsXG4gICAgICAgICAgICBfdGhyb3R0bGVkU2F2ZXM6IHRoaXMuX3Rocm90dGxlZFNhdmVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFiYXNlIGxldmVsIGRlc3RydWN0dXJlZCBKU09OIHNlcmlhbGl6YXRpb24gcm91dGluZSB0byBhbGxvdyBhbHRlcm5hdGUgc2VyaWFsaXphdGlvbiBtZXRob2RzLlxuICAgICAqIEludGVybmFsbHksIExva2kgc3VwcG9ydHMgZGVzdHJ1Y3R1cmluZyB2aWEgbG9raSBcInNlcmlhbGl6YXRpb25NZXRob2QnIG9wdGlvbiBhbmRcbiAgICAgKiB0aGUgb3B0aW9uYWwgTG9raVBhcnRpdGlvbmluZ0FkYXB0ZXIgY2xhc3MuIEl0IGlzIGFsc28gYXZhaWxhYmxlIGlmIHlvdSB3aXNoIHRvIGRvXG4gICAgICogeW91ciBvd24gc3RydWN0dXJlZCBwZXJzaXN0ZW5jZSBvciBkYXRhIGV4Y2hhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvdXRwdXQgZm9ybWF0IG9wdGlvbnMgZm9yIHVzZSBleHRlcm5hbGx5IHRvIGxva2lcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhcnRpdGlvbmVkPWZhbHNlXSAtIHdoZXRoZXIgZGIgYW5kIGVhY2ggY29sbGVjdGlvbiBhcmUgc2VwYXJhdGVcbiAgICAgKiBAcGFyYW0ge2ludH0gb3B0aW9ucy5wYXJ0aXRpb24gLSBjYW4gYmUgdXNlZCB0byBvbmx5IG91dHB1dCBhbiBpbmRpdmlkdWFsIGNvbGxlY3Rpb24gb3IgZGIgKC0xKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVsaW1pdGVkPXRydWVdIC0gd2hldGhlciBzdWJpdGVtcyBhcmUgZGVsaW1pdGVkIG9yIHN1YmFycmF5c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRlbGltaXRlciAtIG92ZXJyaWRlIGRlZmF1bHQgZGVsaW1pdGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfEFycmF5fSBBIGN1c3RvbSwgcmVzdHJ1Y3R1cmVkIGFnZ3JlZ2F0aW9uIG9mIGluZGVwZW5kZW50IHNlcmlhbGl6YXRpb25zLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZURlc3RydWN0dXJlZChvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucGFydGl0aW9uZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJ0aXRpb25lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlbGltaXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlbGltaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVsaW1pdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gdGhpcy5fZGVzdHJ1Y3R1cmVEZWxpbWl0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gJ3BhcnRpdGlvbmVkJyBhbG9uZyB3aXRoICdwYXJ0aXRpb24nIG9mIDAgb3IgZ3JlYXRlciBpcyBhIHJlcXVlc3QgZm9yIHNpbmdsZSBjb2xsZWN0aW9uIHNlcmlhbGl6YXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnMucGFydGl0aW9uZWQgPT09IHRydWUgJiYgb3B0aW9ucy5wYXJ0aXRpb24gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnBhcnRpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVDb2xsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZWQ6IG9wdGlvbnMuZGVsaW1pdGVkLFxuICAgICAgICAgICAgICAgIGRlbGltaXRlcjogb3B0aW9ucy5kZWxpbWl0ZXIsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbkluZGV4OiBvcHRpb25zLnBhcnRpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IGp1c3QgYW4gaW5kaXZpZHVhbCBjb2xsZWN0aW9uLCBzbyB3ZSB3aWxsIG5lZWQgdG8gc2VyaWFsaXplIGRiIGNvbnRhaW5lciB2aWEgc2hhbGxvdyBjb3B5XG4gICAgICAgIGxldCBkYmNvcHkgPSBuZXcgTG9raSh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgZGJjb3B5LmxvYWRKU09OT2JqZWN0KHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBkYmNvcHkuX2NvbGxlY3Rpb25zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGRiY29weS5fY29sbGVjdGlvbnNbaWR4XS5fZGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIC1vbmx5LSB3YW50ZWQgdGhlIGRiIGNvbnRhaW5lciBwb3J0aW9uLCByZXR1cm4gaXQgbm93XG4gICAgICAgIGlmIChvcHRpb25zLnBhcnRpdGlvbmVkID09PSB0cnVlICYmIG9wdGlvbnMucGFydGl0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgLy8gc2luY2Ugd2UgYXJlIGRlY29uc3RydWN0aW5nLCBvdmVycmlkZSBzZXJpYWxpemF0aW9uTWV0aG9kIHRvIG5vcm1hbCBmb3IgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIGRiY29weS5zZXJpYWxpemUoe1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25NZXRob2Q6IFwibm9ybWFsXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgbXVzdCBiZSBkZWNvbnN0cnVjdGluZyB0aGUgZW50aXJlIGRhdGFiYXNlXG4gICAgICAgIC8vIHN0YXJ0IGJ5IHB1c2hpbmcgZGIgc2VyaWFsaXphdGlvbiBpbnRvIGZpcnN0IGFycmF5IGVsZW1lbnRcbiAgICAgICAgY29uc3QgcmVjb25zdHJ1Y3QgPSBbXTtcbiAgICAgICAgcmVjb25zdHJ1Y3QucHVzaChkYmNvcHkuc2VyaWFsaXplKHtcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25NZXRob2Q6IFwibm9ybWFsXCJcbiAgICAgICAgfSkpO1xuICAgICAgICBkYmNvcHkgPSBudWxsO1xuICAgICAgICAvLyBwdXNoIGNvbGxlY3Rpb24gZGF0YSBpbnRvIHN1YnNlcXVlbnQgZWxlbWVudHNcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5fY29sbGVjdGlvbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc2VyaWFsaXplQ29sbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgZGVsaW1pdGVkOiBvcHRpb25zLmRlbGltaXRlZCxcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXI6IG9wdGlvbnMuZGVsaW1pdGVyLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JbmRleDogaWR4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5EQSA6IE5vbi1EZWxpbWl0ZWQgQXJyYXkgOiBvbmUgaXRlcmFibGUgY29uY2F0ZW5hdGVkIGFycmF5IHdpdGggZW1wdHkgc3RyaW5nIGNvbGxlY3Rpb24gcGFydGl0aW9uc1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFydGl0aW9uZWQgPT09IGZhbHNlICYmIG9wdGlvbnMuZGVsaW1pdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImEgbm9uZGVsaW1pdGVkLCBub24gcGFydGl0aW9uZWQgY29sbGVjdGlvbiBzZXJpYWxpemF0aW9uIGRpZCBub3QgcmV0dXJuIGFuIGV4cGVjdGVkIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBcnJheS5jb25jYXQgd291bGQgcHJvYmFibHkgZHVwbGljYXRlIG1lbW9yeSBvdmVyaGVhZCBmb3IgY29weWluZyBzdHJpbmdzLlxuICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgY29weSBlYWNoIGluZGl2aWR1YWxseSwgYW5kIGNsZWFyIG9sZCB2YWx1ZSBhZnRlciBlYWNoIGNvcHkuXG4gICAgICAgICAgICAgICAgLy8gSG9wZWZ1bGx5IHRoaXMgd2lsbCBhbGxvdyBnLmMuIHRvIHJlZHVjZSBtZW1vcnkgcHJlc3N1cmUsIGlmIG5lZWRlZC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzaWR4ID0gMDsgc2lkeCA8IHJlc3VsdC5sZW5ndGg7IHNpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICByZWNvbnN0cnVjdC5wdXNoKHJlc3VsdFtzaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtzaWR4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY29uc3RydWN0LnB1c2goXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNvbnN0cnVjdC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgLyBwcmVzZW50IHJlc3VsdHMgYWNjb3JkaW5nIHRvIGZvdXIgY29tYmluYXRpb25zIDogRCwgREEsIE5EQSwgTkRBQVxuICAgICAgICBpZiAob3B0aW9ucy5wYXJ0aXRpb25lZCkge1xuICAgICAgICAgICAgLy8gREEgOiBEZWxpbWl0ZWQgQXJyYXkgb2Ygc3RyaW5ncyBbMF0gZGIgWzFdIGNvbGxlY3Rpb24gW25dIGNvbGxlY3Rpb24geyBwYXJ0aXRpb25lZDogdHJ1ZSwgZGVsaW1pdGVkOiB0cnVlIH1cbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3Igc2ltcGxlIGZ1dHVyZSBhZGFwdGF0aW9ucyBvZiBleGlzdGluZyBwZXJzaXN0ZW5jZSBhZGFwdGVycyB0byBzYXZlIGNvbGxlY3Rpb25zIHNlcGFyYXRlbHlcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlbGltaXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvbnN0cnVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5EQUEgOiBOb24tRGVsaW1pdGVkIEFycmF5IHdpdGggc3ViQXJyYXlzLiBkYiBhdCBbMF0gYW5kIGNvbGxlY3Rpb24gc3ViYXJyYXlzIGF0IFtuXSB7IHBhcnRpdGlvbmVkOiB0cnVlLCBkZWxpbWl0ZWQgOiBmYWxzZSB9XG4gICAgICAgICAgICAvLyBUaGlzIGZvcm1hdCBtaWdodCBiZSB0aGUgbW9zdCB2ZXJzYXRpbGUgZm9yICdyb2xsaW5nIHlvdXIgb3duJyBwYXJ0aXRpb25lZCBzeW5jIG9yIHNhdmUuXG4gICAgICAgICAgICAvLyBNZW1vcnkgb3ZlcmhlYWQgY2FuIGJlIHJlZHVjZWQgYnkgc3BlY2lmeWluZyBhIHNwZWNpZmljIHBhcnRpdGlvbiwgYnV0IGF0IHRoaXMgY29kZSBwYXRoIHRoZXkgZGlkIG5vdCwgc28gaXRzIGFsbC5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvbnN0cnVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEQgOiBvbmUgYmlnIERlbGltaXRlZCBzdHJpbmcgeyBwYXJ0aXRpb25lZDogZmFsc2UsIGRlbGltaXRlZCA6IHRydWUgfVxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbWV0aG9kIExva2kgd2lsbCB1c2UgaW50ZXJuYWxseSBpZiAnZGVzdHJ1Y3R1cmVkJy5cbiAgICAgICAgICAgIC8vIExpdHRsZSBtZW1vcnkgb3ZlcmhlYWQgaW1wcm92ZW1lbnRzIGJ1dCBkb2VzIG5vdCByZXF1aXJlIG11bHRpcGxlIGFzeW5jaHJvbm91cyBhZGFwdGVyIGNhbGwgc2NoZWR1bGluZ1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVsaW1pdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5kaWNhdGUgbm8gbW9yZSBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHJlY29uc3RydWN0LnB1c2goXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0LmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTkRBIDogTm9uLURlbGltaXRlZCBBcnJheSA6IG9uZSBpdGVyYWJsZSBhcnJheSB3aXRoIGVtcHR5IHN0cmluZyBjb2xsZWN0aW9uIHBhcnRpdGlvbnMgeyBwYXJ0aXRpb25lZDogZmFsc2UsIGRlbGltaXRlZDogZmFsc2UgfVxuICAgICAgICAgICAgLy8gVGhpcyBmb3JtYXQgbWlnaHQgYmUgYmVzdCBjYW5kaWRhdGUgZm9yIGN1c3RvbSBzeW5jaHJvbm91cyBzeW5jcyBvciBzYXZlc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5kaWNhdGUgbm8gbW9yZSBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHJlY29uc3RydWN0LnB1c2goXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gbGV2ZWwgdXRpbGl0eSBtZXRob2QgdG8gc2VyaWFsaXplIGEgY29sbGVjdGlvbiBpbiBhICdkZXN0cnVjdHVyZWQnIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB1c2VkIHRvIGRldGVybWluZSBvdXRwdXQgb2YgbWV0aG9kXG4gICAgICogQHBhcmFtIHtpbnR9IG9wdGlvbnMuZGVsaW1pdGVkIC0gd2hldGhlciB0byByZXR1cm4gc2luZ2xlIGRlbGltaXRlZCBzdHJpbmcgb3IgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5kZWxpbWl0ZXIgLSAob3B0aW9uYWwpIGlmIGRlbGltaXRlZCwgdGhpcyBpcyBkZWxpbWl0ZXIgdG8gdXNlXG4gICAgICogQHBhcmFtIHtpbnR9IG9wdGlvbnMuY29sbGVjdGlvbkluZGV4IC0gIHNwZWNpZnkgd2hpY2ggY29sbGVjdGlvbiB0byBzZXJpYWxpemUgZGF0YSBmb3JcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8YXJyYXl9IEEgY3VzdG9tLCByZXN0cnVjdHVyZWQgYWdncmVnYXRpb24gb2YgaW5kZXBlbmRlbnQgc2VyaWFsaXphdGlvbnMgZm9yIGEgc2luZ2xlIGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgc2VyaWFsaXplQ29sbGVjdGlvbihvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVsaW1pdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVsaW1pdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jb2xsZWN0aW9uSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VyaWFsaXplQ29sbGVjdGlvbiBjYWxsZWQgd2l0aG91dCAnY29sbGVjdGlvbkluZGV4JyBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jY291bnQgPSB0aGlzLl9jb2xsZWN0aW9uc1tvcHRpb25zLmNvbGxlY3Rpb25JbmRleF0uY291bnQoKTtcbiAgICAgICAgbGV0IHJlc3VsdGxpbmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGRvY2lkeCA9IDA7IGRvY2lkeCA8IGRvY2NvdW50OyBkb2NpZHgrKykge1xuICAgICAgICAgICAgcmVzdWx0bGluZXMucHVzaChKU09OLnN0cmluZ2lmeSh0aGlzLl9jb2xsZWN0aW9uc1tvcHRpb25zLmNvbGxlY3Rpb25JbmRleF0uX2RhdGFbZG9jaWR4XSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEQgYW5kIERBXG4gICAgICAgIGlmIChvcHRpb25zLmRlbGltaXRlZCkge1xuICAgICAgICAgICAgLy8gaW5kaWNhdGUgbm8gbW9yZSBkb2N1bWVudHMgaW4gY29sbGVjdGlvbiAodmlhIGVtcHR5IGRlbGltaXRlZCBzdHJpbmcpXG4gICAgICAgICAgICByZXN1bHRsaW5lcy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdGxpbmVzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTkRBQSBhbmQgTkRBXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0bGluZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YWJhc2UgbGV2ZWwgZGVzdHJ1Y3R1cmVkIEpTT04gZGVzZXJpYWxpemF0aW9uIHJvdXRpbmUgdG8gbWluaW1pemUgbWVtb3J5IG92ZXJoZWFkLlxuICAgICAqIEludGVybmFsbHksIExva2kgc3VwcG9ydHMgZGVzdHJ1Y3R1cmluZyB2aWEgbG9raSBcInNlcmlhbGl6YXRpb25NZXRob2QnIG9wdGlvbiBhbmRcbiAgICAgKiB0aGUgb3B0aW9uYWwgTG9raVBhcnRpdGlvbmluZ0FkYXB0ZXIgY2xhc3MuIEl0IGlzIGFsc28gYXZhaWxhYmxlIGlmIHlvdSB3aXNoIHRvIGRvXG4gICAgICogeW91ciBvd24gc3RydWN0dXJlZCBwZXJzaXN0ZW5jZSBvciBkYXRhIGV4Y2hhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IGRlc3RydWN0dXJlZFNvdXJjZSAtIGRlc3RydWN0dXJlZCBqc29uIG9yIGFycmF5IHRvIGRlc2VyaWFsaXplIGZyb21cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHNvdXJjZSBmb3JtYXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucGFydGl0aW9uZWQ9ZmFsc2VdIC0gd2hldGhlciBkYiBhbmQgZWFjaCBjb2xsZWN0aW9uIGFyZSBzZXBhcmF0ZVxuICAgICAqIEBwYXJhbSB7aW50fSBvcHRpb25zLnBhcnRpdGlvbiAtIGNhbiBiZSB1c2VkIHRvIGRlc2VyaWFsaXplIG9ubHkgYSBzaW5nbGUgcGFydGl0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWxpbWl0ZWQ9dHJ1ZV0gLSB3aGV0aGVyIHN1Yml0ZW1zIGFyZSBkZWxpbWl0ZWQgb3Igc3ViYXJyYXlzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZGVsaW1pdGVyIC0gb3ZlcnJpZGUgZGVmYXVsdCBkZWxpbWl0ZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8YXJyYXl9IEFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGVzZXJpYWxpemVkIGRhdGFiYXNlLCBub3QgeWV0IGFwcGxpZWQgdG8gJ3RoaXMnIGRiIG9yIGRvY3VtZW50IGFycmF5XG4gICAgICovXG4gICAgZGVzZXJpYWxpemVEZXN0cnVjdHVyZWQoZGVzdHJ1Y3R1cmVkU291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucGFydGl0aW9uZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJ0aXRpb25lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlbGltaXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlbGltaXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVsaW1pdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gdGhpcy5fZGVzdHJ1Y3R1cmVEZWxpbWl0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFydGl0aW9uZWRcbiAgICAgICAgLy8gREEgOiBEZWxpbWl0ZWQgQXJyYXkgb2Ygc3RyaW5ncyBbMF0gZGIgWzFdIGNvbGxlY3Rpb24gW25dIGNvbGxlY3Rpb24geyBwYXJ0aXRpb25lZDogdHJ1ZSwgZGVsaW1pdGVkOiB0cnVlIH1cbiAgICAgICAgLy8gTkRBQSA6IE5vbi1EZWxpbWl0ZWQgQXJyYXkgd2l0aCBzdWJBcnJheXMuIGRiIGF0IFswXSBhbmQgY29sbGVjdGlvbiBzdWJhcnJheXMgYXQgW25dIHsgcGFydGl0aW9uZWQ6IHRydWUsIGRlbGltaXRlZCA6IGZhbHNlIH1cbiAgICAgICAgLy8gLW9yLSBzaW5nbGUgcGFydGl0aW9uXG4gICAgICAgIGlmIChvcHRpb25zLnBhcnRpdGlvbmVkKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgc2luZ2xlIHBhcnRpdGlvblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFydGl0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkYiBvbmx5XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFydGl0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZXN0cnVjdHVyZWRTb3VyY2VbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY29sbGVjdGlvbiwgcmV0dXJuIGRvYyBhcnJheVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplQ29sbGVjdGlvbihkZXN0cnVjdHVyZWRTb3VyY2Vbb3B0aW9ucy5wYXJ0aXRpb24gKyAxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIHJlc3RvcmluZyBhbiBlbnRpcmUgcGFydGl0aW9uZWQgZGJcbiAgICAgICAgICAgIGNvbnN0IGNkYiA9IEpTT04ucGFyc2UoZGVzdHJ1Y3R1cmVkU291cmNlWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxDb3VudCA9IGNkYi5fY29sbGVjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sbEluZGV4ID0gMDsgY29sbEluZGV4IDwgY29sbENvdW50OyBjb2xsSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBlYWNoIGNvbGxlY3Rpb24gZG9jYXJyYXkgdG8gY29udGFpbmVyIGNvbGxlY3Rpb24gZGF0YSwgYWRkIDEgdG8gY29sbGVjdGlvbiBhcnJheSBpbmRleCBzaW5jZSBkYiBpcyBhdCAwXG4gICAgICAgICAgICAgICAgY2RiLl9jb2xsZWN0aW9uc1tjb2xsSW5kZXhdLl9kYXRhID0gdGhpcy5kZXNlcmlhbGl6ZUNvbGxlY3Rpb24oZGVzdHJ1Y3R1cmVkU291cmNlW2NvbGxJbmRleCArIDFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjZGI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9uLVBhcnRpdGlvbmVkXG4gICAgICAgIC8vIEQgOiBvbmUgYmlnIERlbGltaXRlZCBzdHJpbmcgeyBwYXJ0aXRpb25lZDogZmFsc2UsIGRlbGltaXRlZCA6IHRydWUgfVxuICAgICAgICAvLyBOREEgOiBOb24tRGVsaW1pdGVkIEFycmF5IDogb25lIGl0ZXJhYmxlIGFycmF5IHdpdGggZW1wdHkgc3RyaW5nIGNvbGxlY3Rpb24gcGFydGl0aW9ucyB7IHBhcnRpdGlvbmVkOiBmYWxzZSwgZGVsaW1pdGVkOiBmYWxzZSB9XG4gICAgICAgIGxldCB3b3JrYXJyYXkgPSBbXTtcbiAgICAgICAgLy8gRFxuICAgICAgICBpZiAob3B0aW9ucy5kZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHdvcmthcnJheSA9IGRlc3RydWN0dXJlZFNvdXJjZS5zcGxpdChvcHRpb25zLmRlbGltaXRlcik7XG4gICAgICAgICAgICBkZXN0cnVjdHVyZWRTb3VyY2UgPSBudWxsOyAvLyBsb3dlciBtZW1vcnkgcHJlc3N1cmVcbiAgICAgICAgICAgIGlmICh3b3JrYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTkRBXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd29ya2FycmF5ID0gZGVzdHJ1Y3R1cmVkU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IGxpbmUgaXMgZGF0YWJhc2UgYW5kIGNvbGxlY3Rpb24gc2hlbGxzXG4gICAgICAgIGNvbnN0IGNkYiA9IEpTT04ucGFyc2Uod29ya2FycmF5WzBdKTtcbiAgICAgICAgY29uc3QgY29sbENvdW50ID0gY2RiLl9jb2xsZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHdvcmthcnJheVswXSA9IG51bGw7XG4gICAgICAgIGxldCBjb2xsSW5kZXggPSAwO1xuICAgICAgICBsZXQgbGluZUluZGV4ID0gMTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaW5kaWNhdGVzIGVpdGhlciBlbmQgb2YgY29sbGVjdGlvbiBvciBlbmQgb2YgZmlsZVxuICAgICAgICAgICAgaWYgKHdvcmthcnJheVtsaW5lSW5kZXhdID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbW9yZSBjb2xsZWN0aW9ucyB0byBsb2FkIGludG8sIHdlIGFyZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKCsrY29sbEluZGV4ID4gY29sbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNkYi5fY29sbGVjdGlvbnNbY29sbEluZGV4XS5fZGF0YS5wdXNoKEpTT04ucGFyc2Uod29ya2FycmF5W2xpbmVJbmRleF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvd2VyIG1lbW9yeSBwcmVzc3VyZSBhbmQgYWR2YW5jZSBpdGVyYXRvclxuICAgICAgICAgICAgd29ya2FycmF5W2xpbmVJbmRleCsrXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNkYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBsZXZlbCB1dGlsaXR5IGZ1bmN0aW9uIHRvIGRlc2VyaWFsaXplcyBhIGRlc3RydWN0dXJlZCBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGRlc3RydWN0dXJlZFNvdXJjZSAtIGRlc3RydWN0dXJlZCByZXByZXNlbnRhdGlvbiBvZiBjb2xsZWN0aW9uIHRvIGluZmxhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHVzZWQgdG8gZGVzY3JpYmUgZm9ybWF0IG9mIGRlc3RydWN0dXJlZFNvdXJjZSBpbnB1dFxuICAgICAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5kZWxpbWl0ZWQ9ZmFsc2VdIC0gd2hldGhlciBzb3VyY2UgaXMgZGVsaW1pdGVkIHN0cmluZyBvciBhbiBhcnJheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRlbGltaXRlciAtIGlmIGRlbGltaXRlZCwgdGhpcyBpcyBkZWxpbWl0ZXIgdG8gdXNlIChpZiBvdGhlciB0aGFuIGRlZmF1bHQpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIGRvY3VtZW50cyB0byBhdHRhY2ggdG8gY29sbGVjdGlvbi5kYXRhLlxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplQ29sbGVjdGlvbihkZXN0cnVjdHVyZWRTb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAob3B0aW9ucy5wYXJ0aXRpb25lZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhcnRpdGlvbmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVsaW1pdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVsaW1pdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSB0aGlzLl9kZXN0cnVjdHVyZURlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd29ya2FycmF5ID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmRlbGltaXRlZCkge1xuICAgICAgICAgICAgd29ya2FycmF5ID0gZGVzdHJ1Y3R1cmVkU291cmNlLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgICAgICAgICAgIHdvcmthcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdvcmthcnJheSA9IGRlc3RydWN0dXJlZFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB3b3JrYXJyYXkubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgd29ya2FycmF5W2lkeF0gPSBKU09OLnBhcnNlKHdvcmthcnJheVtpZHhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29ya2FycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmZsYXRlcyBhIGxva2kgZGF0YWJhc2UgZnJvbSBhIHNlcmlhbGl6ZWQgSlNPTiBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpYWxpemVkRGIgLSBhIHNlcmlhbGl6ZWQgbG9raSBkYXRhYmFzZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGFwcGx5IG9yIG92ZXJyaWRlIGNvbGxlY3Rpb24gbGV2ZWwgc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucmV0YWluRGlydHlGbGFncyAtIHdoZXRoZXIgY29sbGVjdGlvbiBkaXJ0eSBmbGFncyB3aWxsIGJlIHByZXNlcnZlZFxuICAgICAqL1xuICAgIGxvYWRKU09OKHNlcmlhbGl6ZWREYiwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZGJPYmplY3Q7XG4gICAgICAgIGlmIChzZXJpYWxpemVkRGIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkYk9iamVjdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNpbmcgb3B0aW9uIGRlZmluZWQgaW4gaW5zdGFudGlhdGVkIGRiIG5vdCB3aGF0IHdhcyBpbiBzZXJpYWxpemVkIGRiXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3NlcmlhbGl6YXRpb25NZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibm9ybWFsXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInByZXR0eVwiOlxuICAgICAgICAgICAgICAgICAgICBkYk9iamVjdCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZERiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlc3RydWN0dXJlZFwiOlxuICAgICAgICAgICAgICAgICAgICBkYk9iamVjdCA9IHRoaXMuZGVzZXJpYWxpemVEZXN0cnVjdHVyZWQoc2VyaWFsaXplZERiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZGJPYmplY3QgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWREYik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZEpTT05PYmplY3QoZGJPYmplY3QsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBsb2FkSlNPTk9iamVjdChkYk9iamVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRiT2JqZWN0Ll9jb2xsZWN0aW9ucyA/IGRiT2JqZWN0Ll9jb2xsZWN0aW9ucy5sZW5ndGggOiAwO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZGJPYmplY3QuZmlsZW5hbWU7XG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25zLnB1c2goX2NvbGxlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBDb2xsZWN0aW9uICovIFwiYVwiXS5mcm9tSlNPTk9iamVjdChkYk9iamVjdC5fY29sbGVjdGlvbnNbaV0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB0aGUgY2xvc2UgZXZlbnQuIEluIGF1dG9zYXZlIHNjZW5hcmlvcywgaWYgdGhlIGRhdGFiYXNlIGlzIGRpcnR5LCB0aGlzIHdpbGwgc2F2ZSBhbmQgZGlzYWJsZSB0aW1lci5cbiAgICAgKiBEb2VzIG5vdCBhY3R1YWxseSBkZXN0cm95IHRoZSBkYi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBjbG9zaW5nIHRoZSBkYXRhYmFzZSBzdWNjZWVkZWRcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgLy8gZm9yIGF1dG9zYXZlIHNjZW5hcmlvcywgd2Ugd2lsbCBsZXQgY2xvc2UgcGVyZm9ybSBmaW5hbCBzYXZlIChpZiBkaXJ0eSlcbiAgICAgICAgLy8gRm9yIHdlYiB1c2UsIHlvdSBtaWdodCBjYWxsIGZyb20gd2luZG93Lm9uYmVmb3JldW5sb2FkIHRvIHNodXRkb3duIGRhdGFiYXNlLCBzYXZpbmcgcGVuZGluZyBjaGFuZ2VzXG4gICAgICAgIGlmICh0aGlzLl9hdXRvc2F2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9zYXZlRGlzYWJsZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdXRvc2F2ZURpcnR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZURhdGFiYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgfCBDaGFuZ2VzIEFQSSAgICAgICAgICAgICAgIHxcbiAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvKipcbiAgICAgKiBUaGUgQ2hhbmdlcyBBUEkgZW5hYmxlcyB0aGUgdHJhY2tpbmcgdGhlIGNoYW5nZXMgb2NjdXJyZWQgaW4gdGhlIGNvbGxlY3Rpb25zIHNpbmNlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlc3Npb24sXG4gICAgICogc28gaXQncyBwb3NzaWJsZSB0byBjcmVhdGUgYSBkaWZmZXJlbnRpYWwgZGF0YXNldCBmb3Igc3luY2hyb25pemF0aW9uIHB1cnBvc2VzIChwb3NzaWJseSB0byBhIHJlbW90ZSBkYilcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiAoQ2hhbmdlcyBBUEkpIDogdGFrZXMgYWxsIHRoZSBjaGFuZ2VzIHN0b3JlZCBpbiBlYWNoXG4gICAgICogY29sbGVjdGlvbiBhbmQgY3JlYXRlcyBhIHNpbmdsZSBhcnJheSBmb3IgdGhlIGVudGlyZSBkYXRhYmFzZS4gSWYgYW4gYXJyYXkgb2YgbmFtZXNcbiAgICAgKiBvZiBjb2xsZWN0aW9ucyBpcyBwYXNzZWQgdGhlbiBvbmx5IHRoZSBpbmNsdWRlZCBjb2xsZWN0aW9ucyB3aWxsIGJlIHRyYWNrZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXlPZkNvbGxlY3Rpb25OYW1lcz1dIC0gYXJyYXkgb2YgY29sbGVjdGlvbiBuYW1lcy4gTm8gYXJnIG1lYW5zIGFsbCBjb2xsZWN0aW9ucyBhcmUgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2YgY2hhbmdlc1xuICAgICAqIEBzZWUgcHJpdmF0ZSBtZXRob2QgX2NyZWF0ZUNoYW5nZSgpIGluIENvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUNoYW5nZXNOb3RpZmljYXRpb24oYXJyYXlPZkNvbGxlY3Rpb25OYW1lcykge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBjb25zdCBzZWxlY3RlZENvbGxlY3Rpb25zID0gYXJyYXlPZkNvbGxlY3Rpb25OYW1lc1xuICAgICAgICAgICAgfHwgdGhpcy5fY29sbGVjdGlvbnMubWFwKChjb2xsKSA9PiBjb2xsLm5hbWUpO1xuICAgICAgICB0aGlzLl9jb2xsZWN0aW9ucy5mb3JFYWNoKChjb2xsKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRDb2xsZWN0aW9ucy5pbmRleE9mKGNvbGwubmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29uY2F0KGNvbGwuZ2V0Q2hhbmdlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAoQ2hhbmdlcyBBUEkpIC0gc3RyaW5naWZ5IGNoYW5nZXMgZm9yIG5ldHdvcmsgdHJhbnNtaXNzaW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaGFuZ2VzXG4gICAgICovXG4gICAgc2VyaWFsaXplQ2hhbmdlcyhjb2xsZWN0aW9uTmFtZXNBcnJheSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5nZW5lcmF0ZUNoYW5nZXNOb3RpZmljYXRpb24oY29sbGVjdGlvbk5hbWVzQXJyYXkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogKENoYW5nZXMgQVBJKSA6IGNsZWFycyBhbGwgdGhlIGNoYW5nZXMgaW4gYWxsIGNvbGxlY3Rpb25zLlxuICAgICAqL1xuICAgIGNsZWFyQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbnMuZm9yRWFjaCgoY29sbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbGwuZmx1c2hDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29sbC5mbHVzaENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgZm9yIHRocm90dGxlZFNhdmVzIHRvIGNvbXBsZXRlIGFuZCBpbnZva2UgeW91ciBjYWxsYmFjayB3aGVuIGRyYWluZWQgb3IgZHVyYXRpb24gaXMgbWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlY3Vyc2l2ZVdhaXQ9dHJ1ZV0gLSBpZiBhZnRlciBxdWV1ZSBpcyBkcmFpbmVkLCBhbm90aGVyIHNhdmUgd2FzIGtpY2tlZCBvZmYsIHdhaXQgZm9yIGl0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWN1cnNpdmVXYWl0TGltaXQ9ZmFsc2VdIC0gbGltaXQgb3VyIHJlY3Vyc2l2ZSB3YWl0aW5nIHRvIGEgZHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVjdXJzaXZlV2FpdExpbWl0RHVyYXRpb249MjAwMF0gLSBjdXRvZmYgaW4gbXMgdG8gc3RvcCByZWN1cnNpdmVseSByZS1kcmFpbmluZ1xuICAgICAqIEBwYXJhbSB7RGF0ZX0gW29wdGlvbnMuc3RhcnRlZD1ub3coKV0gLSB0aGUgc3RhcnQgdGltZSBvZiB0aGUgcmVjdXJzaXZlIHdhaXQgZHVyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBzYXZlIHF1ZXVlIGlzIGRyYWluZWQsIGl0IGlzIHBhc3NlZCBhIHN1Y2VzcyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICB0aHJvdHRsZWRTYXZlRHJhaW4ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIGlmICghdGhpcy5fdGhyb3R0bGVkU2F2ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yZWN1cnNpdmVXYWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVjdXJzaXZlV2FpdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmVjdXJzaXZlV2FpdExpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVjdXJzaXZlV2FpdExpbWl0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmVjdXJzaXZlV2FpdExpbWl0RHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZWN1cnNpdmVXYWl0TGltaXREdXJhdGlvbiA9IDIwMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN0YXJ0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHNhdmUgaXMgcGVuZGluZ1xuICAgICAgICBpZiAodGhpcy5fdGhyb3R0bGVkU2F2ZXMgJiYgdGhpcy5fdGhyb3R0bGVkU2F2ZVJ1bm5pbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIHdhbnQgdG8gd2FpdCB1bnRpbCB3ZSBhcmUgaW4gYSBzdGF0ZSB3aGVyZSB0aGVyZSBhcmUgbm8gcGVuZGluZyBzYXZlcyBhdCBhbGxcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlY3Vyc2l2ZVdhaXQpIHtcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSB0aGUgZm9sbG93aW5nIG1ldGEgY2FsbGJhY2sgZm9yIHdoZW4gaXQgY29tcGxldGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShQcm9taXNlLmFsbChbdGhpcy5fdGhyb3R0bGVkU2F2ZVJ1bm5pbmcsIHRoaXMuX3Rocm90dGxlZFNhdmVQZW5kaW5nXSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGhyb3R0bGVkU2F2ZVJ1bm5pbmcgIT09IG51bGwgfHwgdGhpcy5fdGhyb3R0bGVkU2F2ZVBlbmRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlY3Vyc2l2ZVdhaXRMaW1pdCAmJiAobm93IC0gb3B0aW9ucy5zdGFydGVkLmdldFRpbWUoKSA+IG9wdGlvbnMucmVjdXJzaXZlV2FpdExpbWl0RHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRocm90dGxlZFNhdmVEcmFpbihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ganVzdCBub3RpZnkgd2hlbiBjdXJyZW50IHF1ZXVlIGlzIGRlcGxldGVkXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Rocm90dGxlZFNhdmVSdW5uaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBubyBzYXZlIHBlbmRpbmcsIGp1c3QgY2FsbGJhY2tcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbG9hZCBsb2dpYywgZGVjb3VwbGVkIGZyb20gdGhyb3R0bGluZy9jb250ZW50aW9uIGxvZ2ljXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGFuIG9iamVjdCBjb250YWluaW5nIGluZmxhdGlvbiBvcHRpb25zIGZvciBlYWNoIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZV9ub3RfZm91bmQgLSBkb2VzIG5vdCByYWlzZSBhbiBlcnJvciBpZiBkYXRhYmFzZSBpcyBub3QgZm91bmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIGRhdGFiYXNlIGlzIGxvYWRlZFxuICAgICAqL1xuICAgIF9sb2FkRGF0YWJhc2Uob3B0aW9ucyA9IHt9LCBpZ25vcmVfbm90X2ZvdW5kID0gZmFsc2UpIHtcbiAgICAgICAgLy8gdGhlIHBlcnNpc3RlbmNlQWRhcHRlciBzaG91bGQgYmUgcHJlc2VudCBpZiBhbGwgaXMgb2ssIGJ1dCBjaGVjayB0byBiZSBzdXJlLlxuICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVuY2VBZGFwdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwicGVyc2lzdGVuY2VBZGFwdGVyIG5vdCBjb25maWd1cmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3BlcnNpc3RlbmNlQWRhcHRlci5sb2FkRGF0YWJhc2UodGhpcy5maWxlbmFtZSkpXG4gICAgICAgICAgICAudGhlbigoZGJTdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGRiU3RyaW5nKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEpTT04oZGJTdHJpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImxvYWRcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgYWRhcHRlciBoYXMgcmV0dXJuZWQgYSBqcyBvYmplY3QgKG90aGVyIHRoYW4gbnVsbCBvciBlcnJvcikgYXR0ZW1wdCB0byBsb2FkIGZyb20gSlNPTiBvYmplY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZGJTdHJpbmcpID09PSBcIm9iamVjdFwiICYmIGRiU3RyaW5nICE9PSBudWxsICYmICEoZGJTdHJpbmcgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRKU09OT2JqZWN0KGRiU3RyaW5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJsb2FkXCIsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGJTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHBlcnNpc3RlbmNlIGFkYXB0ZXIgZGlkIG5vdCBsb2FkIGEgc2VyaWFsaXplZCBEQiBzdHJpbmcgb3Igb2JqZWN0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpZ25vcmVfbm90X2ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2Ugbm90IGZvdW5kLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbWFudWFsbHkgbG9hZGluZyBmcm9tIGFuIGFkYXB0ZXIgc3RvcmFnZSAoc3VjaCBhcyBmcy1zdG9yYWdlKVxuICAgICAqICAgIFRoaXMgbWV0aG9kIHV0aWxpemVzIGxva2kgY29uZmlndXJhdGlvbiBvcHRpb25zIChpZiBwcm92aWRlZCkgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICogICAgcGVyc2lzdGVuY2UgbWV0aG9kIHRvIHVzZSwgb3IgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIChpZiBjb25maWd1cmF0aW9uIHdhcyBub3QgcHJvdmlkZWQpLlxuICAgICAqICAgIFRvIGF2b2lkIGNvbnRlbnRpb24gd2l0aCBhbnkgdGhyb3R0bGVkU2F2ZXMsIHdlIHdpbGwgZHJhaW4gdGhlIHNhdmUgcXVldWUgZmlyc3QuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIGNvbmZpZ3VyZWQgd2l0aCBhdXRvc2F2ZSwgeW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgeW91cnNlbGYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIC0gaWYgdGhyb3R0bGluZyBzYXZlcyBhbmQgbG9hZHMsIHRoaXMgY29udHJvbHMgaG93IHdlIGRyYWluIHNhdmUgcXVldWUgYmVmb3JlIGxvYWRpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlY3Vyc2l2ZVdhaXQ9dHJ1ZV0gd2FpdCByZWN1cnNpdmVseSB1bnRpbCBubyBzYXZlcyBhcmUgcXVldWVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWN1cnNpdmVXYWl0TGltaXQ9ZmFsc2VdIGxpbWl0IG91ciByZWN1cnNpdmUgd2FpdGluZyB0byBhIGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlY3Vyc2l2ZVdhaXRMaW1pdERlbGF5PTIwMDBdIGN1dG9mZiBpbiBtcyB0byBzdG9wIHJlY3Vyc2l2ZWx5IHJlLWRyYWluaW5nXG4gICAgICogQHBhcmFtIHtEYXRlfSBbb3B0aW9ucy5zdGFydGVkPW5vdygpXSAtIHRoZSBzdGFydCB0aW1lIG9mIHRoZSByZWN1cnNpdmUgd2FpdCBkdXJhdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgZGF0YWJhc2UgaXMgbG9hZGVkXG4gICAgICovXG4gICAgbG9hZERhdGFiYXNlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBpZiB0aHJvdHRsaW5nIGRpc2FibGVkLCBqdXN0IGNhbGwgaW50ZXJuYWxcbiAgICAgICAgaWYgKCF0aGlzLl90aHJvdHRsZWRTYXZlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWREYXRhYmFzZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cnkgdG8gZHJhaW4gYW55IHBlbmRpbmcgc2F2ZXMgaW4gdGhlIHF1ZXVlIHRvIGxvY2sgaXQgZm9yIGxvYWRpbmdcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyb3R0bGVkU2F2ZURyYWluKG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gcGF1c2UvdGhyb3R0bGUgc2F2aW5nIHVudGlsIGxvYWRpbmcgaXMgZG9uZVxuICAgICAgICAgICAgdGhpcy5fdGhyb3R0bGVkU2F2ZVJ1bm5pbmcgPSB0aGlzLl9sb2FkRGF0YWJhc2Uob3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbm93IHRoYXQgd2UgYXJlIGZpbmlzaGVkIGxvYWRpbmcsIGlmIG5vIHNhdmVzIHdlcmUgdGhyb3R0bGVkLCBkaXNhYmxlIGZsYWdcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvdHRsZWRTYXZlUnVubmluZyA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJvdHRsZWRTYXZlUnVubmluZztcbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhdXNlIHNhdmUgdGhyb3R0bGluZyBsb25nIGVub3VnaCB0byByZWFkIGRhdGFiYXNlXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NhdmVEYXRhYmFzZSgpIHtcbiAgICAgICAgLy8gdGhlIHBlcnNpc3RlbmNlQWRhcHRlciBzaG91bGQgYmUgcHJlc2VudCBpZiBhbGwgaXMgb2ssIGJ1dCBjaGVjayB0byBiZSBzdXJlLlxuICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVuY2VBZGFwdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwicGVyc2lzdGVuY2VBZGFwdGVyIG5vdCBjb25maWd1cmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgYWRhcHRlciBpcyByZXF1ZXN0aW5nIChhbmQgc3VwcG9ydHMpIGEgJ3JlZmVyZW5jZScgbW9kZSBleHBvcnRcbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbmNlQWRhcHRlci5tb2RlID09PSBcInJlZmVyZW5jZVwiICYmIHR5cGVvZiB0aGlzLl9wZXJzaXN0ZW5jZUFkYXB0ZXIuZXhwb3J0RGF0YWJhc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gZmlsZW5hbWUgbWF5IHNlZW0gcmVkdW5kYW50IGJ1dCBsb2FkRGF0YWJhc2Ugd2lsbCBuZWVkIHRvIGV4cGVjdCB0aGlzIHNhbWUgZmlsZW5hbWVcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcGVyc2lzdGVuY2VBZGFwdGVyLmV4cG9ydERhdGFiYXNlKHRoaXMuZmlsZW5hbWUsIHRoaXMuY29weSh7IHJlbW92ZU5vblNlcmlhbGl6YWJsZTogdHJ1ZSB9KSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9zYXZlQ2xlYXJGbGFncygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInNhdmVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UganVzdCBwYXNzIHRoZSBzZXJpYWxpemVkIGRhdGFiYXNlIHRvIGFkYXB0ZXJcbiAgICAgICAgLy8gcGVyc2lzdGVuY2VBZGFwdGVyIG1pZ2h0IGJlIGFzeW5jaHJvbm91cywgc28gd2UgbXVzdCBjbGVhciBgZGlydHlgIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIG9yIGF1dG9zYXZlIHdvbid0IHdvcmsgaWYgYW4gdXBkYXRlIG9jY3VycyBiZXR3ZWVuIGhlcmUgYW5kIHRoZSBjYWxsYmFja1xuICAgICAgICB0aGlzLl9hdXRvc2F2ZUNsZWFyRmxhZ3MoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9wZXJzaXN0ZW5jZUFkYXB0ZXIuc2F2ZURhdGFiYXNlKHRoaXMuZmlsZW5hbWUsIHRoaXMuc2VyaWFsaXplKCkpKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwic2F2ZVwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbWFudWFsbHkgc2F2aW5nIHRvIGFuIGFkYXB0ZXIgc3RvcmFnZSAoc3VjaCBhcyBmcy1zdG9yYWdlKVxuICAgICAqICAgIFRoaXMgbWV0aG9kIHV0aWxpemVzIGxva2kgY29uZmlndXJhdGlvbiBvcHRpb25zIChpZiBwcm92aWRlZCkgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICogICAgcGVyc2lzdGVuY2UgbWV0aG9kIHRvIHVzZSwgb3IgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIChpZiBjb25maWd1cmF0aW9uIHdhcyBub3QgcHJvdmlkZWQpLlxuICAgICAqXG4gICAgICogSWYgeW91IGFyZSBjb25maWd1cmVkIHdpdGggYXV0b3NhdmUsIHlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIHlvdXJzZWxmLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBkYXRhYmFzZSBpcyBwZXJzaXN0ZWRcbiAgICAgKi9cbiAgICBzYXZlRGF0YWJhc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGhyb3R0bGVkU2F2ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlRGF0YWJhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgZGIgc2F2ZSBpcyBjdXJyZW50bHkgcnVubmluZywgYSBuZXcgcHJvbWlzZSBmb3IgYSBuZXh0IGRiIHNhdmUgaXMgY3JlYXRlZFxuICAgICAgICAvLyBhbGwgY2FsbHMgdG8gc2F2ZSBkYiB3aWxsIGdldCB0aGlzIG5ldyBwcm9taXNlIHdoaWNoIHdpbGwgYmUgcHJvY2Vzc2VkIHJpZ2h0IGFmdGVyXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IGRiIHNhdmUgaXMgZmluaXNoZWRcbiAgICAgICAgaWYgKHRoaXMuX3Rocm90dGxlZFNhdmVSdW5uaW5nICE9PSBudWxsICYmIHRoaXMuX3Rocm90dGxlZFNhdmVQZW5kaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvdHRsZWRTYXZlUGVuZGluZyA9IFByb21pc2UucmVzb2x2ZSh0aGlzLl90aHJvdHRsZWRTYXZlUnVubmluZykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3R0bGVkU2F2ZVJ1bm5pbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm90dGxlZFNhdmVQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlRGF0YWJhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90aHJvdHRsZWRTYXZlUGVuZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm90dGxlZFNhdmVQZW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rocm90dGxlZFNhdmVSdW5uaW5nID0gdGhpcy5fc2F2ZURhdGFiYXNlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90aHJvdHRsZWRTYXZlUnVubmluZyA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3R0bGVkU2F2ZVJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgZGVsZXRpbmcgYSBkYXRhYmFzZSBmcm9tIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgYWRhcHRlclxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBkYXRhYmFzZSBpcyBkZWxldGVkXG4gICAgICovXG4gICAgZGVsZXRlRGF0YWJhc2UoKSB7XG4gICAgICAgIC8vIHRoZSBwZXJzaXN0ZW5jZUFkYXB0ZXIgc2hvdWxkIGJlIHByZXNlbnQgaWYgYWxsIGlzIG9rLCBidXQgY2hlY2sgdG8gYmUgc3VyZS5cbiAgICAgICAgaWYgKHRoaXMuX3BlcnNpc3RlbmNlQWRhcHRlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInBlcnNpc3RlbmNlQWRhcHRlciBub3QgY29uZmlndXJlZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9wZXJzaXN0ZW5jZUFkYXB0ZXIuZGVsZXRlRGF0YWJhc2UodGhpcy5maWxlbmFtZSkpO1xuICAgIH1cbiAgICAvKioqKioqKioqKioqKioqKlxuICAgICAqIEF1dG9zYXZlIEFQSVxuICAgICAqKioqKioqKioqKioqKioqL1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgYW55IGNvbGxlY3Rpb25zIGFyZSBcImRpcnR5XCIgbWVhbmluZyB3ZSBuZWVkIHRvIHNhdmUgdGhlIChlbnRpcmUpIGRhdGFiYXNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiBkYXRhYmFzZSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGF1dG9zYXZlLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBfYXV0b3NhdmVEaXJ0eSgpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5fY29sbGVjdGlvbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb25zW2lkeF0uX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgZGlydHkgZmxhZ3Mgb24gYWxsIGNvbGxlY3Rpb25zLlxuICAgICAqL1xuICAgIF9hdXRvc2F2ZUNsZWFyRmxhZ3MoKSB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMuX2NvbGxlY3Rpb25zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25zW2lkeF0uX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHBlcmlvZGljYWxseSBzYXZlcyB0byB0aGUgdW5kZXJseWluZyBzdG9yYWdlIGFkYXB0ZXIuXG4gICAgICovXG4gICAgX2F1dG9zYXZlRW5hYmxlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2F1dG9zYXZlIHx8IHRoaXMuX2F1dG9zYXZlUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F1dG9zYXZlUnVubmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdXRvc2F2ZVJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F1dG9zYXZlRGlydHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9zYXZlSGFuZGxlciA9IHRoaXMuX2F1dG9zYXZlSGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVEYXRhYmFzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9hdXRvc2F2ZUludGVydmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIGF1dG9zYXZlIGludGVydmFsIHRpbWVyLlxuICAgICAqL1xuICAgIF9hdXRvc2F2ZURpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX2F1dG9zYXZlUnVubmluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b3NhdmVIYW5kbGVyO1xuICAgIH1cbn1cblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNykpKVxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xva2lfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMb2tpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2xva2lfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImFcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbGxlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb2xsZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2NvbGxlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImFcIl07IH0pO1xuXG5cblxuX2xva2lfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBMb2tpICovIFwiYVwiXVtcIkNvbGxlY3Rpb25cIl0gPSBfY29sbGVjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIENvbGxlY3Rpb24gKi8gXCJhXCJdO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9sb2tpX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogTG9raSAqLyBcImFcIl0pO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9raWRiLmxva2kuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///457\n')},458:function(module,exports,__webpack_require__){eval('(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== \'undefined\' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === \'object\' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, \'default\', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != \'string\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PLUGINS; });\nfunction getGlobal() {\n    let glob;\n    (function (global) {\n        glob = global;\n    })(global !== undefined && global || this);\n    return glob;\n}\nfunction create() {\n    const global = getGlobal();\n    const sym = Symbol.for("LOKI");\n    if (global[sym] === undefined) {\n        global[sym] = {};\n    }\n    return global[sym];\n}\n/**\n * @hidden\n */\nconst PLUGINS = create();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/analyzer/tokenizer.ts\n/**\n * Splits a string at whitespace characters into tokens.\n * @param {string} value - the string\n * @returns {string[]} - the tokens\n */\nfunction whitespaceTokenizer(value) {\n    return value.split(/[\\s]+/);\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/analyzer/token_filter.ts\n/**\n * Converts a token to lowercase.\n * @param {string} token - the token\n * @returns {string} - the lowercased token\n */\nfunction lowercaseTokenFilter(token) {\n    return token.toLowerCase();\n}\n/**\n * Converts a token to uppercase.\n * @param {string} token - the token\n * @returns {string} - the uppercased token\n */\nfunction uppercaseTokenFilter(token) {\n    return token.toUpperCase();\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/analyzer/analyzer.ts\n\n\n/**\n * Analyzes a given string.\n * @param {Analyzer} analyzer - the analyzer\n * @param {string} str - the string\n * @returns {string[]} - the tokens\n */\nfunction analyze(analyzer, str) {\n    if (analyzer.char_filter) {\n        for (let j = 0; j < analyzer.char_filter.length; j++) {\n            str = analyzer.char_filter[j](str);\n        }\n    }\n    const tokens = analyzer.tokenizer(str);\n    if (analyzer.token_filter) {\n        for (let i = 0; i < tokens.length; i++) {\n            for (let k = 0; k < analyzer.token_filter.length; k++) {\n                tokens[i] = analyzer.token_filter[k](tokens[i], i, tokens);\n            }\n        }\n    }\n    // Remove empty tokens.\n    return tokens.filter((token) => token);\n}\n/**\n * An analyzer with the whitespace tokenizer and the lowercase token filter.\n */\nclass analyzer_StandardAnalyzer {\n    constructor() {\n        this.tokenizer = whitespaceTokenizer;\n        this.token_filter = [lowercaseTokenFilter];\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/inverted_index.ts\n\n/**\n * Converts a string into an array of code points.\n * @param str - the string\n * @returns {number[]} to code points\n * @hidden\n */\nfunction toCodePoints(str) {\n    const r = [];\n    for (let i = 0; i < str.length;) {\n        const chr = str.charCodeAt(i++);\n        if (chr >= 0xD800 && chr <= 0xDBFF) {\n            // surrogate pair\n            const low = str.charCodeAt(i++);\n            r.push(0x10000 + ((chr - 0xD800) << 10) | (low - 0xDC00));\n        }\n        else {\n            // ordinary character\n            r.push(chr);\n        }\n    }\n    return r;\n}\n/**\n * Inverted index class handles featured text search for specific document fields.\n * @hidden\n */\nclass inverted_index_InvertedIndex {\n    /**\n     * @param {boolean} [options.store=true] - inverted index will be stored at serialization rather than rebuilt on load\n     * @param {boolean} [options.optimizeChanges=true] - flag to store additional metadata inside the index for better\n     *  performance if an existing field is updated or removed\n     * @param {Analyzer} [options.analyzer=] - the analyzer of this inverted index\n     */\n    constructor(options = {}) {\n        this.docCount = 0;\n        this.docStore = new Map();\n        this.totalFieldLength = 0;\n        this.root = new Map();\n        ({\n            store: this._store = true,\n            optimizeChanges: this._optimizeChanges = true,\n            analyzer: this.analyzer = new analyzer_StandardAnalyzer()\n        } = options);\n    }\n    /**\n     * Adds defined fields of a document to the inverted index.\n     * @param {string} field - the field to add\n     * @param {number} docId - the doc id of the field\n     */\n    insert(field, docId) {\n        if (this.docStore.has(docId)) {\n            throw Error("Field already added.");\n        }\n        // Tokenize document field.\n        const fieldTokens = analyze(this.analyzer, field);\n        if (fieldTokens.length == 0) {\n            // Add empty field at least to document store for query \'exists\'.\n            this.docStore.set(docId, { fieldLength: 0 });\n            return;\n        }\n        this.totalFieldLength += fieldTokens.length;\n        this.docCount += 1;\n        this.docStore.set(docId, { fieldLength: fieldTokens.length });\n        // Holds references to each index of a document.\n        const indexRef = [];\n        if (this._optimizeChanges) {\n            Object.defineProperties(this.docStore.get(docId), {\n                indexRef: { enumerable: false, configurable: true, writable: true, value: indexRef }\n            });\n        }\n        // Iterate over all unique field terms.\n        for (const token of new Set(fieldTokens)) {\n            // Calculate term frequency.\n            let tf = 0;\n            for (let j = 0; j < fieldTokens.length; j++) {\n                if (fieldTokens[j] === token) {\n                    ++tf;\n                }\n            }\n            // Add term to index tree.\n            let branch = this.root;\n            for (const c of toCodePoints(token)) {\n                let child = branch.get(c);\n                if (child === undefined) {\n                    child = new Map();\n                    if (this._optimizeChanges) {\n                        child.pa = branch;\n                    }\n                    branch.set(c, child);\n                }\n                branch = child;\n            }\n            // Add term info to index leaf.\n            if (branch.dc === undefined) {\n                branch.dc = new Map();\n                branch.df = 0;\n            }\n            branch.dc.set(docId, tf);\n            branch.df += 1;\n            // Store index leaf for deletion.\n            indexRef.push(branch);\n        }\n    }\n    /**\n     * Removes all relevant terms of a document from the inverted index.\n     * @param {number} docId - the document.\n     */\n    remove(docId) {\n        if (!this.docStore.has(docId)) {\n            return;\n        }\n        const docStore = this.docStore.get(docId);\n        // Remove document.\n        this.docStore.delete(docId);\n        if (docStore.fieldLength === 0) {\n            return;\n        }\n        this.docCount -= 1;\n        // Reduce total field length.\n        this.totalFieldLength -= docStore.fieldLength;\n        if (this._optimizeChanges) {\n            // Iterate over all term references.\n            // Remove docId from docs and decrement document frequency.\n            const indexRef = docStore.indexRef;\n            for (let j = 0; j < indexRef.length; j++) {\n                let index = indexRef[j];\n                index.df -= 1;\n                index.dc.delete(docId);\n                // Check if no document is left for current tree.\n                if (index.df === 0) {\n                    // Delete unused meta data of branch.\n                    delete index.df;\n                    delete index.dc;\n                    // Check for sub branches.\n                    if (index.size !== 0) {\n                        continue;\n                    }\n                    // Delete term branch if not used anymore.\n                    do {\n                        // Go tree upwards.\n                        const parent = index.pa;\n                        // Delete parent reference for preventing memory leak (cycle reference).\n                        delete index.pa;\n                        // Iterate over all children.\n                        for (const key of parent.keys()) {\n                            // Remove previous child form parent.\n                            if (parent.get(key) === index) {\n                                parent.delete(key);\n                                break;\n                            }\n                        }\n                        index = parent;\n                    } while (index.pa !== undefined && index.size === 0 && index.df === undefined);\n                }\n            }\n        }\n        else {\n            this._remove(this.root, docId);\n        }\n    }\n    /**\n     * Gets the term index of a term.\n     * @param {string} term - the term\n     * @param {object} root - the term index to start from\n     * @param {number} start - the position of the term string to start from\n     * @return {object} - The term index or null if the term is not in the term tree.\n     */\n    static getTermIndex(term, root, start = 0) {\n        if (start >= term.length) {\n            return null;\n        }\n        for (let i = start; i < term.length; i++) {\n            let child = root.get(term[i]);\n            if (child === undefined) {\n                return null;\n            }\n            root = child;\n        }\n        return root;\n    }\n    /**\n     * Extends a term index to all available term leafs.\n     * @param {object} idx - the term index to start from\n     * @param {number[]} [term=[]] - the current term\n     * @param {Array} termIndices - all extended indices with their term\n     * @returns {Array} - Array with term indices and extension\n     */\n    static extendTermIndex(idx, term = [], termIndices = []) {\n        if (idx.df !== undefined) {\n            termIndices.push({ index: idx, term: term.slice() });\n        }\n        term.push(0);\n        for (const child of idx) {\n            term[term.length - 1] = child[0];\n            inverted_index_InvertedIndex.extendTermIndex(child[1], term, termIndices);\n        }\n        term.pop();\n        return termIndices;\n    }\n    /**\n     * Serialize the inverted index.\n     * @returns {{docStore: *, _fields: *, index: *}}\n     */\n    toJSON() {\n        if (this._store) {\n            return {\n                _store: true,\n                _optimizeChanges: this._optimizeChanges,\n                docCount: this.docCount,\n                docStore: [...this.docStore],\n                totalFieldLength: this.totalFieldLength,\n                root: inverted_index_InvertedIndex._serializeIndex(this.root)\n            };\n        }\n        return {\n            _store: false,\n            _optimizeChanges: this._optimizeChanges,\n        };\n    }\n    /**\n     * Deserialize the inverted index.\n     * @param {{docStore: *, _fields: *, index: *}} serialized - The serialized inverted index.\n     * @param {Analyzer} analyzer[undefined] - an analyzer\n     */\n    static fromJSONObject(serialized, analyzer) {\n        const invIdx = new inverted_index_InvertedIndex({\n            store: serialized._store,\n            optimizeChanges: serialized._optimizeChanges,\n            analyzer: analyzer\n        });\n        if (serialized._store) {\n            invIdx.docCount = serialized.docCount;\n            invIdx.docStore = new Map(serialized.docStore);\n            invIdx.totalFieldLength = serialized.totalFieldLength;\n            invIdx.root = inverted_index_InvertedIndex._deserializeIndex(serialized.root);\n        }\n        if (invIdx._optimizeChanges) {\n            invIdx._regenerate(invIdx.root, null);\n        }\n        return invIdx;\n    }\n    static _serializeIndex(idx) {\n        const serialized = {};\n        if (idx.dc !== undefined) {\n            serialized.d = { df: idx.df, dc: [...idx.dc] };\n        }\n        if (idx.size === 0) {\n            return serialized;\n        }\n        const keys = [];\n        const values = [];\n        for (const child of idx) {\n            keys.push(child[0]);\n            values.push(inverted_index_InvertedIndex._serializeIndex(child[1]));\n        }\n        serialized.k = keys;\n        serialized.v = values;\n        return serialized;\n    }\n    static _deserializeIndex(serialized) {\n        const idx = new Map();\n        if (serialized.k !== undefined) {\n            for (let i = 0; i < serialized.k.length; i++) {\n                idx.set(serialized.k[i], inverted_index_InvertedIndex._deserializeIndex(serialized.v[i]));\n            }\n        }\n        if (serialized.d !== undefined) {\n            idx.df = serialized.d.df;\n            idx.dc = new Map(serialized.d.dc);\n        }\n        return idx;\n    }\n    /**\n     * Set parent of to each index and regenerate the indexRef.\n     * @param {Index} index - the index\n     * @param {Index} parent - the parent\n     */\n    _regenerate(index, parent) {\n        // Set parent.\n        if (parent !== null) {\n            index.pa = parent;\n        }\n        // Iterate over subtree.\n        for (const child of index.values()) {\n            this._regenerate(child, index);\n        }\n        if (index.dc !== undefined) {\n            // Get documents of term.\n            for (const docId of index.dc.keys()) {\n                // Get document store at specific document/field.\n                const ref = this.docStore.get(docId);\n                if (ref.indexRef === undefined) {\n                    Object.defineProperties(ref, {\n                        indexRef: { enumerable: false, configurable: true, writable: true, value: [] }\n                    });\n                }\n                // Set reference to term index.\n                ref.indexRef.push(index);\n            }\n        }\n    }\n    /**\n     * Iterate over the whole inverted index and remove the document.\n     * Delete branch if not needed anymore.\n     * Function is needed if index is used without optimization.\n     * @param {Index} idx - the index\n     * @param {number} docId - the doc id\n     * @returns {boolean} true if index is empty\n     */\n    _remove(idx, docId) {\n        for (const child of idx) {\n            // Checkout branch.\n            if (this._remove(child[1], docId)) {\n                idx.delete(child[0]);\n            }\n        }\n        // Remove docId from docs and decrement document frequency.\n        if (idx.df !== undefined) {\n            if (idx.dc.has(docId)) {\n                idx.df -= 1;\n                idx.dc.delete(docId);\n                // Delete unused meta data of branch.\n                if (idx.df === 0) {\n                    delete idx.df;\n                    delete idx.dc;\n                }\n            }\n        }\n        return idx.size === 0 && idx.dc === undefined;\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/scorer.ts\n/**\n * @hidden\n */\nclass Scorer {\n    constructor(invIdxs) {\n        this._cache = {};\n        this._invIdxs = invIdxs;\n    }\n    setDirty() {\n        this._cache = {};\n    }\n    score(fieldName, boost, termIdx, doScoring, queryResults, term, df = 0) {\n        if (termIdx === null || termIdx.dc === undefined) {\n            return;\n        }\n        const idf = this._idf(fieldName, df || termIdx.df);\n        for (const [docId, tf] of termIdx.dc) {\n            if (!queryResults.has(docId)) {\n                queryResults.set(docId, []);\n            }\n            if (doScoring === true) {\n                // BM25 scoring.\n                queryResults.get(docId).push({ tf, idf, boost, fieldName, term });\n            }\n            else if (doScoring === false) {\n                // Constant scoring.\n                queryResults.set(docId, [{ boost }]);\n            }\n            else {\n                // Zero scoring.\n                queryResults.set(docId, [{ boost: 0 }]);\n            }\n        }\n    }\n    scoreConstant(boost, docId, queryResults) {\n        if (!queryResults.has(docId)) {\n            queryResults.set(docId, []);\n        }\n        queryResults.get(docId).push({ boost });\n        return queryResults;\n    }\n    finalScore(query, queryResults) {\n        const finalResult = {};\n        const k1 = query.bm25 !== undefined ? query.bm25.k1 : 1.2;\n        const b = query.bm25 !== undefined ? query.bm25.b : 0.75;\n        const explain = query.explain !== undefined ? query.explain : false;\n        for (const [docId, result] of queryResults) {\n            let docScore = 0;\n            let docExplanation = [];\n            for (let i = 0; i < result.length; i++) {\n                const queryResult = result[i];\n                let score = 0;\n                if (queryResult.tf !== undefined) {\n                    // BM25 scoring.\n                    const tf = queryResult.tf;\n                    const fieldLength = Scorer._calculateFieldLength(this._invIdxs[queryResult.fieldName].docStore.get(docId)\n                        .fieldLength);\n                    const avgFieldLength = this._avgFieldLength(queryResult.fieldName);\n                    const tfNorm = (tf * (k1 + 1)) / (tf + k1 * (1 - b + b * (fieldLength / avgFieldLength)));\n                    score = queryResult.idf * tfNorm * queryResult.boost;\n                    if (explain) {\n                        docExplanation.push({\n                            boost: queryResult.boost,\n                            score: score,\n                            docID: docId,\n                            fieldName: queryResult.fieldName,\n                            index: String.fromCharCode(...queryResult.term),\n                            idf: queryResult.idf,\n                            tfNorm: tfNorm,\n                            tf: tf,\n                            fieldLength: fieldLength,\n                            avgFieldLength: avgFieldLength,\n                        });\n                    }\n                }\n                else {\n                    // Constant scoring.\n                    score = queryResult.boost;\n                    if (explain) {\n                        docExplanation.push({\n                            boost: queryResult.boost,\n                            score: score\n                        });\n                    }\n                }\n                docScore += score;\n            }\n            if (explain) {\n                finalResult[docId] = {\n                    score: docScore,\n                    explanation: docExplanation\n                };\n            }\n            else {\n                finalResult[docId] = {\n                    score: docScore\n                };\n            }\n        }\n        return finalResult;\n    }\n    static _calculateFieldLength(fieldLength) {\n        // Dummy function to be compatible to lucene in unit tests.\n        return fieldLength;\n    }\n    _getCache(fieldName) {\n        if (this._cache[fieldName] === undefined) {\n            const avgFieldLength = this._invIdxs[fieldName].totalFieldLength / this._invIdxs[fieldName].docCount;\n            this._cache[fieldName] = { idfs: {}, avgFieldLength };\n        }\n        return this._cache[fieldName];\n    }\n    /**\n     * Returns the idf by either calculate it or use a cached one.\n     * @param {string} fieldName - the name of the field\n     * @param {number} docFreq - the doc frequency of the term\n     * @returns {number} the idf\n     * @private\n     */\n    _idf(fieldName, docFreq) {\n        const cache = this._getCache(fieldName);\n        if (cache.idfs[docFreq] !== undefined) {\n            return cache.idfs[docFreq];\n        }\n        return cache.idfs[docFreq] = Math.log(1 + (this._invIdxs[fieldName].docCount - docFreq + 0.5) / (docFreq + 0.5));\n    }\n    _avgFieldLength(fieldName) {\n        return this._getCache(fieldName).avgFieldLength;\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/fuzzy/run_automaton.ts\n/**\n * From org/apache/lucene/util/automaton/RunAutomaton.java\n * @hidden\n */\nclass RunAutomaton {\n    constructor(automaton) {\n        const size = automaton.getNumStates();\n        this._points = automaton.getStartPoints();\n        this._accept = new Array(size);\n        this._transitions = new Array(size * this._points.length);\n        for (let n = 0; n < size; n++) {\n            this._accept[n] = automaton.isAccept(n);\n            for (let c = 0; c < this._points.length; c++) {\n                // assert dest === -1 || dest < size;\n                this._transitions[n * this._points.length + c] = automaton.step(n, this._points[c]);\n            }\n        }\n        this._classmap = new Array(256 /* alphaSize */);\n        for (let i = 0, j = 0; j < this._classmap.length; j++) {\n            if (i + 1 < this._points.length && j === this._points[i + 1]) {\n                i++;\n            }\n            this._classmap[j] = i;\n        }\n    }\n    getCharClass(c) {\n        // binary search\n        let a = 0;\n        let b = this._points.length;\n        while (b - a > 1) {\n            const d = (a + b) >>> 1;\n            if (this._points[d] > c) {\n                b = d;\n            }\n            else if (this._points[d] < c) {\n                a = d;\n            }\n            else {\n                return d;\n            }\n        }\n        return a;\n    }\n    step(state, c) {\n        if (c >= this._classmap.length) {\n            return this._transitions[state * this._points.length + this.getCharClass(c)];\n        }\n        else {\n            return this._transitions[state * this._points.length + this._classmap[c]];\n        }\n    }\n    isAccept(state) {\n        return this._accept[state];\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/fuzzy/automaton.ts\n/**\n * @type {number}\n * @hidden\n */\nconst MIN_CODE_POINT = 0;\n/**\n * @type {number}\n * @hidden\n */\nconst MAX_CODE_POINT = 1114111;\nfunction sortByDestMinMax(a, b) {\n    if (a[0] < b[0]) {\n        return -1;\n    }\n    else if (a[0] > b[0]) {\n        return 1;\n    }\n    if (a[1] < b[1]) {\n        return -1;\n    }\n    else if (a[1] > b[1]) {\n        return 1;\n    }\n    if (a[2] < b[2]) {\n        return -1;\n    }\n    else if (a[2] > b[2]) {\n        return 1;\n    }\n    return 0;\n}\nfunction sortByMinMaxDest(a, b) {\n    if (a[1] < b[1]) {\n        return -1;\n    }\n    else if (a[1] > b[1]) {\n        return 1;\n    }\n    if (a[2] < b[2]) {\n        return -1;\n    }\n    else if (a[2] > b[2]) {\n        return 1;\n    }\n    if (a[0] < b[0]) {\n        return -1;\n    }\n    else if (a[0] > b[0]) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * From org/apache/lucene/util/automaton/Automaton.java\n * @hidden\n */\nclass Automaton {\n    constructor() {\n        this._stateTransitions = [];\n        this._stateTransitions = [];\n        this._accept = new Set();\n        this._nextState = 0;\n        this._currState = -1;\n        // this.deterministic = true;\n        this._transitions = {};\n    }\n    isAccept(n) {\n        return this._accept.has(n);\n    }\n    createState() {\n        return this._nextState++;\n    }\n    setAccept(state, accept) {\n        if (accept) {\n            this._accept.add(state);\n        }\n        else {\n            this._accept.delete(state);\n        }\n    }\n    finishState() {\n        if (this._currState !== -1) {\n            this._finishCurrentState();\n            this._currState = -1;\n        }\n    }\n    _finishCurrentState() {\n        // Sort all transitions.\n        this._stateTransitions.sort(sortByDestMinMax);\n        let upto = 0;\n        let p = [-1, -1, -1];\n        for (let i = 0, len = this._stateTransitions.length; i < len; i++) {\n            let t = this._stateTransitions[i];\n            if (p[0] === t[0]) {\n                if (t[1] <= p[2] + 1) {\n                    if (t[2] > p[2]) {\n                        p[2] = t[2];\n                    }\n                }\n                else {\n                    if (p[0] !== -1) {\n                        this._stateTransitions[upto][0] = p[0];\n                        this._stateTransitions[upto][1] = p[1];\n                        this._stateTransitions[upto][2] = p[2];\n                        upto++;\n                    }\n                    p[1] = t[1];\n                    p[2] = t[2];\n                }\n            }\n            else {\n                if (p[0] !== -1) {\n                    this._stateTransitions[upto][0] = p[0];\n                    this._stateTransitions[upto][1] = p[1];\n                    this._stateTransitions[upto][2] = p[2];\n                    upto++;\n                }\n                p[0] = t[0];\n                p[1] = t[1];\n                p[2] = t[2];\n            }\n        }\n        if (p[0] !== -1) {\n            // Last transition\n            this._stateTransitions[upto][0] = p[0];\n            this._stateTransitions[upto][1] = p[1];\n            this._stateTransitions[upto][2] = p[2];\n            upto++;\n        }\n        this._transitions[this._currState] = this._stateTransitions.slice(0, upto).sort(sortByMinMaxDest);\n        // if (this.deterministic && upto > 1) {\n        //   let lastMax = this.stateTransitions[0][2];\n        //   for (let i = 1; i < upto; i++) {\n        //     let min = this.stateTransitions[i][1];\n        //     if (min <= lastMax) {\n        //       this.deterministic = false;\n        //       break;\n        //     }\n        //     lastMax = this.stateTransitions[i][2];\n        //   }\n        // }\n        this._stateTransitions = [];\n    }\n    getStartPoints() {\n        const pointset = new Set();\n        pointset.add(MIN_CODE_POINT);\n        const states = Object.keys(this._transitions);\n        for (let i = 0; i < states.length; i++) {\n            let trans = this._transitions[states[i]];\n            for (let j = 0; j < trans.length; j++) {\n                let tran = trans[j];\n                pointset.add(tran[1]);\n                if (tran[2] < MAX_CODE_POINT) {\n                    pointset.add(tran[2] + 1);\n                }\n            }\n        }\n        return Array.from(pointset).sort((a, b) => a - b);\n    }\n    step(state, label) {\n        let trans = this._transitions[state];\n        if (trans) {\n            for (let i = 0; i < trans.length; i++) {\n                let tran = trans[i];\n                if (tran[1] <= label && label <= tran[2]) {\n                    return tran[0];\n                }\n            }\n        }\n        return -1;\n    }\n    getNumStates() {\n        return this._nextState;\n    }\n    addTransition(source, dest, min, max) {\n        if (this._currState !== source) {\n            if (this._currState !== -1) {\n                this._finishCurrentState();\n            }\n            this._currState = source;\n        }\n        this._stateTransitions.push([dest, min, max]);\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/fuzzy/long.ts\n/**\n * Class supports 64Bit integer operations.\n * A cut-down version of dcodeIO/long.js.\n * @hidden\n */\nclass Long {\n    constructor(low = 0, high = 0) {\n        this._low = low;\n        this._high = high;\n    }\n    /**\n     * Returns this long with bits arithmetically shifted to the right by the given amount.\n     * @param {number} numBits - number of bits\n     * @returns {Long} the long\n     */\n    shiftRight(numBits) {\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return new Long((this._low >>> numBits) | (this._high << (32 - numBits)), this._high >> numBits);\n        else\n            return new Long((this._high >> (numBits - 32)), this._high >= 0 ? 0 : -1);\n    }\n    /**\n     * Returns this long with bits arithmetically shifted to the left by the given amount.\n     * @param {number} numBits - number of bits\n     * @returns {Long} the long\n     */\n    shiftLeft(numBits) {\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return new Long(this._low << numBits, (this._high << numBits) | (this._low >>> (32 - numBits)));\n        else\n            return new Long(0, this._low << (numBits - 32));\n    }\n    /**\n     * Returns the bitwise AND of this Long and the specified.\n     * @param {Long} other - the other Long\n     * @returns {Long} the long\n     */\n    and(other) {\n        return new Long(this._low & other._low, this._high & other._high);\n    }\n    /**\n     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n     * @returns {number}\n     */\n    toInt() {\n        return this._low;\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/fuzzy/parametric_description.ts\n\nconst MASKS = [new Long(0x1), new Long(0x3), new Long(0x7), new Long(0xf),\n    new Long(0x1f), new Long(0x3f), new Long(0x7f), new Long(0xff),\n    new Long(0x1ff), new Long(0x3ff), new Long(0x7ff), new Long(0xfff),\n    new Long(0x1fff), new Long(0x3fff), new Long(0x7fff), new Long(0xffff),\n    new Long(0xf, 0x1fff), new Long(0xf, 0x3fff), new Long(0xf, 0x7fff), new Long(0xf, 0xffff),\n    new Long(0xff, 0x1fff), new Long(0xff, 0x3fff), new Long(0xff, 0x7fff), new Long(0xff, 0xffff),\n    new Long(0xfff, 0x1fff), new Long(0xfff, 0x3fff), new Long(0xfff, 0x7fff), new Long(0xfff, 0xffff),\n    new Long(0xffff, 0x1fff), new Long(0xffff, 0x3fff), new Long(0xffff, 0x7fff), new Long(0xffff, 0xffff),\n    new Long(0xfffff, 0x1fff), new Long(0xfffff, 0x3fff), new Long(0xfffff, 0x7fff), new Long(0xfffff, 0xffff),\n    new Long(0xffffff, 0x1fff), new Long(0xffffff, 0x3fff), new Long(0xffffff, 0x7fff), new Long(0xffffff, 0xffff),\n    new Long(0xfffffff, 0x1fff), new Long(0xfffffff, 0x3fff), new Long(0xfffffff, 0x7fff), new Long(0xfffffff, 0xffff),\n    new Long(0xffffffff, 0x1fff), new Long(0xffffffff, 0x3fff), new Long(0xffffffff, 0x7fff), new Long(0xffffffff, 0xffff),\n    new Long(0xfffffffff, 0x1fff), new Long(0xfffffffff, 0x3fff), new Long(0xfffffffff, 0x7fff), new Long(0xfffffffff, 0xffff),\n    new Long(0xffffffffff, 0x1fff), new Long(0xffffffffff, 0x3fff), new Long(0xffffffffff, 0x7fff), new Long(0xffffffffff, 0xffff),\n    new Long(0xfffffffffff, 0x1fff), new Long(0xfffffffffff, 0x3fff), new Long(0xfffffffffff, 0x7fff), new Long(0xfffffffffff, 0xffff),\n    new Long(0xffffffffffff, 0x1fff), new Long(0xffffffffffff, 0x3fff), new Long(0xffffffffffff, 0x7fff)];\n/**\n * From org/apache/lucene/util/automaton/LevenshteinAutomata.java#ParametricDescription\n * @hidden\n */\nclass ParametricDescription {\n    constructor(w, n, minErrors) {\n        this._w = w;\n        this._n = n;\n        this._minErrors = minErrors;\n    }\n    /**\n     * Return the number of states needed to compute a Levenshtein DFA\n     */\n    size() {\n        return this._minErrors.length * (this._w + 1);\n    }\n    /**\n     * Returns true if the <code>state</code> in any Levenshtein DFA is an accept state (final state).\n     */\n    isAccept(absState) {\n        // decode absState -> state, offset\n        let state = Math.floor(absState / (this._w + 1));\n        let offset = absState % (this._w + 1);\n        //assert offset >= 0;\n        return this._w - offset + this._minErrors[state] <= this._n;\n    }\n    /**\n     * Returns the position in the input word for a given <code>state</code>.\n     * This is the minimal boundary for the state.\n     */\n    getPosition(absState) {\n        return absState % (this._w + 1);\n    }\n    static unpack(data, index, bitsPerValue) {\n        const bitLoc = bitsPerValue * index;\n        const dataLoc = (bitLoc >> 6);\n        const bitStart = (bitLoc & 63);\n        if (bitStart + bitsPerValue <= 64) {\n            // not split\n            return data[dataLoc].shiftRight(bitStart).and(MASKS[bitsPerValue - 1]).toInt();\n        }\n        else {\n            // split\n            const part = 64 - bitStart;\n            return (data[dataLoc].shiftRight(bitStart).and(MASKS[part - 1])).toInt()\n                + (data[1 + dataLoc].and(MASKS[bitsPerValue - part - 1]).shiftLeft(part)).toInt();\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/fuzzy/lev1t_parametric_description.ts\n\n\n// 1 vectors; 2 states per vector; array length = 2\nconst toStates0 = [new Long(0x2)];\nconst offsetIncrs0 = [new Long(0x0)];\n// 2 vectors; 3 states per vector; array length = 6\nconst toStates1 = [new Long(0xa43)];\nconst offsetIncrs1 = [new Long(0x38)];\n// 4 vectors; 6 states per vector; array length = 24\nconst toStates2 = [new Long(0x82140003, 0x34534914), new Long(0x6d)];\nconst offsetIncrs2 = [new Long(0x55a20000, 0x5555)];\n// 8 vectors; 6 states per vector; array length = 48\nconst toStates3 = [new Long(0x900C0003, 0x21520854), new Long(0x4534916d, 0x5b4d19a2), new Long(0xda34)];\nconst offsetIncrs3 = [new Long(0x20fc0000, 0x5555ae0a), new Long(0x55555555)];\n// state map\n//   0 -> [(0, 0)]\n//   1 -> [(0, 1)]\n//   2 -> [(0, 1), (1, 1)]\n//   3 -> [(0, 1), (2, 1)]\n//   4 -> [t(0, 1), (0, 1), (1, 1), (2, 1)]\n//   5 -> [(0, 1), (1, 1), (2, 1)]\n/**\n * From org/apache/lucene/util/automaton/Lev1TParametricDescription.java\n * @hidden\n */\nclass lev1t_parametric_description_Lev1TParametricDescription extends ParametricDescription {\n    constructor(w) {\n        super(w, 1, [0, 1, 0, -1, -1, -1]);\n    }\n    transition(absState, position, vector) {\n        // null absState should never be passed in\n        //assert absState != -1;\n        // decode absState -> state, offset\n        let state = Math.floor(absState / (this._w + 1));\n        let offset = absState % (this._w + 1);\n        //assert offset >= 0;\n        if (position === this._w) {\n            if (state < 2) {\n                const loc = vector * 2 + state;\n                offset += ParametricDescription.unpack(offsetIncrs0, loc, 1);\n                state = ParametricDescription.unpack(toStates0, loc, 2) - 1;\n            }\n        }\n        else if (position === this._w - 1) {\n            if (state < 3) {\n                const loc = vector * 3 + state;\n                offset += ParametricDescription.unpack(offsetIncrs1, loc, 1);\n                state = ParametricDescription.unpack(toStates1, loc, 2) - 1;\n            }\n        }\n        else if (position === this._w - 2) {\n            if (state < 6) {\n                const loc = vector * 6 + state;\n                offset += ParametricDescription.unpack(offsetIncrs2, loc, 2);\n                state = ParametricDescription.unpack(toStates2, loc, 3) - 1;\n            }\n        }\n        else {\n            if (state < 6) {\n                const loc = vector * 6 + state;\n                offset += ParametricDescription.unpack(offsetIncrs3, loc, 2);\n                state = ParametricDescription.unpack(toStates3, loc, 3) - 1;\n            }\n        }\n        if (state === -1) {\n            // null state\n            return -1;\n        }\n        else {\n            // translate back to abs\n            return state * (this._w + 1) + offset;\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/fuzzy/lev2t_parametric_description.ts\n\n\n// 1 vectors; 3 states per vector; array length = 3\nconst lev2t_parametric_description_toStates0 = /*2 bits per value */ [\n    new Long(0x23)\n];\nconst lev2t_parametric_description_offsetIncrs0 = /*1 bits per value */ [\n    new Long(0x0)\n];\n// 2 vectors; 5 states per vector; array length = 10\nconst lev2t_parametric_description_toStates1 = /*3 bits per value */ [\n    new Long(0x13688b44)\n];\nconst lev2t_parametric_description_offsetIncrs1 = /*1 bits per value */ [\n    new Long(0x3e0)\n];\n// 4 vectors; 13 states per vector; array length = 52\nconst lev2t_parametric_description_toStates2 = /*4 bits per value */ [\n    new Long(0x5200b504, 0x60dbb0b0), new Long(0x27062227, 0x52332176), new Long(0x14323235, 0x23555432), new Long(0x4354)\n];\nconst lev2t_parametric_description_offsetIncrs2 = /*2 bits per value */ [\n    new Long(0x00002000, 0x555080a8), new Long(0x55555555, 0x55)\n];\n// 8 vectors; 28 states per vector; array length = 224\nconst lev2t_parametric_description_toStates3 = /*5 bits per value */ [\n    new Long(0x40059404, 0xe701c029), new Long(0x00a50000, 0xa0101620), new Long(0xa1416288, 0xb02c8c40), new Long(0x310858c0, 0xa821032),\n    new Long(0x0d28b201, 0x31442398), new Long(0x847788e0, 0x5281e528), new Long(0x08c2280e, 0xa23980d3), new Long(0xa962278c, 0x1e3294b1),\n    new Long(0x2288e528, 0x8c41309e), new Long(0x021aca21, 0x11444409), new Long(0x86b1086b, 0x11a46248), new Long(0x1d6240c4, 0x2a625894),\n    new Long(0x489074ad, 0x5024a50b), new Long(0x520c411a, 0x14821aca), new Long(0x0b594a44, 0x5888b589), new Long(0xc411a465, 0x941d6520),\n    new Long(0xad6a62d4, 0x8b589075), new Long(0x1a5055a4)\n];\nconst lev2t_parametric_description_offsetIncrs3 = /*2 bits per value */ [\n    new Long(0x00002000, 0x30c302), new Long(0xc3fc333c, 0x2a0030f3), new Long(0x8282a820, 0x233a0032), new Long(0x32b283a8, 0x55555555),\n    new Long(0x55555555, 0x55555555), new Long(0x55555555, 0x55555555), new Long(0x55555555, 0x55555555)\n];\n// 16 vectors; 45 states per vector; array length = 720\nconst toStates4 = /*6 bits per value */ [\n    new Long(0x002c5004, 0x3801450), new Long(0x00000e38, 0xc500014b), new Long(0x51401402, 0x514), new Long(0x0),\n    new Long(0x14010000, 0x518000b), new Long(0x28e20230, 0x9f1c208), new Long(0x830a70c2, 0x219f0df0), new Long(0x08208200, 0x82000082),\n    new Long(0x60800800, 0x8050501), new Long(0x02602643, 0x30820986), new Long(0x50508064, 0x45640142), new Long(0x20000831, 0x8500514),\n    new Long(0x85002082, 0x41405820), new Long(0x0990c201, 0x45618098), new Long(0x50a01051, 0x8316d0c), new Long(0x050df0e0, 0x21451420),\n    new Long(0x14508214, 0xd142140), new Long(0x50821c60, 0x3c21c018), new Long(0xcb142087, 0x1cb1403), new Long(0x1851822c, 0x80082145),\n    new Long(0x20800020, 0x200208), new Long(0x87180345, 0xd0061820), new Long(0x24976b09, 0xcb0a81cb), new Long(0x624709d1, 0x8b1a60e),\n    new Long(0x82249089, 0x2490820), new Long(0x00d2c024, 0xc31421c6), new Long(0x15454423, 0x3c314515), new Long(0xc21cb140, 0x31853c22),\n    new Long(0x2c208214, 0x4514500b), new Long(0x508b0051, 0x8718034), new Long(0x5108f0c5, 0xb2cb4551), new Long(0x1cb0a810, 0xe824715d),\n    new Long(0x908b0e60, 0x1422cb14), new Long(0xc02cb145, 0x30812c22), new Long(0x0cb1420c, 0x84202202), new Long(0x20ce0850, 0x5c20ce08),\n    new Long(0x8b0d70c2, 0x20820820), new Long(0x14214208, 0x42085082), new Long(0x50830c20, 0x9208340), new Long(0x13653592, 0xc6134dc6),\n    new Long(0x6dc4db4d, 0xd309341c), new Long(0x54d34d34, 0x6424d908), new Long(0x030814c2, 0x92072c22), new Long(0x24a30930, 0x4220724b),\n    new Long(0x25c920e2, 0x2470d720), new Long(0x975c9082, 0x92c92d70), new Long(0x04924e08, 0xcb0880c2), new Long(0xc24c2481, 0x45739728),\n    new Long(0xda6174da, 0xc6da4db5), new Long(0x5d30971d, 0x4b5d35d7), new Long(0x93825ce2, 0x1030815c), new Long(0x020cb145, 0x51442051),\n    new Long(0x2c220e2c, 0xc538210e), new Long(0x52cb0d70, 0x8514214), new Long(0x85145142, 0x204b0850), new Long(0x4051440c, 0x92156083),\n    new Long(0xa60e6595, 0x4d660e4d), new Long(0x1c6dc658, 0x94d914e4), new Long(0x1454d365, 0x82642659), new Long(0x51030813, 0x2892072c),\n    new Long(0xcb2ca30b, 0xe2c22072), new Long(0x20538910, 0x452c70d7), new Long(0x708e3891, 0x8b2cb2d), new Long(0xc204b24e, 0x81cb1440),\n    new Long(0x28c2ca24, 0xda44e38e), new Long(0x85d660e4, 0x1dc6da65), new Long(0x8e5d914e, 0xe2cb5d33), new Long(0x38938238)\n];\nconst offsetIncrs4 = /*3 bits per value */ [\n    new Long(0x00080000, 0x30020000), new Long(0x20c060), new Long(0x04000000, 0x81490000), new Long(0x10824824, 0x40249241),\n    new Long(0x60002082, 0xdb6030c3), new Long(0x301b0d80, 0x6c36c06c), new Long(0x000db0db, 0xb01861b0), new Long(0x9188e06d, 0x1b703620),\n    new Long(0x06d86db7, 0x8009200), new Long(0x02402490, 0x4920c24), new Long(0x08249009, 0x490002), new Long(0x28124804, 0x49081281),\n    new Long(0x124a44a2, 0x34800104), new Long(0x0d24020c, 0xc3093090), new Long(0x24c24d24, 0x40009a09), new Long(0x9201061a, 0x4984a06),\n    new Long(0x71269262, 0x494d0492), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249),\n    new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924),\n    new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492),\n    new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249),\n    new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x2492)\n];\n// 32 vectors; 45 states per vector; array length = 1440\nconst toStates5 = /*6 bits per value */ [\n    new Long(0x002c5004, 0x3801450), new Long(0x00000e38, 0xc500014b), new Long(0x51401402, 0x514), new Long(0x0),\n    new Long(0x14010000, 0x514000b), new Long(0x038e00e0, 0x550000), new Long(0x0600b180, 0x26451850), new Long(0x08208208, 0x82082082),\n    new Long(0x40820820, 0x2c500), new Long(0x808c0146, 0x70820a38), new Long(0x9c30827c, 0xc37c20c2), new Long(0x20800867, 0x208208),\n    new Long(0x02002080, 0xb1401020), new Long(0x00518000, 0x828e2023), new Long(0x209f1c20, 0x830a70c), new Long(0x853df0df, 0x51451450),\n    new Long(0x14508214, 0x16142142), new Long(0x30805050, 0x60260264), new Long(0x43082098, 0x25050806), new Long(0x14564014, 0x42000083),\n    new Long(0x20850051, 0x8500208), new Long(0x14140582, 0x80990c20), new Long(0x08261809, 0x82019202), new Long(0x90060941, 0x8920519),\n    new Long(0xc22cb242, 0x22492492), new Long(0x0162492c, 0x43080505), new Long(0x86026026, 0x80414515), new Long(0xc5b43142, 0x37c38020),\n    new Long(0x14508014, 0x42085085), new Long(0x50850051, 0x1414058), new Long(0x980990c2, 0x51456180), new Long(0x0c50a010, 0xe008316d),\n    new Long(0x508b21f0, 0x2c52cb2c), new Long(0xc22cb249, 0x600d2c92), new Long(0x1850821c, 0x873c21c0), new Long(0x03cb1420, 0x2c01cb14),\n    new Long(0x45185182, 0x20800821), new Long(0x08208000, 0x45002002), new Long(0x20871803, 0x8700614), new Long(0x050821cf, 0x740500f5),\n    new Long(0x18609000, 0x934d9646), new Long(0x30824d30, 0x4c24d34d), new Long(0xc600d642, 0x1860821), new Long(0x25dac274, 0xc2a072c9),\n    new Long(0x91c27472, 0x2c698398), new Long(0x89242242, 0x92420820), new Long(0x34b00900, 0x82087180), new Long(0xb09d0061, 0x1cb24976),\n    new Long(0x9d1cb0a8, 0x60e62470), new Long(0x1574ce3e, 0xd31455d7), new Long(0x25c25d74, 0x1c600d38), new Long(0x423c3142, 0x51515454),\n    new Long(0x1403c314, 0xc22c21cb), new Long(0x21431853, 0xb2c208), new Long(0x05145145, 0x34508b0), new Long(0x0c508718, 0x5515108f),\n    new Long(0xf2051454, 0x8740500), new Long(0x0618f090, 0xe2534d92), new Long(0x6592c238, 0x49382659), new Long(0x21c600d6, 0x4423c314),\n    new Long(0xcb2d1545, 0x72c2a042), new Long(0xa091c574, 0x422c3983), new Long(0x508b2c52, 0xb2c514), new Long(0x8034b08b, 0xf0c50871),\n    new Long(0x45515108, 0xa810b2cb), new Long(0x715d1cb0, 0x2260e824), new Long(0x8e2d74ce, 0xe6592c53), new Long(0x38938238, 0x420c3081),\n    new Long(0x22020cb1, 0x8508420), new Long(0xce0820ce, 0x70c25c20), new Long(0x08208b0d, 0x42082082), new Long(0x50821421, 0xc204208),\n    new Long(0x832c5083, 0x21080880), new Long(0x0838c214, 0xa5083882), new Long(0xa9c39430, 0xaaaaaaaa), new Long(0x9fa9faaa, 0x1aaa7eaa),\n    new Long(0x1420c308, 0x824820d0), new Long(0x84d94d64, 0x7184d371), new Long(0x1b7136d3, 0x34c24d07), new Long(0x1534d34d, 0x99093642),\n    new Long(0x30c20530, 0x8340508), new Long(0x53592092, 0x34dc6136), new Long(0x4db4dc61, 0xa479c6dc), new Long(0x4924924a, 0x920a9f92),\n    new Long(0x8192a82a, 0x72c22030), new Long(0x30930920, 0x724b24a), new Long(0x920e2422, 0xd72025c), new Long(0xc9082247, 0x92d70975),\n    new Long(0x24e0892c, 0x880c2049), new Long(0xc2481cb0, 0x2c928c24), new Long(0x89088749, 0x80a52488), new Long(0xaac74394, 0x6a861b2a),\n    new Long(0xab27b278, 0x81b2ca6), new Long(0x072c2203, 0xa3093092), new Long(0x6915ce5c, 0xd76985d3), new Long(0x771b6936, 0x5d74c25c),\n    new Long(0x892d74d7, 0x724e0973), new Long(0x0880c205, 0x4c2481cb), new Long(0x739728c2, 0x6174da45), new Long(0xda4db5da, 0x4aa175c6),\n    new Long(0x86486186, 0x6a869b27), new Long(0x308186ca, 0xcb14510), new Long(0x44205102, 0x220e2c51), new Long(0x38210e2c, 0xcb0d70c5),\n    new Long(0x51421452, 0x14514208), new Long(0x4b085085, 0x51440c20), new Long(0x1440832c, 0xcb145108), new Long(0x488b0888, 0x94316208),\n    new Long(0x9f7e79c3, 0xfaaa7dfa), new Long(0x7ea7df7d, 0x30819ea), new Long(0x20d01451, 0x65648558), new Long(0x93698399, 0x96135983),\n    new Long(0x39071b71, 0xd9653645), new Long(0x96451534, 0x4e09909), new Long(0x051440c2, 0x21560834), new Long(0x60e65959, 0xd660e4da),\n    new Long(0xc6dc6584, 0x9207e979), new Long(0xdf924820, 0xa82a8207), new Long(0x103081a6, 0x892072c5), new Long(0xb2ca30b2, 0x2c22072c),\n    new Long(0x0538910e, 0x52c70d72), new Long(0x08e38914, 0x8b2cb2d7), new Long(0x204b24e0, 0x1cb1440c), new Long(0x8c2ca248, 0x874b2cb2),\n    new Long(0x24488b08, 0x43948162), new Long(0x9b1f7e77, 0x9e786aa6), new Long(0xeca6a9e7, 0x51030819), new Long(0x2892072c, 0x8e38a30b),\n    new Long(0x83936913, 0x69961759), new Long(0x4538771b, 0x74ce3976), new Long(0x08e38b2d, 0xc204e24e), new Long(0x81cb1440, 0x28c2ca24),\n    new Long(0xda44e38e, 0x85d660e4), new Long(0x75c6da65, 0x698607e9), new Long(0x99e7864a, 0xa6ca6aa6)\n];\nconst offsetIncrs5 = /*3 bits per value */ [\n    new Long(0x00080000, 0x30020000), new Long(0x20c060), new Long(0x04000000, 0x1000000), new Long(0x50603018, 0xdb6db6db),\n    new Long(0x00002db6, 0xa4800002), new Long(0x41241240, 0x12492088), new Long(0x00104120, 0x40000100), new Long(0x92092052, 0x2492c420),\n    new Long(0x096592d9, 0xc30d800), new Long(0xc36036d8, 0xb01b0c06), new Long(0x6c36db0d, 0x186c0003), new Long(0xb01b6c06, 0xad860361),\n    new Long(0x5b6dd6dd, 0x360001b7), new Long(0x0db6030c, 0xc412311c), new Long(0xb6e36e06, 0xdb0d), new Long(0xdb01861b, 0x9188e06),\n    new Long(0x71b72b62, 0x6dd6db), new Long(0x00800920, 0x40240249), new Long(0x904920c2, 0x20824900), new Long(0x40049000, 0x12012480),\n    new Long(0xa4906120, 0x5524ad4a), new Long(0x02480015, 0x40924020), new Long(0x48409409, 0x92522512), new Long(0x24000820, 0x49201001),\n    new Long(0x204a04a0, 0x29128924), new Long(0x00055549, 0x900830d2), new Long(0x24c24034, 0x934930c), new Long(0x02682493, 0x4186900),\n    new Long(0x61201a48, 0x9a498612), new Long(0x355249d4, 0xc348001), new Long(0x940d2402, 0x24c40930), new Long(0x0924e24d, 0x1a40009a),\n    new Long(0x06920106, 0x6204984a), new Long(0x92712692, 0x92494d54), new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924),\n    new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492),\n    new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249),\n    new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924),\n    new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492),\n    new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249),\n    new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924),\n    new Long(0x49249249, 0x92492492), new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492),\n    new Long(0x24924924, 0x49249249), new Long(0x92492492, 0x24924924), new Long(0x49249249, 0x92492492), new Long(0x24924924)\n];\n// state map\n//   0 -> [(0, 0)]\n//   1 -> [(0, 2)]\n//   2 -> [(0, 1)]\n//   3 -> [(0, 1), (1, 1)]\n//   4 -> [(0, 2), (1, 2)]\n//   5 -> [t(0, 2), (0, 2), (1, 2), (2, 2)]\n//   6 -> [(0, 2), (2, 1)]\n//   7 -> [(0, 1), (2, 2)]\n//   8 -> [(0, 2), (2, 2)]\n//   9 -> [(0, 1), (1, 1), (2, 1)]\n//   10 -> [(0, 2), (1, 2), (2, 2)]\n//   11 -> [(0, 1), (2, 1)]\n//   12 -> [t(0, 1), (0, 1), (1, 1), (2, 1)]\n//   13 -> [(0, 2), (1, 2), (2, 2), (3, 2)]\n//   14 -> [t(0, 2), (0, 2), (1, 2), (2, 2), (3, 2)]\n//   15 -> [(0, 2), t(1, 2), (1, 2), (2, 2), (3, 2)]\n//   16 -> [(0, 2), (2, 1), (3, 1)]\n//   17 -> [(0, 1), t(1, 2), (2, 2), (3, 2)]\n//   18 -> [(0, 2), (3, 2)]\n//   19 -> [(0, 2), (1, 2), t(1, 2), (2, 2), (3, 2)]\n//   20 -> [t(0, 2), (0, 2), (1, 2), (3, 1)]\n//   21 -> [(0, 1), (1, 1), (3, 2)]\n//   22 -> [(0, 2), (2, 2), (3, 2)]\n//   23 -> [(0, 2), (1, 2), (3, 1)]\n//   24 -> [(0, 2), (1, 2), (3, 2)]\n//   25 -> [(0, 1), (2, 2), (3, 2)]\n//   26 -> [(0, 2), (3, 1)]\n//   27 -> [(0, 1), (3, 2)]\n//   28 -> [(0, 2), (2, 1), (4, 2)]\n//   29 -> [(0, 2), t(1, 2), (1, 2), (2, 2), (3, 2), (4, 2)]\n//   30 -> [(0, 2), (1, 2), (4, 2)]\n//   31 -> [(0, 2), (1, 2), (3, 2), (4, 2)]\n//   32 -> [(0, 2), (2, 2), (3, 2), (4, 2)]\n//   33 -> [(0, 2), (1, 2), t(2, 2), (2, 2), (3, 2), (4, 2)]\n//   34 -> [(0, 2), (1, 2), (2, 2), t(2, 2), (3, 2), (4, 2)]\n//   35 -> [(0, 2), (3, 2), (4, 2)]\n//   36 -> [(0, 2), t(2, 2), (2, 2), (3, 2), (4, 2)]\n//   37 -> [t(0, 2), (0, 2), (1, 2), (2, 2), (4, 2)]\n//   38 -> [(0, 2), (1, 2), (2, 2), (4, 2)]\n//   39 -> [t(0, 2), (0, 2), (1, 2), (2, 2), (3, 2), (4, 2)]\n//   40 -> [(0, 2), (1, 2), (2, 2), (3, 2), (4, 2)]\n//   41 -> [(0, 2), (4, 2)]\n//   42 -> [t(0, 2), (0, 2), (1, 2), (2, 2), t(2, 2), (3, 2), (4, 2)]\n//   43 -> [(0, 2), (2, 2), (4, 2)]\n//   44 -> [(0, 2), (1, 2), t(1, 2), (2, 2), (3, 2), (4, 2)]\n/**\n * From org/apache/lucene/util/automaton/Lev2TParametricDescription.java\n * @hidden\n */\nclass lev2t_parametric_description_Lev2TParametricDescription extends ParametricDescription {\n    constructor(w) {\n        super(w, 2, [0, 2, 1, 0, 1, 0, -1, 0, 0, -1, 0, -1, -1, -1, -1, -1, -2, -1, -1, -1, -2, -1, -1, -2, -1, -1, -2, -1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2]);\n    }\n    transition(absState, position, vector) {\n        // null absState should never be passed in\n        // assert absState != -1;\n        // decode absState -> state, offset\n        let state = Math.floor(absState / (this._w + 1));\n        let offset = absState % (this._w + 1);\n        // assert offset >= 0;\n        if (position === this._w) {\n            if (state < 3) {\n                const loc = vector * 3 + state;\n                offset += ParametricDescription.unpack(lev2t_parametric_description_offsetIncrs0, loc, 1);\n                state = ParametricDescription.unpack(lev2t_parametric_description_toStates0, loc, 2) - 1;\n            }\n        }\n        else if (position === this._w - 1) {\n            if (state < 5) {\n                const loc = vector * 5 + state;\n                offset += ParametricDescription.unpack(lev2t_parametric_description_offsetIncrs1, loc, 1);\n                state = ParametricDescription.unpack(lev2t_parametric_description_toStates1, loc, 3) - 1;\n            }\n        }\n        else if (position === this._w - 2) {\n            if (state < 13) {\n                const loc = vector * 13 + state;\n                offset += ParametricDescription.unpack(lev2t_parametric_description_offsetIncrs2, loc, 2);\n                state = ParametricDescription.unpack(lev2t_parametric_description_toStates2, loc, 4) - 1;\n            }\n        }\n        else if (position === this._w - 3) {\n            if (state < 28) {\n                const loc = vector * 28 + state;\n                offset += ParametricDescription.unpack(lev2t_parametric_description_offsetIncrs3, loc, 2);\n                state = ParametricDescription.unpack(lev2t_parametric_description_toStates3, loc, 5) - 1;\n            }\n        }\n        else if (position === this._w - 4) {\n            if (state < 45) {\n                const loc = vector * 45 + state;\n                offset += ParametricDescription.unpack(offsetIncrs4, loc, 3);\n                state = ParametricDescription.unpack(toStates4, loc, 6) - 1;\n            }\n        }\n        else {\n            if (state < 45) {\n                const loc = vector * 45 + state;\n                offset += ParametricDescription.unpack(offsetIncrs5, loc, 3);\n                state = ParametricDescription.unpack(toStates5, loc, 6) - 1;\n            }\n        }\n        if (state === -1) {\n            // null state\n            return -1;\n        }\n        else {\n            // translate back to abs\n            return state * (this._w + 1) + offset;\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/fuzzy/levenshtein_automata.ts\n\n\n\n/**\n * From org/apache/lucene/util/automaton/LevenshteinAutomata.java\n * @hidden\n */\nclass levenshtein_automata_LevenshteinAutomata {\n    constructor(input, editDistance) {\n        this._word = input;\n        this._editDistance = editDistance;\n        this._alphabet = [...new Set(this._word)].sort((a, b) => a - b);\n        this._numRanges = 0;\n        this._rangeLower = new Array(this._alphabet.length + 2);\n        this._rangeUpper = new Array(this._alphabet.length + 2);\n        // calculate the unicode range intervals that exclude the alphabet\n        // these are the ranges for all unicode characters not in the alphabet\n        let lower = 0;\n        for (let i = 0; i < this._alphabet.length; i++) {\n            const higher = this._alphabet[i];\n            if (higher > lower) {\n                this._rangeLower[this._numRanges] = lower;\n                this._rangeUpper[this._numRanges] = higher - 1;\n                this._numRanges++;\n            }\n            lower = higher + 1;\n        }\n        /* add the final endpoint */\n        if (lower <= MAX_CODE_POINT) {\n            this._rangeLower[this._numRanges] = lower;\n            this._rangeUpper[this._numRanges] = MAX_CODE_POINT;\n            this._numRanges++;\n        }\n        if (editDistance === 1) {\n            this._description = new lev1t_parametric_description_Lev1TParametricDescription(input.length);\n        }\n        else {\n            this._description = new lev2t_parametric_description_Lev2TParametricDescription(input.length);\n        }\n    }\n    /**\n     * Transforms the NDFA to a DFA.\n     * @returns {Automaton}\n     */\n    toAutomaton() {\n        let automat = new Automaton();\n        const range = 2 * this._editDistance + 1;\n        // the number of states is based on the length of the word and the edit distance\n        const numStates = this._description.size();\n        // Prefix is not needed to be handled by the automaton.\n        // stateOffset = 0;\n        automat.createState();\n        // create all states, and mark as accept states if appropriate\n        for (let i = 1; i < numStates; i++) {\n            let state = automat.createState();\n            automat.setAccept(state, this._description.isAccept(i));\n        }\n        for (let k = 0; k < numStates; k++) {\n            const xpos = this._description.getPosition(k);\n            if (xpos < 0) {\n                continue;\n            }\n            const end = xpos + Math.min(this._word.length - xpos, range);\n            for (let x = 0; x < this._alphabet.length; x++) {\n                const ch = this._alphabet[x];\n                const cvec = this._getVector(ch, xpos, end);\n                const dest = this._description.transition(k, xpos, cvec);\n                if (dest >= 0) {\n                    automat.addTransition(k, dest, ch, ch);\n                }\n            }\n            const dest = this._description.transition(k, xpos, 0);\n            if (dest >= 0) {\n                for (let r = 0; r < this._numRanges; r++) {\n                    automat.addTransition(k, dest, this._rangeLower[r], this._rangeUpper[r]);\n                }\n            }\n        }\n        // assert automat.deterministic;\n        automat.finishState();\n        return automat;\n    }\n    _getVector(x, pos, end) {\n        let vector = 0;\n        for (let i = pos; i < end; i++) {\n            vector <<= 1;\n            if (this._word[i] === x) {\n                vector |= 1;\n            }\n        }\n        return vector;\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/index_searcher.ts\n\n\n\n\n\nfunction calculateMinShouldMatch(optionalClauseCount, spec) {\n    if (spec === undefined) {\n        return 1;\n    }\n    if (typeof spec === "number") {\n        return (spec < 0) ? optionalClauseCount + spec : spec;\n    }\n    let result = optionalClauseCount;\n    if (spec.includes("<")) {\n        // Parse conditional minimumShouldMatch.;\n        for (const s of spec.split(" ")) {\n            const parts = s.split("<");\n            const upperBound = parseInt(parts[0]);\n            if (optionalClauseCount <= upperBound) {\n                return result;\n            }\n            else {\n                result = calculateMinShouldMatch(optionalClauseCount, parts[1]);\n            }\n        }\n        return result;\n    }\n    if (spec.includes("%")) {\n        // Parse percentage.\n        const percent = parseInt(spec.slice(0, -1));\n        const calc = (result * percent) * (1 / 100);\n        result = (calc < 0) ? result + Math.ceil(calc) : Math.floor(calc);\n    }\n    else {\n        const calc = parseInt(spec);\n        result = (calc < 0) ? result + calc : calc;\n    }\n    return (result < 1) ? 1 : result;\n}\n/**\n * @hidden\n */\nclass index_searcher_IndexSearcher {\n    /**\n     * Constructs an index searcher.\n     * @param {Dict<InvertedIndex>} invIdxs - the inverted indexes\n     * @param {Set<number>} docs - the ids of the documents\n     */\n    constructor(invIdxs, docs) {\n        this._invIdxs = invIdxs;\n        this._docs = docs;\n        this._scorer = new Scorer(this._invIdxs);\n    }\n    search(query) {\n        let queryResults = this._recursive(query.query, true);\n        // Do final scoring.\n        if (query.calculate_scoring !== undefined ? query.calculate_scoring : true) {\n            return this._scorer.finalScore(query, queryResults);\n        }\n        const result = {};\n        for (const key of queryResults.keys()) {\n            result[key] = { score: 1 };\n        }\n        return result;\n    }\n    setDirty() {\n        this._scorer.setDirty();\n    }\n    _recursive(query, doScoring) {\n        let queryResults = new Map();\n        const boost = query.boost !== undefined ? query.boost : 1;\n        const fieldName = query.field !== undefined ? query.field : null;\n        let root = null;\n        let analyzer = null;\n        if (this._invIdxs[fieldName] !== undefined) {\n            root = this._invIdxs[fieldName].root;\n            analyzer = this._invIdxs[fieldName].analyzer;\n        }\n        switch (query.type) {\n            case "bool": {\n                queryResults = null;\n                if (query.must !== undefined) {\n                    queryResults = this._getUnique(query.must, doScoring, queryResults);\n                }\n                if (query.filter !== undefined) {\n                    queryResults = this._getUnique(query.filter, null, queryResults);\n                }\n                if (query.should !== undefined) {\n                    const shouldDocs = this._getAll(query.should, doScoring);\n                    let empty = false;\n                    if (queryResults === null) {\n                        empty = true;\n                        queryResults = new Map();\n                    }\n                    const msm = Math.max(1, calculateMinShouldMatch(query.should.length, query.minimum_should_match));\n                    if (empty && msm === 1) {\n                        // Take all documents.\n                        queryResults = shouldDocs;\n                    }\n                    else {\n                        // Remove documents with fewer matches.\n                        for (const [docId, res] of shouldDocs) {\n                            if (res.length >= msm) {\n                                if (queryResults.has(docId)) {\n                                    queryResults.get(docId).push(...res);\n                                }\n                                else if (empty) {\n                                    queryResults.set(docId, res);\n                                }\n                                else {\n                                    queryResults.delete(docId);\n                                }\n                            }\n                        }\n                    }\n                }\n                // Match all documents if must/filter/should is not defined.\n                if (queryResults === null) {\n                    queryResults = this._recursive({ type: "match_all" }, false);\n                }\n                if (query.not !== undefined) {\n                    let notDocs = this._getAll(query.not, null);\n                    // Remove all matching documents.\n                    for (const docId of notDocs.keys()) {\n                        if (queryResults.has(docId)) {\n                            queryResults.delete(docId);\n                        }\n                    }\n                }\n                // Boost query results afterwards.\n                if (boost !== 1) {\n                    for (const [_, result] of queryResults) {\n                        for (let i = 0; i < result.length; i++) {\n                            result[i].boost *= boost;\n                        }\n                    }\n                }\n                break;\n            }\n            case "term": {\n                const cps = toCodePoints(query.value);\n                let termIdx = inverted_index_InvertedIndex.getTermIndex(cps, root);\n                this._scorer.score(fieldName, boost, termIdx, doScoring, queryResults, cps);\n                break;\n            }\n            case "terms": {\n                for (let i = 0; i < query.value.length; i++) {\n                    const cps = toCodePoints(query.value[i]);\n                    let termIdx = inverted_index_InvertedIndex.getTermIndex(cps, root);\n                    this._scorer.score(fieldName, boost, termIdx, doScoring, queryResults, cps);\n                }\n                break;\n            }\n            case "fuzzy": {\n                const [f, idf] = fuzzySearch(query, root);\n                for (let i = 0; i < f.length; i++) {\n                    this._scorer.score(fieldName, boost * f[i].boost, f[i].index, doScoring, queryResults, f[i].term, idf);\n                }\n                break;\n            }\n            case "wildcard": {\n                const enableScoring = query.enable_scoring !== undefined ? query.enable_scoring : false;\n                const w = wildcardSearch(query, root);\n                for (let i = 0; i < w.length; i++) {\n                    this._scorer.score(fieldName, boost, w[i].index, doScoring && enableScoring, queryResults, w[i].term);\n                }\n                break;\n            }\n            case "match_all": {\n                for (let docId of this._docs) {\n                    this._scorer.scoreConstant(boost, docId, queryResults);\n                }\n                break;\n            }\n            case "constant_score": {\n                let tmpQueryResults = this._getAll(query.filter, false);\n                // Add to each document a constant score.\n                for (const docId of tmpQueryResults.keys()) {\n                    this._scorer.scoreConstant(boost, docId, queryResults);\n                }\n                break;\n            }\n            case "prefix": {\n                const enableScoring = query.enable_scoring !== undefined ? query.enable_scoring : false;\n                const cps = toCodePoints(query.value);\n                const termIdx = inverted_index_InvertedIndex.getTermIndex(cps, root);\n                if (termIdx !== null) {\n                    const termIdxs = inverted_index_InvertedIndex.extendTermIndex(termIdx);\n                    for (let i = 0; i < termIdxs.length; i++) {\n                        this._scorer.score(fieldName, boost, termIdxs[i].index, doScoring && enableScoring, queryResults, [...cps, ...termIdxs[i].term]);\n                    }\n                }\n                break;\n            }\n            case "exists": {\n                if (root !== null) {\n                    for (const docId of this._invIdxs[fieldName].docStore.keys()) {\n                        this._scorer.scoreConstant(boost, docId, queryResults);\n                    }\n                }\n                break;\n            }\n            case "match": {\n                const terms = analyze(analyzer, query.value);\n                const operator = query.operator !== undefined ? query.operator : "or";\n                const boolQuery = { type: "bool" };\n                const subQueries = [];\n                if (operator === "or") {\n                    if (query.minimum_should_match !== undefined) {\n                        boolQuery.minimum_should_match = query.minimum_should_match;\n                    }\n                    // Create a should query.\n                    boolQuery.should = subQueries;\n                }\n                else {\n                    // Create a must query.\n                    boolQuery.must = subQueries;\n                }\n                boolQuery.boost = boost;\n                if (query.fuzziness !== undefined) {\n                    let prefixLength = query.prefix_length !== undefined ? query.prefix_length : 2;\n                    let extended = query.extended !== undefined ? query.extended : false;\n                    // Add each fuzzy.\n                    for (let i = 0; i < terms.length; i++) {\n                        subQueries.push({\n                            type: "fuzzy", field: fieldName, value: terms[i], fuzziness: query.fuzziness,\n                            prefix_length: prefixLength, extended: extended\n                        });\n                    }\n                }\n                else {\n                    // Add each term.\n                    for (let i = 0; i < terms.length; i++) {\n                        subQueries.push({ type: "term", field: fieldName, value: terms[i] });\n                    }\n                }\n                queryResults = this._recursive(boolQuery, doScoring);\n                break;\n            }\n            default:\n                break;\n        }\n        return queryResults;\n    }\n    _getUnique(queries, doScoring, queryResults) {\n        if (queries.length === 0) {\n            return queryResults;\n        }\n        for (let i = 0; i < queries.length; i++) {\n            let currDocs = this._recursive(queries[i], doScoring);\n            if (queryResults === null) {\n                queryResults = this._recursive(queries[0], doScoring);\n                continue;\n            }\n            for (const docId of queryResults.keys()) {\n                if (!currDocs.has(docId)) {\n                    queryResults.delete(docId);\n                }\n                else {\n                    queryResults.get(docId).push(...currDocs.get(docId));\n                }\n            }\n        }\n        return queryResults;\n    }\n    _getAll(queries, doScoring, queryResults = new Map()) {\n        for (let i = 0; i < queries.length; i++) {\n            let currDocs = this._recursive(queries[i], doScoring);\n            for (const docId of currDocs.keys()) {\n                if (!queryResults.has(docId)) {\n                    queryResults.set(docId, currDocs.get(docId));\n                }\n                else {\n                    queryResults.get(docId).push(...currDocs.get(docId));\n                }\n            }\n        }\n        return queryResults;\n    }\n}\n/**\n * Calculates the levenshtein distance. Specialized version.\n * Copyright Kigiri: https://github.com/kigiri\n *           Milot Mirdita: https://github.com/milot-mirdita\n *           Toni Neubert:  https://github.com/Viatorus/\n * @param {string} a - a string\n * @param {string} b - a string\n */\nfunction calculateLevenshteinDistance(a, b) {\n    let i;\n    let j;\n    let prev;\n    let val;\n    const row = Array(a.length + 1);\n    // init the row\n    for (i = 0; i <= a.length; i++) {\n        row[i] = i;\n    }\n    // fill in the rest\n    for (i = 1; i <= b.length; i++) {\n        prev = i;\n        for (j = 1; j <= a.length; j++) {\n            if (b[i - 1] === a[j - 1]) { // match\n                val = row[j - 1];\n            }\n            else {\n                val = Math.min(row[j - 1] + 1, // substitution\n                Math.min(prev + 1, // insertion\n                row[j] + 1)); // deletion\n                // transposition\n                if (i > 1 && j > 1 && b[i - 2] === a[j - 1] && a[j - 2] === b[i - 1]) {\n                    val = Math.min(val, row[j - 1] - (a[j - 1] === b[i - 1] ? 1 : 0));\n                }\n            }\n            row[j - 1] = prev;\n            prev = val;\n        }\n        row[a.length] = prev;\n    }\n    return row[a.length];\n}\n/**\n * Performs a fuzzy search.\n * @param {FuzzyQuery} query - the fuzzy query\n * @param {Index} root - the root index\n * @returns {[FuzzyResult, number]} - the fuzzy results and the maximum df\n */\nfunction fuzzySearch(query, root) {\n    let value = toCodePoints(query.value);\n    let fuzziness = query.fuzziness !== undefined ? query.fuzziness : "AUTO";\n    if (fuzziness === "AUTO") {\n        if (value.length <= 2) {\n            fuzziness = 0;\n        }\n        else if (value.length <= 5) {\n            fuzziness = 1;\n        }\n        else {\n            fuzziness = 2;\n        }\n    }\n    let prefixLength = query.prefix_length !== undefined ? query.prefix_length : 0;\n    let extended = query.extended !== undefined ? query.extended : false;\n    // Do just a prefix search if zero fuzziness.\n    if (fuzziness === 0) {\n        prefixLength = value.length;\n    }\n    let result = [];\n    let startIdx = root;\n    let prefix = value.slice(0, prefixLength);\n    let fuzzy = value;\n    let df = 0;\n    // Perform a prefix search.\n    if (prefixLength !== 0) {\n        startIdx = inverted_index_InvertedIndex.getTermIndex(prefix, startIdx);\n        fuzzy = fuzzy.slice(prefixLength);\n    }\n    // No startIdx found.\n    if (startIdx === null) {\n        return [result, df];\n    }\n    // Fuzzy is not necessary anymore, because prefix search includes the whole query value.\n    if (fuzzy.length === 0) {\n        if (extended) {\n            // Add all terms down the index.\n            const all = inverted_index_InvertedIndex.extendTermIndex(startIdx);\n            for (let i = 0; i < all.length; i++) {\n                result.push({ index: all[i].index, term: all[i].term, boost: 1 });\n                df = Math.max(df, all[i].index.df);\n            }\n        }\n        else if (startIdx.dc !== undefined) {\n            // Add prefix search result.\n            result.push({ index: startIdx, term: value, boost: 1 });\n            df = startIdx.df;\n        }\n        return [result, df];\n    }\n    // The matching term.\n    const term = [0];\n    // Create an automaton from the fuzzy.\n    const automaton = new RunAutomaton(new levenshtein_automata_LevenshteinAutomata(fuzzy, fuzziness).toAutomaton());\n    function determineEditDistance(state, term, fuzzy) {\n        // Check how many edits this fuzzy can still do.\n        let ed = 0;\n        state = automaton.step(state, 0);\n        if (state !== -1 && automaton.isAccept(state)) {\n            ed++;\n            state = automaton.step(state, 0);\n            if (state !== -1 && automaton.isAccept(state)) {\n                ed++;\n            }\n            // Special handling for smaller terms.\n            if (term.length < fuzzy.length) {\n                if (ed !== fuzziness) {\n                    return calculateLevenshteinDistance(term, fuzzy);\n                }\n                // Include the term and fuzzy length.\n                ed -= fuzzy.length - term.length;\n            }\n        }\n        return fuzziness - ed;\n    }\n    function recursive(state, key, idx) {\n        term[term.length - 1] = key;\n        // Check the current key of term with the automaton.\n        state = automaton.step(state, key);\n        if (state === -1) {\n            return;\n        }\n        if (automaton.isAccept(state)) {\n            if (extended) {\n                // Add all terms down the index.\n                const all = inverted_index_InvertedIndex.extendTermIndex(idx);\n                for (let i = 0; i < all.length; i++) {\n                    result.push({ index: all[i].index, term: all[i].term, boost: 1 });\n                    df = Math.max(df, all[i].index.df);\n                }\n                return;\n            }\n            else if (idx.df !== undefined) {\n                // Calculate boost.\n                const distance = determineEditDistance(state, term, fuzzy);\n                const boost = Math.max(0, 1 - distance / Math.min(prefix.length + term.length, value.length));\n                result.push({ index: idx, term: [...prefix, ...term], boost });\n                df = Math.max(df, idx.df);\n            }\n        }\n        term.push(0);\n        for (const child of idx) {\n            recursive(state, child[0], child[1]);\n        }\n        term.pop();\n    }\n    for (const child of startIdx) {\n        recursive(0, child[0], child[1]);\n    }\n    return [result, df];\n}\n/**\n * Performs a wildcard search.\n * @param {WildcardQuery} query - the wildcard query\n * @param {Index} root - the root index\n * @returns {Array} - the results\n */\nfunction wildcardSearch(query, root) {\n    let wildcard = toCodePoints(query.value);\n    let result = [];\n    function recursive(index, idx = 0, term = [], escaped = false) {\n        if (index === null) {\n            return;\n        }\n        if (idx === wildcard.length) {\n            if (index.df !== undefined) {\n                result.push({ index: index, term: term.slice() });\n            }\n            return;\n        }\n        // Escaped character.\n        if (!escaped && wildcard[idx] === 92 /* \\ */) {\n            recursive(index, idx + 1, term, true);\n        }\n        else if (!escaped && wildcard[idx] === 63 /* ? */) {\n            for (const child of index) {\n                recursive(child[1], idx + 1, [...term, child[0]]);\n            }\n        }\n        else if (!escaped && wildcard[idx] === 42 /* * */) {\n            // Check if asterisk is last wildcard character\n            if (idx + 1 === wildcard.length) {\n                const all = inverted_index_InvertedIndex.extendTermIndex(index);\n                for (let i = 0; i < all.length; i++) {\n                    recursive(all[i].index, idx + 1, [...term, ...all[i].term]);\n                }\n            }\n            else {\n                // Iterate over the whole tree.\n                recursive(index, idx + 1, term, false);\n                const indices = [{ index: index, term: [] }];\n                do {\n                    const index = indices.pop();\n                    for (const child of index.index) {\n                        recursive(child[1], idx + 1, [...term, ...index.term, child[0]]);\n                        indices.push({ index: child[1], term: [...index.term, child[0]] });\n                    }\n                } while (indices.length !== 0);\n            }\n        }\n        else {\n            recursive(inverted_index_InvertedIndex.getTermIndex([wildcard[idx]], index), idx + 1, [...term, wildcard[idx]]);\n        }\n    }\n    recursive(root);\n    return result;\n}\n\n// EXTERNAL MODULE: ./packages/common/plugin.ts\nvar common_plugin = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/full_text_search.ts\n\n\n\nclass full_text_search_FullTextSearch {\n    /**\n     * Initialize the full-text search for the given fields.\n     * @param {object[]} fieldOptions - the field options\n     * @param {string} fieldOptions.field - the name of the property field\n     * @param {boolean=true} fieldOptions.store - flag to indicate if the full-text search should be stored on serialization or\n     *  rebuild on deserialization\n     * @param {boolean=true} fieldOptions.optimizeChanges - flag to optimize updating and deleting of documents\n     *    (requires more memory but performs faster)\n     * @param {Analyzer} fieldOptions.analyzer - an analyzer for the field\n     * @param {string} [id] - the property name of the document index\n     */\n    constructor(fieldOptions = [], id) {\n        this._invIdxs = {};\n        // Create an inverted index for each field.\n        for (let i = 0; i < fieldOptions.length; i++) {\n            let fieldOption = fieldOptions[i];\n            this._invIdxs[fieldOption.field] = new inverted_index_InvertedIndex(fieldOption);\n        }\n        this._id = id;\n        this._docs = new Set();\n        this._idxSearcher = new index_searcher_IndexSearcher(this._invIdxs, this._docs);\n    }\n    /**\n     * Registers the full-text search as plugin.\n     */\n    static register() {\n        common_plugin["a" /* PLUGINS */]["FullTextSearch"] = full_text_search_FullTextSearch;\n    }\n    addDocument(doc, id = doc[this._id]) {\n        let fieldNames = Object.keys(this._invIdxs);\n        for (let i = 0, fieldName; i < fieldNames.length, fieldName = fieldNames[i]; i++) {\n            let field = doc[fieldName];\n            // Skip null and undefined.\n            if (field === null || field === undefined) {\n                continue;\n            }\n            if (typeof field !== "string") {\n                // Convert number to string.\n                if (typeof field === "number") {\n                    field = field.toString();\n                }\n                else {\n                    throw TypeError("Unsupported field type for full text search.");\n                }\n            }\n            this._invIdxs[fieldName].insert(field, id);\n        }\n        this._docs.add(id);\n        this._idxSearcher.setDirty();\n    }\n    removeDocument(doc, id = doc[this._id]) {\n        let fieldNames = Object.keys(this._invIdxs);\n        for (let i = 0; i < fieldNames.length; i++) {\n            this._invIdxs[fieldNames[i]].remove(id);\n        }\n        this._docs.delete(id);\n        this._idxSearcher.setDirty();\n    }\n    updateDocument(doc, id = doc[this._id]) {\n        this.removeDocument(doc, id);\n        this.addDocument(doc, id);\n    }\n    clear() {\n        for (let id of this._docs) {\n            this.removeDocument(null, id);\n        }\n    }\n    search(query) {\n        return this._idxSearcher.search(query);\n    }\n    toJSON() {\n        let serialized = { id: this._id, ii: {} };\n        let fieldNames = Object.keys(this._invIdxs);\n        for (let i = 0; i < fieldNames.length; i++) {\n            const fieldName = fieldNames[i];\n            serialized.ii[fieldName] = this._invIdxs[fieldName].toJSON();\n        }\n        return serialized;\n    }\n    static fromJSONObject(serialized, analyzers = {}) {\n        let fts = new full_text_search_FullTextSearch([], serialized.id);\n        let fieldNames = Object.keys(serialized.ii);\n        for (let i = 0; i < fieldNames.length; i++) {\n            const fieldName = fieldNames[i];\n            fts._invIdxs[fieldName] = inverted_index_InvertedIndex.fromJSONObject(serialized.ii[fieldName], analyzers[fieldName]);\n        }\n        return fts;\n    }\n}\n\n// CONCATENATED MODULE: ./packages/full-text-search/src/index.ts\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "FullTextSearch", function() { return full_text_search_FullTextSearch; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "analyze", function() { return analyze; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "StandardAnalyzer", function() { return analyzer_StandardAnalyzer; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "whitespaceTokenizer", function() { return whitespaceTokenizer; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "lowercaseTokenFilter", function() { return lowercaseTokenFilter; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "uppercaseTokenFilter", function() { return uppercaseTokenFilter; });\n\n\n\n\nfull_text_search_FullTextSearch["Analyzer"] = {};\nfull_text_search_FullTextSearch["Analyzer"]["analyze"] = analyze;\nfull_text_search_FullTextSearch["Analyzer"]["StandardAnalyzer"] = analyzer_StandardAnalyzer;\nfull_text_search_FullTextSearch["Tokenizer"] = {};\nfull_text_search_FullTextSearch["Tokenizer"]["whitespaceTokenizer"] = whitespaceTokenizer;\nfull_text_search_FullTextSearch["TokenFilter"] = {};\nfull_text_search_FullTextSearch["TokenFilter"]["lowercaseTokenFilter"] = lowercaseTokenFilter;\nfull_text_search_FullTextSearch["TokenFilter"]["uppercaseTokenFilter"] = uppercaseTokenFilter;\n\n/* harmony default export */ var src = __webpack_exports__["default"] = (full_text_search_FullTextSearch);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function("return this")() || (1, eval)("this");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=lokidb.full-text-search.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxva2lkYi9mdWxsLXRleHQtc2VhcmNoL2xva2lkYi5mdWxsLXRleHQtc2VhcmNoLmpzP2M0N2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUtvSDtBQUMxSCxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsMkZBQTJGLGdCQUFnQixFQUFFO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtEQUFrRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0dBQXdHLHdDQUF3QyxFQUFFO0FBQ2xKLGlHQUFpRyxnQkFBZ0IsRUFBRTtBQUNuSCwwR0FBMEcsa0NBQWtDLEVBQUU7QUFDOUksNkdBQTZHLDRCQUE0QixFQUFFO0FBQzNJLDhHQUE4Ryw2QkFBNkIsRUFBRTtBQUM3SSw4R0FBOEcsNkJBQTZCLEVBQUU7Ozs7O0FBSzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsQ0FBQztBQUNEIiwiZmlsZSI6IjQ1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiQGxva2lkYi9mdWxsLXRleHQtc2VhcmNoXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkBsb2tpZGIvZnVsbC10ZXh0LXNlYXJjaFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHsgcm9vdFtcIkBsb2tpZGIvZnVsbC10ZXh0LXNlYXJjaFwiXSA9IGZhY3RvcnkoKTsgcm9vdFtcIkxva2lGdWxsVGV4dFNlYXJjaFwiXSA9IHJvb3RbXCJAbG9raWRiL2Z1bGwtdGV4dC1zZWFyY2hcIl0uZGVmYXVsdDsgfVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUExVR0lOUzsgfSk7XG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gICAgbGV0IGdsb2I7XG4gICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgZ2xvYiA9IGdsb2JhbDtcbiAgICB9KShnbG9iYWwgIT09IHVuZGVmaW5lZCAmJiBnbG9iYWwgfHwgdGhpcyk7XG4gICAgcmV0dXJuIGdsb2I7XG59XG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgY29uc3QgZ2xvYmFsID0gZ2V0R2xvYmFsKCk7XG4gICAgY29uc3Qgc3ltID0gU3ltYm9sLmZvcihcIkxPS0lcIik7XG4gICAgaWYgKGdsb2JhbFtzeW1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2xvYmFsW3N5bV0gPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFtzeW1dO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFBMVUdJTlMgPSBjcmVhdGUoKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMikpKVxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZnVsbC10ZXh0LXNlYXJjaC9zcmMvYW5hbHl6ZXIvdG9rZW5pemVyLnRzXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBhdCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgaW50byB0b2tlbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gdGhlIHRva2Vuc1xuICovXG5mdW5jdGlvbiB3aGl0ZXNwYWNlVG9rZW5pemVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KC9bXFxzXSsvKTtcbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9mdWxsLXRleHQtc2VhcmNoL3NyYy9hbmFseXplci90b2tlbl9maWx0ZXIudHNcbi8qKlxuICogQ29udmVydHMgYSB0b2tlbiB0byBsb3dlcmNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSB0aGUgdG9rZW5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGxvd2VyY2FzZWQgdG9rZW5cbiAqL1xuZnVuY3Rpb24gbG93ZXJjYXNlVG9rZW5GaWx0ZXIodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4udG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB0b2tlbiB0byB1cHBlcmNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSB0aGUgdG9rZW5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIHVwcGVyY2FzZWQgdG9rZW5cbiAqL1xuZnVuY3Rpb24gdXBwZXJjYXNlVG9rZW5GaWx0ZXIodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4udG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9mdWxsLXRleHQtc2VhcmNoL3NyYy9hbmFseXplci9hbmFseXplci50c1xuXG5cbi8qKlxuICogQW5hbHl6ZXMgYSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0ge0FuYWx5emVyfSBhbmFseXplciAtIHRoZSBhbmFseXplclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHRoZSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSB0aGUgdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGFuYWx5emUoYW5hbHl6ZXIsIHN0cikge1xuICAgIGlmIChhbmFseXplci5jaGFyX2ZpbHRlcikge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFuYWx5emVyLmNoYXJfZmlsdGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBzdHIgPSBhbmFseXplci5jaGFyX2ZpbHRlcltqXShzdHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IGFuYWx5emVyLnRva2VuaXplcihzdHIpO1xuICAgIGlmIChhbmFseXplci50b2tlbl9maWx0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYW5hbHl6ZXIudG9rZW5fZmlsdGVyLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zW2ldID0gYW5hbHl6ZXIudG9rZW5fZmlsdGVyW2tdKHRva2Vuc1tpXSwgaSwgdG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgZW1wdHkgdG9rZW5zLlxuICAgIHJldHVybiB0b2tlbnMuZmlsdGVyKCh0b2tlbikgPT4gdG9rZW4pO1xufVxuLyoqXG4gKiBBbiBhbmFseXplciB3aXRoIHRoZSB3aGl0ZXNwYWNlIHRva2VuaXplciBhbmQgdGhlIGxvd2VyY2FzZSB0b2tlbiBmaWx0ZXIuXG4gKi9cbmNsYXNzIGFuYWx5emVyX1N0YW5kYXJkQW5hbHl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHdoaXRlc3BhY2VUb2tlbml6ZXI7XG4gICAgICAgIHRoaXMudG9rZW5fZmlsdGVyID0gW2xvd2VyY2FzZVRva2VuRmlsdGVyXTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZnVsbC10ZXh0LXNlYXJjaC9zcmMvaW52ZXJ0ZWRfaW5kZXgudHNcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICogQHBhcmFtIHN0ciAtIHRoZSBzdHJpbmdcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdG8gY29kZSBwb2ludHNcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gdG9Db2RlUG9pbnRzKHN0cikge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7KSB7XG4gICAgICAgIGNvbnN0IGNociA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGlmIChjaHIgPj0gMHhEODAwICYmIGNociA8PSAweERCRkYpIHtcbiAgICAgICAgICAgIC8vIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgci5wdXNoKDB4MTAwMDAgKyAoKGNociAtIDB4RDgwMCkgPDwgMTApIHwgKGxvdyAtIDB4REMwMCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3JkaW5hcnkgY2hhcmFjdGVyXG4gICAgICAgICAgICByLnB1c2goY2hyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbi8qKlxuICogSW52ZXJ0ZWQgaW5kZXggY2xhc3MgaGFuZGxlcyBmZWF0dXJlZCB0ZXh0IHNlYXJjaCBmb3Igc3BlY2lmaWMgZG9jdW1lbnQgZmllbGRzLlxuICogQGhpZGRlblxuICovXG5jbGFzcyBpbnZlcnRlZF9pbmRleF9JbnZlcnRlZEluZGV4IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnN0b3JlPXRydWVdIC0gaW52ZXJ0ZWQgaW5kZXggd2lsbCBiZSBzdG9yZWQgYXQgc2VyaWFsaXphdGlvbiByYXRoZXIgdGhhbiByZWJ1aWx0IG9uIGxvYWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm9wdGltaXplQ2hhbmdlcz10cnVlXSAtIGZsYWcgdG8gc3RvcmUgYWRkaXRpb25hbCBtZXRhZGF0YSBpbnNpZGUgdGhlIGluZGV4IGZvciBiZXR0ZXJcbiAgICAgKiAgcGVyZm9ybWFuY2UgaWYgYW4gZXhpc3RpbmcgZmllbGQgaXMgdXBkYXRlZCBvciByZW1vdmVkXG4gICAgICogQHBhcmFtIHtBbmFseXplcn0gW29wdGlvbnMuYW5hbHl6ZXI9XSAtIHRoZSBhbmFseXplciBvZiB0aGlzIGludmVydGVkIGluZGV4XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZG9jQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmRvY1N0b3JlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRvdGFsRmllbGRMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTWFwKCk7XG4gICAgICAgICh7XG4gICAgICAgICAgICBzdG9yZTogdGhpcy5fc3RvcmUgPSB0cnVlLFxuICAgICAgICAgICAgb3B0aW1pemVDaGFuZ2VzOiB0aGlzLl9vcHRpbWl6ZUNoYW5nZXMgPSB0cnVlLFxuICAgICAgICAgICAgYW5hbHl6ZXI6IHRoaXMuYW5hbHl6ZXIgPSBuZXcgYW5hbHl6ZXJfU3RhbmRhcmRBbmFseXplcigpXG4gICAgICAgIH0gPSBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBkZWZpbmVkIGZpZWxkcyBvZiBhIGRvY3VtZW50IHRvIHRoZSBpbnZlcnRlZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgLSB0aGUgZmllbGQgdG8gYWRkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRvY0lkIC0gdGhlIGRvYyBpZCBvZiB0aGUgZmllbGRcbiAgICAgKi9cbiAgICBpbnNlcnQoZmllbGQsIGRvY0lkKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY1N0b3JlLmhhcyhkb2NJZCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiRmllbGQgYWxyZWFkeSBhZGRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9rZW5pemUgZG9jdW1lbnQgZmllbGQuXG4gICAgICAgIGNvbnN0IGZpZWxkVG9rZW5zID0gYW5hbHl6ZSh0aGlzLmFuYWx5emVyLCBmaWVsZCk7XG4gICAgICAgIGlmIChmaWVsZFRva2Vucy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgLy8gQWRkIGVtcHR5IGZpZWxkIGF0IGxlYXN0IHRvIGRvY3VtZW50IHN0b3JlIGZvciBxdWVyeSAnZXhpc3RzJy5cbiAgICAgICAgICAgIHRoaXMuZG9jU3RvcmUuc2V0KGRvY0lkLCB7IGZpZWxkTGVuZ3RoOiAwIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxGaWVsZExlbmd0aCArPSBmaWVsZFRva2Vucy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZG9jQ291bnQgKz0gMTtcbiAgICAgICAgdGhpcy5kb2NTdG9yZS5zZXQoZG9jSWQsIHsgZmllbGRMZW5ndGg6IGZpZWxkVG9rZW5zLmxlbmd0aCB9KTtcbiAgICAgICAgLy8gSG9sZHMgcmVmZXJlbmNlcyB0byBlYWNoIGluZGV4IG9mIGEgZG9jdW1lbnQuXG4gICAgICAgIGNvbnN0IGluZGV4UmVmID0gW107XG4gICAgICAgIGlmICh0aGlzLl9vcHRpbWl6ZUNoYW5nZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMuZG9jU3RvcmUuZ2V0KGRvY0lkKSwge1xuICAgICAgICAgICAgICAgIGluZGV4UmVmOiB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogaW5kZXhSZWYgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCB1bmlxdWUgZmllbGQgdGVybXMuXG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbmV3IFNldChmaWVsZFRva2VucykpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0ZXJtIGZyZXF1ZW5jeS5cbiAgICAgICAgICAgIGxldCB0ZiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkVG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkVG9rZW5zW2pdID09PSB0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICArK3RmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0ZXJtIHRvIGluZGV4IHRyZWUuXG4gICAgICAgICAgICBsZXQgYnJhbmNoID0gdGhpcy5yb290O1xuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIHRvQ29kZVBvaW50cyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBicmFuY2guZ2V0KGMpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYSA9IGJyYW5jaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmFuY2guc2V0KGMsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJhbmNoID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGVybSBpbmZvIHRvIGluZGV4IGxlYWYuXG4gICAgICAgICAgICBpZiAoYnJhbmNoLmRjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBicmFuY2guZGMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgYnJhbmNoLmRmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyYW5jaC5kYy5zZXQoZG9jSWQsIHRmKTtcbiAgICAgICAgICAgIGJyYW5jaC5kZiArPSAxO1xuICAgICAgICAgICAgLy8gU3RvcmUgaW5kZXggbGVhZiBmb3IgZGVsZXRpb24uXG4gICAgICAgICAgICBpbmRleFJlZi5wdXNoKGJyYW5jaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcmVsZXZhbnQgdGVybXMgb2YgYSBkb2N1bWVudCBmcm9tIHRoZSBpbnZlcnRlZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZG9jSWQgLSB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgcmVtb3ZlKGRvY0lkKSB7XG4gICAgICAgIGlmICghdGhpcy5kb2NTdG9yZS5oYXMoZG9jSWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jU3RvcmUgPSB0aGlzLmRvY1N0b3JlLmdldChkb2NJZCk7XG4gICAgICAgIC8vIFJlbW92ZSBkb2N1bWVudC5cbiAgICAgICAgdGhpcy5kb2NTdG9yZS5kZWxldGUoZG9jSWQpO1xuICAgICAgICBpZiAoZG9jU3RvcmUuZmllbGRMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY0NvdW50IC09IDE7XG4gICAgICAgIC8vIFJlZHVjZSB0b3RhbCBmaWVsZCBsZW5ndGguXG4gICAgICAgIHRoaXMudG90YWxGaWVsZExlbmd0aCAtPSBkb2NTdG9yZS5maWVsZExlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplQ2hhbmdlcykge1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCB0ZXJtIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZG9jSWQgZnJvbSBkb2NzIGFuZCBkZWNyZW1lbnQgZG9jdW1lbnQgZnJlcXVlbmN5LlxuICAgICAgICAgICAgY29uc3QgaW5kZXhSZWYgPSBkb2NTdG9yZS5pbmRleFJlZjtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXhSZWYubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBpbmRleFJlZltqXTtcbiAgICAgICAgICAgICAgICBpbmRleC5kZiAtPSAxO1xuICAgICAgICAgICAgICAgIGluZGV4LmRjLmRlbGV0ZShkb2NJZCk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbm8gZG9jdW1lbnQgaXMgbGVmdCBmb3IgY3VycmVudCB0cmVlLlxuICAgICAgICAgICAgICAgIGlmIChpbmRleC5kZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgdW51c2VkIG1ldGEgZGF0YSBvZiBicmFuY2guXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmRleC5kZjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGluZGV4LmRjO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3Igc3ViIGJyYW5jaGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXguc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRlcm0gYnJhbmNoIGlmIG5vdCB1c2VkIGFueW1vcmUuXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIHRyZWUgdXB3YXJkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGluZGV4LnBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHBhcmVudCByZWZlcmVuY2UgZm9yIHByZXZlbnRpbmcgbWVtb3J5IGxlYWsgKGN5Y2xlIHJlZmVyZW5jZSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW5kZXgucGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGFyZW50LmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjaGlsZCBmb3JtIHBhcmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmdldChrZXkpID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpbmRleC5wYSAhPT0gdW5kZWZpbmVkICYmIGluZGV4LnNpemUgPT09IDAgJiYgaW5kZXguZGYgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHRoaXMucm9vdCwgZG9jSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRlcm0gaW5kZXggb2YgYSB0ZXJtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJtIC0gdGhlIHRlcm1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcm9vdCAtIHRoZSB0ZXJtIGluZGV4IHRvIHN0YXJ0IGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSB0aGUgcG9zaXRpb24gb2YgdGhlIHRlcm0gc3RyaW5nIHRvIHN0YXJ0IGZyb21cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHRlcm0gaW5kZXggb3IgbnVsbCBpZiB0aGUgdGVybSBpcyBub3QgaW4gdGhlIHRlcm0gdHJlZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VGVybUluZGV4KHRlcm0sIHJvb3QsIHN0YXJ0ID0gMCkge1xuICAgICAgICBpZiAoc3RhcnQgPj0gdGVybS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHRlcm0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHJvb3QuZ2V0KHRlcm1baV0pO1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3QgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0ZW5kcyBhIHRlcm0gaW5kZXggdG8gYWxsIGF2YWlsYWJsZSB0ZXJtIGxlYWZzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpZHggLSB0aGUgdGVybSBpbmRleCB0byBzdGFydCBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gW3Rlcm09W11dIC0gdGhlIGN1cnJlbnQgdGVybVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRlcm1JbmRpY2VzIC0gYWxsIGV4dGVuZGVkIGluZGljZXMgd2l0aCB0aGVpciB0ZXJtXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIEFycmF5IHdpdGggdGVybSBpbmRpY2VzIGFuZCBleHRlbnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZXh0ZW5kVGVybUluZGV4KGlkeCwgdGVybSA9IFtdLCB0ZXJtSW5kaWNlcyA9IFtdKSB7XG4gICAgICAgIGlmIChpZHguZGYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGVybUluZGljZXMucHVzaCh7IGluZGV4OiBpZHgsIHRlcm06IHRlcm0uc2xpY2UoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0ZXJtLnB1c2goMCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaWR4KSB7XG4gICAgICAgICAgICB0ZXJtW3Rlcm0ubGVuZ3RoIC0gMV0gPSBjaGlsZFswXTtcbiAgICAgICAgICAgIGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXguZXh0ZW5kVGVybUluZGV4KGNoaWxkWzFdLCB0ZXJtLCB0ZXJtSW5kaWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybS5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRlcm1JbmRpY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGludmVydGVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHt7ZG9jU3RvcmU6ICosIF9maWVsZHM6ICosIGluZGV4OiAqfX1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdG9yZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfc3RvcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgX29wdGltaXplQ2hhbmdlczogdGhpcy5fb3B0aW1pemVDaGFuZ2VzLFxuICAgICAgICAgICAgICAgIGRvY0NvdW50OiB0aGlzLmRvY0NvdW50LFxuICAgICAgICAgICAgICAgIGRvY1N0b3JlOiBbLi4udGhpcy5kb2NTdG9yZV0sXG4gICAgICAgICAgICAgICAgdG90YWxGaWVsZExlbmd0aDogdGhpcy50b3RhbEZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHJvb3Q6IGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXguX3NlcmlhbGl6ZUluZGV4KHRoaXMucm9vdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9zdG9yZTogZmFsc2UsXG4gICAgICAgICAgICBfb3B0aW1pemVDaGFuZ2VzOiB0aGlzLl9vcHRpbWl6ZUNoYW5nZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplIHRoZSBpbnZlcnRlZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge3tkb2NTdG9yZTogKiwgX2ZpZWxkczogKiwgaW5kZXg6ICp9fSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgaW52ZXJ0ZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtBbmFseXplcn0gYW5hbHl6ZXJbdW5kZWZpbmVkXSAtIGFuIGFuYWx5emVyXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OT2JqZWN0KHNlcmlhbGl6ZWQsIGFuYWx5emVyKSB7XG4gICAgICAgIGNvbnN0IGludklkeCA9IG5ldyBpbnZlcnRlZF9pbmRleF9JbnZlcnRlZEluZGV4KHtcbiAgICAgICAgICAgIHN0b3JlOiBzZXJpYWxpemVkLl9zdG9yZSxcbiAgICAgICAgICAgIG9wdGltaXplQ2hhbmdlczogc2VyaWFsaXplZC5fb3B0aW1pemVDaGFuZ2VzLFxuICAgICAgICAgICAgYW5hbHl6ZXI6IGFuYWx5emVyXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VyaWFsaXplZC5fc3RvcmUpIHtcbiAgICAgICAgICAgIGludklkeC5kb2NDb3VudCA9IHNlcmlhbGl6ZWQuZG9jQ291bnQ7XG4gICAgICAgICAgICBpbnZJZHguZG9jU3RvcmUgPSBuZXcgTWFwKHNlcmlhbGl6ZWQuZG9jU3RvcmUpO1xuICAgICAgICAgICAgaW52SWR4LnRvdGFsRmllbGRMZW5ndGggPSBzZXJpYWxpemVkLnRvdGFsRmllbGRMZW5ndGg7XG4gICAgICAgICAgICBpbnZJZHgucm9vdCA9IGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXguX2Rlc2VyaWFsaXplSW5kZXgoc2VyaWFsaXplZC5yb290KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52SWR4Ll9vcHRpbWl6ZUNoYW5nZXMpIHtcbiAgICAgICAgICAgIGludklkeC5fcmVnZW5lcmF0ZShpbnZJZHgucm9vdCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludklkeDtcbiAgICB9XG4gICAgc3RhdGljIF9zZXJpYWxpemVJbmRleChpZHgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHt9O1xuICAgICAgICBpZiAoaWR4LmRjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuZCA9IHsgZGY6IGlkeC5kZiwgZGM6IFsuLi5pZHguZGNdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkeC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGlkeCkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGNoaWxkWzBdKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXguX3NlcmlhbGl6ZUluZGV4KGNoaWxkWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXplZC5rID0ga2V5cztcbiAgICAgICAgc2VyaWFsaXplZC52ID0gdmFsdWVzO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgc3RhdGljIF9kZXNlcmlhbGl6ZUluZGV4KHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoc2VyaWFsaXplZC5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZC5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWR4LnNldChzZXJpYWxpemVkLmtbaV0sIGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXguX2Rlc2VyaWFsaXplSW5kZXgoc2VyaWFsaXplZC52W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmlhbGl6ZWQuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZHguZGYgPSBzZXJpYWxpemVkLmQuZGY7XG4gICAgICAgICAgICBpZHguZGMgPSBuZXcgTWFwKHNlcmlhbGl6ZWQuZC5kYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHBhcmVudCBvZiB0byBlYWNoIGluZGV4IGFuZCByZWdlbmVyYXRlIHRoZSBpbmRleFJlZi5cbiAgICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleCAtIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7SW5kZXh9IHBhcmVudCAtIHRoZSBwYXJlbnRcbiAgICAgKi9cbiAgICBfcmVnZW5lcmF0ZShpbmRleCwgcGFyZW50KSB7XG4gICAgICAgIC8vIFNldCBwYXJlbnQuXG4gICAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluZGV4LnBhID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBzdWJ0cmVlLlxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluZGV4LnZhbHVlcygpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWdlbmVyYXRlKGNoaWxkLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4LmRjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudHMgb2YgdGVybS5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9jSWQgb2YgaW5kZXguZGMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGRvY3VtZW50IHN0b3JlIGF0IHNwZWNpZmljIGRvY3VtZW50L2ZpZWxkLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuZG9jU3RvcmUuZ2V0KGRvY0lkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmLmluZGV4UmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFJlZjogeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IFtdIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNldCByZWZlcmVuY2UgdG8gdGVybSBpbmRleC5cbiAgICAgICAgICAgICAgICByZWYuaW5kZXhSZWYucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIHRoZSB3aG9sZSBpbnZlcnRlZCBpbmRleCBhbmQgcmVtb3ZlIHRoZSBkb2N1bWVudC5cbiAgICAgKiBEZWxldGUgYnJhbmNoIGlmIG5vdCBuZWVkZWQgYW55bW9yZS5cbiAgICAgKiBGdW5jdGlvbiBpcyBuZWVkZWQgaWYgaW5kZXggaXMgdXNlZCB3aXRob3V0IG9wdGltaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge0luZGV4fSBpZHggLSB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZG9jSWQgLSB0aGUgZG9jIGlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaW5kZXggaXMgZW1wdHlcbiAgICAgKi9cbiAgICBfcmVtb3ZlKGlkeCwgZG9jSWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpZHgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrb3V0IGJyYW5jaC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmUoY2hpbGRbMV0sIGRvY0lkKSkge1xuICAgICAgICAgICAgICAgIGlkeC5kZWxldGUoY2hpbGRbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBkb2NJZCBmcm9tIGRvY3MgYW5kIGRlY3JlbWVudCBkb2N1bWVudCBmcmVxdWVuY3kuXG4gICAgICAgIGlmIChpZHguZGYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlkeC5kYy5oYXMoZG9jSWQpKSB7XG4gICAgICAgICAgICAgICAgaWR4LmRmIC09IDE7XG4gICAgICAgICAgICAgICAgaWR4LmRjLmRlbGV0ZShkb2NJZCk7XG4gICAgICAgICAgICAgICAgLy8gRGVsZXRlIHVudXNlZCBtZXRhIGRhdGEgb2YgYnJhbmNoLlxuICAgICAgICAgICAgICAgIGlmIChpZHguZGYgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGlkeC5kZjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGlkeC5kYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkeC5zaXplID09PSAwICYmIGlkeC5kYyA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9mdWxsLXRleHQtc2VhcmNoL3NyYy9zY29yZXIudHNcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTY29yZXIge1xuICAgIGNvbnN0cnVjdG9yKGludklkeHMpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5faW52SWR4cyA9IGludklkeHM7XG4gICAgfVxuICAgIHNldERpcnR5KCkge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIH1cbiAgICBzY29yZShmaWVsZE5hbWUsIGJvb3N0LCB0ZXJtSWR4LCBkb1Njb3JpbmcsIHF1ZXJ5UmVzdWx0cywgdGVybSwgZGYgPSAwKSB7XG4gICAgICAgIGlmICh0ZXJtSWR4ID09PSBudWxsIHx8IHRlcm1JZHguZGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkZiA9IHRoaXMuX2lkZihmaWVsZE5hbWUsIGRmIHx8IHRlcm1JZHguZGYpO1xuICAgICAgICBmb3IgKGNvbnN0IFtkb2NJZCwgdGZdIG9mIHRlcm1JZHguZGMpIHtcbiAgICAgICAgICAgIGlmICghcXVlcnlSZXN1bHRzLmhhcyhkb2NJZCkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdHMuc2V0KGRvY0lkLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9TY29yaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQk0yNSBzY29yaW5nLlxuICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cy5nZXQoZG9jSWQpLnB1c2goeyB0ZiwgaWRmLCBib29zdCwgZmllbGROYW1lLCB0ZXJtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9TY29yaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnN0YW50IHNjb3JpbmcuXG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzLnNldChkb2NJZCwgW3sgYm9vc3QgfV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gWmVybyBzY29yaW5nLlxuICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cy5zZXQoZG9jSWQsIFt7IGJvb3N0OiAwIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzY29yZUNvbnN0YW50KGJvb3N0LCBkb2NJZCwgcXVlcnlSZXN1bHRzKSB7XG4gICAgICAgIGlmICghcXVlcnlSZXN1bHRzLmhhcyhkb2NJZCkpIHtcbiAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cy5zZXQoZG9jSWQsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBxdWVyeVJlc3VsdHMuZ2V0KGRvY0lkKS5wdXNoKHsgYm9vc3QgfSk7XG4gICAgICAgIHJldHVybiBxdWVyeVJlc3VsdHM7XG4gICAgfVxuICAgIGZpbmFsU2NvcmUocXVlcnksIHF1ZXJ5UmVzdWx0cykge1xuICAgICAgICBjb25zdCBmaW5hbFJlc3VsdCA9IHt9O1xuICAgICAgICBjb25zdCBrMSA9IHF1ZXJ5LmJtMjUgIT09IHVuZGVmaW5lZCA/IHF1ZXJ5LmJtMjUuazEgOiAxLjI7XG4gICAgICAgIGNvbnN0IGIgPSBxdWVyeS5ibTI1ICE9PSB1bmRlZmluZWQgPyBxdWVyeS5ibTI1LmIgOiAwLjc1O1xuICAgICAgICBjb25zdCBleHBsYWluID0gcXVlcnkuZXhwbGFpbiAhPT0gdW5kZWZpbmVkID8gcXVlcnkuZXhwbGFpbiA6IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IFtkb2NJZCwgcmVzdWx0XSBvZiBxdWVyeVJlc3VsdHMpIHtcbiAgICAgICAgICAgIGxldCBkb2NTY29yZSA9IDA7XG4gICAgICAgICAgICBsZXQgZG9jRXhwbGFuYXRpb24gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlSZXN1bHQgPSByZXN1bHRbaV07XG4gICAgICAgICAgICAgICAgbGV0IHNjb3JlID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlSZXN1bHQudGYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCTTI1IHNjb3JpbmcuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRmID0gcXVlcnlSZXN1bHQudGY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkTGVuZ3RoID0gU2NvcmVyLl9jYWxjdWxhdGVGaWVsZExlbmd0aCh0aGlzLl9pbnZJZHhzW3F1ZXJ5UmVzdWx0LmZpZWxkTmFtZV0uZG9jU3RvcmUuZ2V0KGRvY0lkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZnRmllbGRMZW5ndGggPSB0aGlzLl9hdmdGaWVsZExlbmd0aChxdWVyeVJlc3VsdC5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0Zk5vcm0gPSAodGYgKiAoazEgKyAxKSkgLyAodGYgKyBrMSAqICgxIC0gYiArIGIgKiAoZmllbGRMZW5ndGggLyBhdmdGaWVsZExlbmd0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgPSBxdWVyeVJlc3VsdC5pZGYgKiB0Zk5vcm0gKiBxdWVyeVJlc3VsdC5ib29zdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGxhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0V4cGxhbmF0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb3N0OiBxdWVyeVJlc3VsdC5ib29zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZTogc2NvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jSUQ6IGRvY0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogcXVlcnlSZXN1bHQuZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnF1ZXJ5UmVzdWx0LnRlcm0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZjogcXVlcnlSZXN1bHQuaWRmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmTm9ybTogdGZOb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmOiB0ZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZExlbmd0aDogZmllbGRMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnRmllbGRMZW5ndGg6IGF2Z0ZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnN0YW50IHNjb3JpbmcuXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gcXVlcnlSZXN1bHQuYm9vc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBsYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NFeHBsYW5hdGlvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29zdDogcXVlcnlSZXN1bHQuYm9vc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHNjb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2NTY29yZSArPSBzY29yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBsYWluKSB7XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHRbZG9jSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29yZTogZG9jU2NvcmUsXG4gICAgICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBkb2NFeHBsYW5hdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3VsdFtkb2NJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlOiBkb2NTY29yZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsUmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgX2NhbGN1bGF0ZUZpZWxkTGVuZ3RoKGZpZWxkTGVuZ3RoKSB7XG4gICAgICAgIC8vIER1bW15IGZ1bmN0aW9uIHRvIGJlIGNvbXBhdGlibGUgdG8gbHVjZW5lIGluIHVuaXQgdGVzdHMuXG4gICAgICAgIHJldHVybiBmaWVsZExlbmd0aDtcbiAgICB9XG4gICAgX2dldENhY2hlKGZpZWxkTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVbZmllbGROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBhdmdGaWVsZExlbmd0aCA9IHRoaXMuX2ludklkeHNbZmllbGROYW1lXS50b3RhbEZpZWxkTGVuZ3RoIC8gdGhpcy5faW52SWR4c1tmaWVsZE5hbWVdLmRvY0NvdW50O1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVbZmllbGROYW1lXSA9IHsgaWRmczoge30sIGF2Z0ZpZWxkTGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2ZpZWxkTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlkZiBieSBlaXRoZXIgY2FsY3VsYXRlIGl0IG9yIHVzZSBhIGNhY2hlZCBvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBmaWVsZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkb2NGcmVxIC0gdGhlIGRvYyBmcmVxdWVuY3kgb2YgdGhlIHRlcm1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgaWRmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaWRmKGZpZWxkTmFtZSwgZG9jRnJlcSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2dldENhY2hlKGZpZWxkTmFtZSk7XG4gICAgICAgIGlmIChjYWNoZS5pZGZzW2RvY0ZyZXFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5pZGZzW2RvY0ZyZXFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZS5pZGZzW2RvY0ZyZXFdID0gTWF0aC5sb2coMSArICh0aGlzLl9pbnZJZHhzW2ZpZWxkTmFtZV0uZG9jQ291bnQgLSBkb2NGcmVxICsgMC41KSAvIChkb2NGcmVxICsgMC41KSk7XG4gICAgfVxuICAgIF9hdmdGaWVsZExlbmd0aChmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKGZpZWxkTmFtZSkuYXZnRmllbGRMZW5ndGg7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2Z1bGwtdGV4dC1zZWFyY2gvc3JjL2Z1enp5L3J1bl9hdXRvbWF0b24udHNcbi8qKlxuICogRnJvbSBvcmcvYXBhY2hlL2x1Y2VuZS91dGlsL2F1dG9tYXRvbi9SdW5BdXRvbWF0b24uamF2YVxuICogQGhpZGRlblxuICovXG5jbGFzcyBSdW5BdXRvbWF0b24ge1xuICAgIGNvbnN0cnVjdG9yKGF1dG9tYXRvbikge1xuICAgICAgICBjb25zdCBzaXplID0gYXV0b21hdG9uLmdldE51bVN0YXRlcygpO1xuICAgICAgICB0aGlzLl9wb2ludHMgPSBhdXRvbWF0b24uZ2V0U3RhcnRQb2ludHMoKTtcbiAgICAgICAgdGhpcy5fYWNjZXB0ID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9ucyA9IG5ldyBBcnJheShzaXplICogdGhpcy5fcG9pbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgc2l6ZTsgbisrKSB7XG4gICAgICAgICAgICB0aGlzLl9hY2NlcHRbbl0gPSBhdXRvbWF0b24uaXNBY2NlcHQobik7XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuX3BvaW50cy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydCBkZXN0ID09PSAtMSB8fCBkZXN0IDwgc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uc1tuICogdGhpcy5fcG9pbnRzLmxlbmd0aCArIGNdID0gYXV0b21hdG9uLnN0ZXAobiwgdGhpcy5fcG9pbnRzW2NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGFzc21hcCA9IG5ldyBBcnJheSgyNTYgLyogYWxwaGFTaXplICovKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBqIDwgdGhpcy5fY2xhc3NtYXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpICsgMSA8IHRoaXMuX3BvaW50cy5sZW5ndGggJiYgaiA9PT0gdGhpcy5fcG9pbnRzW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NsYXNzbWFwW2pdID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGFyQ2xhc3MoYykge1xuICAgICAgICAvLyBiaW5hcnkgc2VhcmNoXG4gICAgICAgIGxldCBhID0gMDtcbiAgICAgICAgbGV0IGIgPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoYiAtIGEgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gKGEgKyBiKSA+Pj4gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2ludHNbZF0gPiBjKSB7XG4gICAgICAgICAgICAgICAgYiA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wb2ludHNbZF0gPCBjKSB7XG4gICAgICAgICAgICAgICAgYSA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgc3RlcChzdGF0ZSwgYykge1xuICAgICAgICBpZiAoYyA+PSB0aGlzLl9jbGFzc21hcC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uc1tzdGF0ZSAqIHRoaXMuX3BvaW50cy5sZW5ndGggKyB0aGlzLmdldENoYXJDbGFzcyhjKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbnNbc3RhdGUgKiB0aGlzLl9wb2ludHMubGVuZ3RoICsgdGhpcy5fY2xhc3NtYXBbY11dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQWNjZXB0KHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY2NlcHRbc3RhdGVdO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9mdWxsLXRleHQtc2VhcmNoL3NyYy9mdXp6eS9hdXRvbWF0b24udHNcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUlOX0NPREVfUE9JTlQgPSAwO1xuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGhpZGRlblxuICovXG5jb25zdCBNQVhfQ09ERV9QT0lOVCA9IDExMTQxMTE7XG5mdW5jdGlvbiBzb3J0QnlEZXN0TWluTWF4KGEsIGIpIHtcbiAgICBpZiAoYVswXSA8IGJbMF0pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhWzBdID4gYlswXSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGFbMV0gPCBiWzFdKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVsxXSA+IGJbMV0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChhWzJdIDwgYlsyXSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFbMl0gPiBiWzJdKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHNvcnRCeU1pbk1heERlc3QoYSwgYikge1xuICAgIGlmIChhWzFdIDwgYlsxXSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFbMV0gPiBiWzFdKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYVsyXSA8IGJbMl0pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhWzJdID4gYlsyXSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGFbMF0gPCBiWzBdKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVswXSA+IGJbMF0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLyoqXG4gKiBGcm9tIG9yZy9hcGFjaGUvbHVjZW5lL3V0aWwvYXV0b21hdG9uL0F1dG9tYXRvbi5qYXZhXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEF1dG9tYXRvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlVHJhbnNpdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RhdGVUcmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9hY2NlcHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX25leHRTdGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJTdGF0ZSA9IC0xO1xuICAgICAgICAvLyB0aGlzLmRldGVybWluaXN0aWMgPSB0cnVlO1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpc0FjY2VwdChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY2NlcHQuaGFzKG4pO1xuICAgIH1cbiAgICBjcmVhdGVTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHRTdGF0ZSsrO1xuICAgIH1cbiAgICBzZXRBY2NlcHQoc3RhdGUsIGFjY2VwdCkge1xuICAgICAgICBpZiAoYWNjZXB0KSB7XG4gICAgICAgICAgICB0aGlzLl9hY2NlcHQuYWRkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdC5kZWxldGUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaFN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VyclN0YXRlICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoQ3VycmVudFN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyU3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmluaXNoQ3VycmVudFN0YXRlKCkge1xuICAgICAgICAvLyBTb3J0IGFsbCB0cmFuc2l0aW9ucy5cbiAgICAgICAgdGhpcy5fc3RhdGVUcmFuc2l0aW9ucy5zb3J0KHNvcnRCeURlc3RNaW5NYXgpO1xuICAgICAgICBsZXQgdXB0byA9IDA7XG4gICAgICAgIGxldCBwID0gWy0xLCAtMSwgLTFdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fc3RhdGVUcmFuc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IHQgPSB0aGlzLl9zdGF0ZVRyYW5zaXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKHBbMF0gPT09IHRbMF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodFsxXSA8PSBwWzJdICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSA+IHBbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbMl0gPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocFswXSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlVHJhbnNpdGlvbnNbdXB0b11bMF0gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVUcmFuc2l0aW9uc1t1cHRvXVsxXSA9IHBbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVRyYW5zaXRpb25zW3VwdG9dWzJdID0gcFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwWzFdID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgcFsyXSA9IHRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlVHJhbnNpdGlvbnNbdXB0b11bMF0gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVRyYW5zaXRpb25zW3VwdG9dWzFdID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVUcmFuc2l0aW9uc1t1cHRvXVsyXSA9IHBbMl07XG4gICAgICAgICAgICAgICAgICAgIHVwdG8rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcFswXSA9IHRbMF07XG4gICAgICAgICAgICAgICAgcFsxXSA9IHRbMV07XG4gICAgICAgICAgICAgICAgcFsyXSA9IHRbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBbMF0gIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBMYXN0IHRyYW5zaXRpb25cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlVHJhbnNpdGlvbnNbdXB0b11bMF0gPSBwWzBdO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVUcmFuc2l0aW9uc1t1cHRvXVsxXSA9IHBbMV07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVRyYW5zaXRpb25zW3VwdG9dWzJdID0gcFsyXTtcbiAgICAgICAgICAgIHVwdG8rKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uc1t0aGlzLl9jdXJyU3RhdGVdID0gdGhpcy5fc3RhdGVUcmFuc2l0aW9ucy5zbGljZSgwLCB1cHRvKS5zb3J0KHNvcnRCeU1pbk1heERlc3QpO1xuICAgICAgICAvLyBpZiAodGhpcy5kZXRlcm1pbmlzdGljICYmIHVwdG8gPiAxKSB7XG4gICAgICAgIC8vICAgbGV0IGxhc3RNYXggPSB0aGlzLnN0YXRlVHJhbnNpdGlvbnNbMF1bMl07XG4gICAgICAgIC8vICAgZm9yIChsZXQgaSA9IDE7IGkgPCB1cHRvOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGxldCBtaW4gPSB0aGlzLnN0YXRlVHJhbnNpdGlvbnNbaV1bMV07XG4gICAgICAgIC8vICAgICBpZiAobWluIDw9IGxhc3RNYXgpIHtcbiAgICAgICAgLy8gICAgICAgdGhpcy5kZXRlcm1pbmlzdGljID0gZmFsc2U7XG4gICAgICAgIC8vICAgICAgIGJyZWFrO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgbGFzdE1heCA9IHRoaXMuc3RhdGVUcmFuc2l0aW9uc1tpXVsyXTtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgdGhpcy5fc3RhdGVUcmFuc2l0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBnZXRTdGFydFBvaW50cygpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHBvaW50c2V0LmFkZChNSU5fQ09ERV9QT0lOVCk7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IE9iamVjdC5rZXlzKHRoaXMuX3RyYW5zaXRpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0cmFucyA9IHRoaXMuX3RyYW5zaXRpb25zW3N0YXRlc1tpXV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRyYW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYW4gPSB0cmFuc1tqXTtcbiAgICAgICAgICAgICAgICBwb2ludHNldC5hZGQodHJhblsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5bMl0gPCBNQVhfQ09ERV9QT0lOVCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNldC5hZGQodHJhblsyXSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShwb2ludHNldCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIH1cbiAgICBzdGVwKHN0YXRlLCBsYWJlbCkge1xuICAgICAgICBsZXQgdHJhbnMgPSB0aGlzLl90cmFuc2l0aW9uc1tzdGF0ZV07XG4gICAgICAgIGlmICh0cmFucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB0cmFuID0gdHJhbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5bMV0gPD0gbGFiZWwgJiYgbGFiZWwgPD0gdHJhblsyXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhblswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXROdW1TdGF0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0U3RhdGU7XG4gICAgfVxuICAgIGFkZFRyYW5zaXRpb24oc291cmNlLCBkZXN0LCBtaW4sIG1heCkge1xuICAgICAgICBpZiAodGhpcy5fY3VyclN0YXRlICE9PSBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyU3RhdGUgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoQ3VycmVudFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyU3RhdGUgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGVUcmFuc2l0aW9ucy5wdXNoKFtkZXN0LCBtaW4sIG1heF0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9mdWxsLXRleHQtc2VhcmNoL3NyYy9mdXp6eS9sb25nLnRzXG4vKipcbiAqIENsYXNzIHN1cHBvcnRzIDY0Qml0IGludGVnZXIgb3BlcmF0aW9ucy5cbiAqIEEgY3V0LWRvd24gdmVyc2lvbiBvZiBkY29kZUlPL2xvbmcuanMuXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExvbmcge1xuICAgIGNvbnN0cnVjdG9yKGxvdyA9IDAsIGhpZ2ggPSAwKSB7XG4gICAgICAgIHRoaXMuX2xvdyA9IGxvdztcbiAgICAgICAgdGhpcy5faGlnaCA9IGhpZ2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBsb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1CaXRzIC0gbnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7TG9uZ30gdGhlIGxvbmdcbiAgICAgKi9cbiAgICBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvbmcoKHRoaXMuX2xvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5faGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuX2hpZ2ggPj4gbnVtQml0cyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9uZygodGhpcy5faGlnaCA+PiAobnVtQml0cyAtIDMyKSksIHRoaXMuX2hpZ2ggPj0gMCA/IDAgOiAtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBsb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bUJpdHMgLSBudW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHtMb25nfSB0aGUgbG9uZ1xuICAgICAqL1xuICAgIHNoaWZ0TGVmdChudW1CaXRzKSB7XG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb25nKHRoaXMuX2xvdyA8PCBudW1CaXRzLCAodGhpcy5faGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLl9sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9uZygwLCB0aGlzLl9sb3cgPDwgKG51bUJpdHMgLSAzMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciAtIHRoZSBvdGhlciBMb25nXG4gICAgICogQHJldHVybnMge0xvbmd9IHRoZSBsb25nXG4gICAgICovXG4gICAgYW5kKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9uZyh0aGlzLl9sb3cgJiBvdGhlci5fbG93LCB0aGlzLl9oaWdoICYgb3RoZXIuX2hpZ2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgdG9JbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb3c7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2Z1bGwtdGV4dC1zZWFyY2gvc3JjL2Z1enp5L3BhcmFtZXRyaWNfZGVzY3JpcHRpb24udHNcblxuY29uc3QgTUFTS1MgPSBbbmV3IExvbmcoMHgxKSwgbmV3IExvbmcoMHgzKSwgbmV3IExvbmcoMHg3KSwgbmV3IExvbmcoMHhmKSxcbiAgICBuZXcgTG9uZygweDFmKSwgbmV3IExvbmcoMHgzZiksIG5ldyBMb25nKDB4N2YpLCBuZXcgTG9uZygweGZmKSxcbiAgICBuZXcgTG9uZygweDFmZiksIG5ldyBMb25nKDB4M2ZmKSwgbmV3IExvbmcoMHg3ZmYpLCBuZXcgTG9uZygweGZmZiksXG4gICAgbmV3IExvbmcoMHgxZmZmKSwgbmV3IExvbmcoMHgzZmZmKSwgbmV3IExvbmcoMHg3ZmZmKSwgbmV3IExvbmcoMHhmZmZmKSxcbiAgICBuZXcgTG9uZygweGYsIDB4MWZmZiksIG5ldyBMb25nKDB4ZiwgMHgzZmZmKSwgbmV3IExvbmcoMHhmLCAweDdmZmYpLCBuZXcgTG9uZygweGYsIDB4ZmZmZiksXG4gICAgbmV3IExvbmcoMHhmZiwgMHgxZmZmKSwgbmV3IExvbmcoMHhmZiwgMHgzZmZmKSwgbmV3IExvbmcoMHhmZiwgMHg3ZmZmKSwgbmV3IExvbmcoMHhmZiwgMHhmZmZmKSxcbiAgICBuZXcgTG9uZygweGZmZiwgMHgxZmZmKSwgbmV3IExvbmcoMHhmZmYsIDB4M2ZmZiksIG5ldyBMb25nKDB4ZmZmLCAweDdmZmYpLCBuZXcgTG9uZygweGZmZiwgMHhmZmZmKSxcbiAgICBuZXcgTG9uZygweGZmZmYsIDB4MWZmZiksIG5ldyBMb25nKDB4ZmZmZiwgMHgzZmZmKSwgbmV3IExvbmcoMHhmZmZmLCAweDdmZmYpLCBuZXcgTG9uZygweGZmZmYsIDB4ZmZmZiksXG4gICAgbmV3IExvbmcoMHhmZmZmZiwgMHgxZmZmKSwgbmV3IExvbmcoMHhmZmZmZiwgMHgzZmZmKSwgbmV3IExvbmcoMHhmZmZmZiwgMHg3ZmZmKSwgbmV3IExvbmcoMHhmZmZmZiwgMHhmZmZmKSxcbiAgICBuZXcgTG9uZygweGZmZmZmZiwgMHgxZmZmKSwgbmV3IExvbmcoMHhmZmZmZmYsIDB4M2ZmZiksIG5ldyBMb25nKDB4ZmZmZmZmLCAweDdmZmYpLCBuZXcgTG9uZygweGZmZmZmZiwgMHhmZmZmKSxcbiAgICBuZXcgTG9uZygweGZmZmZmZmYsIDB4MWZmZiksIG5ldyBMb25nKDB4ZmZmZmZmZiwgMHgzZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmLCAweDdmZmYpLCBuZXcgTG9uZygweGZmZmZmZmYsIDB4ZmZmZiksXG4gICAgbmV3IExvbmcoMHhmZmZmZmZmZiwgMHgxZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZiwgMHgzZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZiwgMHg3ZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZiwgMHhmZmZmKSxcbiAgICBuZXcgTG9uZygweGZmZmZmZmZmZiwgMHgxZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZmYsIDB4M2ZmZiksIG5ldyBMb25nKDB4ZmZmZmZmZmZmLCAweDdmZmYpLCBuZXcgTG9uZygweGZmZmZmZmZmZiwgMHhmZmZmKSxcbiAgICBuZXcgTG9uZygweGZmZmZmZmZmZmYsIDB4MWZmZiksIG5ldyBMb25nKDB4ZmZmZmZmZmZmZiwgMHgzZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZmZmLCAweDdmZmYpLCBuZXcgTG9uZygweGZmZmZmZmZmZmYsIDB4ZmZmZiksXG4gICAgbmV3IExvbmcoMHhmZmZmZmZmZmZmZiwgMHgxZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZmZmZiwgMHgzZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZmZmZiwgMHg3ZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZmZmZiwgMHhmZmZmKSxcbiAgICBuZXcgTG9uZygweGZmZmZmZmZmZmZmZiwgMHgxZmZmKSwgbmV3IExvbmcoMHhmZmZmZmZmZmZmZmYsIDB4M2ZmZiksIG5ldyBMb25nKDB4ZmZmZmZmZmZmZmZmLCAweDdmZmYpXTtcbi8qKlxuICogRnJvbSBvcmcvYXBhY2hlL2x1Y2VuZS91dGlsL2F1dG9tYXRvbi9MZXZlbnNodGVpbkF1dG9tYXRhLmphdmEjUGFyYW1ldHJpY0Rlc2NyaXB0aW9uXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBhcmFtZXRyaWNEZXNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IodywgbiwgbWluRXJyb3JzKSB7XG4gICAgICAgIHRoaXMuX3cgPSB3O1xuICAgICAgICB0aGlzLl9uID0gbjtcbiAgICAgICAgdGhpcy5fbWluRXJyb3JzID0gbWluRXJyb3JzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgbmVlZGVkIHRvIGNvbXB1dGUgYSBMZXZlbnNodGVpbiBERkFcbiAgICAgKi9cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluRXJyb3JzLmxlbmd0aCAqICh0aGlzLl93ICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgPGNvZGU+c3RhdGU8L2NvZGU+IGluIGFueSBMZXZlbnNodGVpbiBERkEgaXMgYW4gYWNjZXB0IHN0YXRlIChmaW5hbCBzdGF0ZSkuXG4gICAgICovXG4gICAgaXNBY2NlcHQoYWJzU3RhdGUpIHtcbiAgICAgICAgLy8gZGVjb2RlIGFic1N0YXRlIC0+IHN0YXRlLCBvZmZzZXRcbiAgICAgICAgbGV0IHN0YXRlID0gTWF0aC5mbG9vcihhYnNTdGF0ZSAvICh0aGlzLl93ICsgMSkpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gYWJzU3RhdGUgJSAodGhpcy5fdyArIDEpO1xuICAgICAgICAvL2Fzc2VydCBvZmZzZXQgPj0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3cgLSBvZmZzZXQgKyB0aGlzLl9taW5FcnJvcnNbc3RhdGVdIDw9IHRoaXMuX247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIGluIHRoZSBpbnB1dCB3b3JkIGZvciBhIGdpdmVuIDxjb2RlPnN0YXRlPC9jb2RlPi5cbiAgICAgKiBUaGlzIGlzIHRoZSBtaW5pbWFsIGJvdW5kYXJ5IGZvciB0aGUgc3RhdGUuXG4gICAgICovXG4gICAgZ2V0UG9zaXRpb24oYWJzU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGFic1N0YXRlICUgKHRoaXMuX3cgKyAxKTtcbiAgICB9XG4gICAgc3RhdGljIHVucGFjayhkYXRhLCBpbmRleCwgYml0c1BlclZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJpdExvYyA9IGJpdHNQZXJWYWx1ZSAqIGluZGV4O1xuICAgICAgICBjb25zdCBkYXRhTG9jID0gKGJpdExvYyA+PiA2KTtcbiAgICAgICAgY29uc3QgYml0U3RhcnQgPSAoYml0TG9jICYgNjMpO1xuICAgICAgICBpZiAoYml0U3RhcnQgKyBiaXRzUGVyVmFsdWUgPD0gNjQpIHtcbiAgICAgICAgICAgIC8vIG5vdCBzcGxpdFxuICAgICAgICAgICAgcmV0dXJuIGRhdGFbZGF0YUxvY10uc2hpZnRSaWdodChiaXRTdGFydCkuYW5kKE1BU0tTW2JpdHNQZXJWYWx1ZSAtIDFdKS50b0ludCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3BsaXRcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSA2NCAtIGJpdFN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIChkYXRhW2RhdGFMb2NdLnNoaWZ0UmlnaHQoYml0U3RhcnQpLmFuZChNQVNLU1twYXJ0IC0gMV0pKS50b0ludCgpXG4gICAgICAgICAgICAgICAgKyAoZGF0YVsxICsgZGF0YUxvY10uYW5kKE1BU0tTW2JpdHNQZXJWYWx1ZSAtIHBhcnQgLSAxXSkuc2hpZnRMZWZ0KHBhcnQpKS50b0ludCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2Z1bGwtdGV4dC1zZWFyY2gvc3JjL2Z1enp5L2xldjF0X3BhcmFtZXRyaWNfZGVzY3JpcHRpb24udHNcblxuXG4vLyAxIHZlY3RvcnM7IDIgc3RhdGVzIHBlciB2ZWN0b3I7IGFycmF5IGxlbmd0aCA9IDJcbmNvbnN0IHRvU3RhdGVzMCA9IFtuZXcgTG9uZygweDIpXTtcbmNvbnN0IG9mZnNldEluY3JzMCA9IFtuZXcgTG9uZygweDApXTtcbi8vIDIgdmVjdG9yczsgMyBzdGF0ZXMgcGVyIHZlY3RvcjsgYXJyYXkgbGVuZ3RoID0gNlxuY29uc3QgdG9TdGF0ZXMxID0gW25ldyBMb25nKDB4YTQzKV07XG5jb25zdCBvZmZzZXRJbmNyczEgPSBbbmV3IExvbmcoMHgzOCldO1xuLy8gNCB2ZWN0b3JzOyA2IHN0YXRlcyBwZXIgdmVjdG9yOyBhcnJheSBsZW5ndGggPSAyNFxuY29uc3QgdG9TdGF0ZXMyID0gW25ldyBMb25nKDB4ODIxNDAwMDMsIDB4MzQ1MzQ5MTQpLCBuZXcgTG9uZygweDZkKV07XG5jb25zdCBvZmZzZXRJbmNyczIgPSBbbmV3IExvbmcoMHg1NWEyMDAwMCwgMHg1NTU1KV07XG4vLyA4IHZlY3RvcnM7IDYgc3RhdGVzIHBlciB2ZWN0b3I7IGFycmF5IGxlbmd0aCA9IDQ4XG5jb25zdCB0b1N0YXRlczMgPSBbbmV3IExvbmcoMHg5MDBDMDAwMywgMHgyMTUyMDg1NCksIG5ldyBMb25nKDB4NDUzNDkxNmQsIDB4NWI0ZDE5YTIpLCBuZXcgTG9uZygweGRhMzQpXTtcbmNvbnN0IG9mZnNldEluY3JzMyA9IFtuZXcgTG9uZygweDIwZmMwMDAwLCAweDU1NTVhZTBhKSwgbmV3IExvbmcoMHg1NTU1NTU1NSldO1xuLy8gc3RhdGUgbWFwXG4vLyAgIDAgLT4gWygwLCAwKV1cbi8vICAgMSAtPiBbKDAsIDEpXVxuLy8gICAyIC0+IFsoMCwgMSksICgxLCAxKV1cbi8vICAgMyAtPiBbKDAsIDEpLCAoMiwgMSldXG4vLyAgIDQgLT4gW3QoMCwgMSksICgwLCAxKSwgKDEsIDEpLCAoMiwgMSldXG4vLyAgIDUgLT4gWygwLCAxKSwgKDEsIDEpLCAoMiwgMSldXG4vKipcbiAqIEZyb20gb3JnL2FwYWNoZS9sdWNlbmUvdXRpbC9hdXRvbWF0b24vTGV2MVRQYXJhbWV0cmljRGVzY3JpcHRpb24uamF2YVxuICogQGhpZGRlblxuICovXG5jbGFzcyBsZXYxdF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX0xldjFUUGFyYW1ldHJpY0Rlc2NyaXB0aW9uIGV4dGVuZHMgUGFyYW1ldHJpY0Rlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih3KSB7XG4gICAgICAgIHN1cGVyKHcsIDEsIFswLCAxLCAwLCAtMSwgLTEsIC0xXSk7XG4gICAgfVxuICAgIHRyYW5zaXRpb24oYWJzU3RhdGUsIHBvc2l0aW9uLCB2ZWN0b3IpIHtcbiAgICAgICAgLy8gbnVsbCBhYnNTdGF0ZSBzaG91bGQgbmV2ZXIgYmUgcGFzc2VkIGluXG4gICAgICAgIC8vYXNzZXJ0IGFic1N0YXRlICE9IC0xO1xuICAgICAgICAvLyBkZWNvZGUgYWJzU3RhdGUgLT4gc3RhdGUsIG9mZnNldFxuICAgICAgICBsZXQgc3RhdGUgPSBNYXRoLmZsb29yKGFic1N0YXRlIC8gKHRoaXMuX3cgKyAxKSk7XG4gICAgICAgIGxldCBvZmZzZXQgPSBhYnNTdGF0ZSAlICh0aGlzLl93ICsgMSk7XG4gICAgICAgIC8vYXNzZXJ0IG9mZnNldCA+PSAwO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IHRoaXMuX3cpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2MgPSB2ZWN0b3IgKiAyICsgc3RhdGU7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IFBhcmFtZXRyaWNEZXNjcmlwdGlvbi51bnBhY2sob2Zmc2V0SW5jcnMwLCBsb2MsIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gUGFyYW1ldHJpY0Rlc2NyaXB0aW9uLnVucGFjayh0b1N0YXRlczAsIGxvYywgMikgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSB0aGlzLl93IC0gMSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlIDwgMykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IHZlY3RvciAqIDMgKyBzdGF0ZTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gUGFyYW1ldHJpY0Rlc2NyaXB0aW9uLnVucGFjayhvZmZzZXRJbmNyczEsIGxvYywgMSk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBQYXJhbWV0cmljRGVzY3JpcHRpb24udW5wYWNrKHRvU3RhdGVzMSwgbG9jLCAyKSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPT09IHRoaXMuX3cgLSAyKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPCA2KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jID0gdmVjdG9yICogNiArIHN0YXRlO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBQYXJhbWV0cmljRGVzY3JpcHRpb24udW5wYWNrKG9mZnNldEluY3JzMiwgbG9jLCAyKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFBhcmFtZXRyaWNEZXNjcmlwdGlvbi51bnBhY2sodG9TdGF0ZXMyLCBsb2MsIDMpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA8IDYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2MgPSB2ZWN0b3IgKiA2ICsgc3RhdGU7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IFBhcmFtZXRyaWNEZXNjcmlwdGlvbi51bnBhY2sob2Zmc2V0SW5jcnMzLCBsb2MsIDIpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gUGFyYW1ldHJpY0Rlc2NyaXB0aW9uLnVucGFjayh0b1N0YXRlczMsIGxvYywgMykgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIG51bGwgc3RhdGVcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBiYWNrIHRvIGFic1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlICogKHRoaXMuX3cgKyAxKSArIG9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9mdWxsLXRleHQtc2VhcmNoL3NyYy9mdXp6eS9sZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uLnRzXG5cblxuLy8gMSB2ZWN0b3JzOyAzIHN0YXRlcyBwZXIgdmVjdG9yOyBhcnJheSBsZW5ndGggPSAzXG5jb25zdCBsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX3RvU3RhdGVzMCA9IC8qMiBiaXRzIHBlciB2YWx1ZSAqLyBbXG4gICAgbmV3IExvbmcoMHgyMylcbl07XG5jb25zdCBsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX29mZnNldEluY3JzMCA9IC8qMSBiaXRzIHBlciB2YWx1ZSAqLyBbXG4gICAgbmV3IExvbmcoMHgwKVxuXTtcbi8vIDIgdmVjdG9yczsgNSBzdGF0ZXMgcGVyIHZlY3RvcjsgYXJyYXkgbGVuZ3RoID0gMTBcbmNvbnN0IGxldjJ0X3BhcmFtZXRyaWNfZGVzY3JpcHRpb25fdG9TdGF0ZXMxID0gLyozIGJpdHMgcGVyIHZhbHVlICovIFtcbiAgICBuZXcgTG9uZygweDEzNjg4YjQ0KVxuXTtcbmNvbnN0IGxldjJ0X3BhcmFtZXRyaWNfZGVzY3JpcHRpb25fb2Zmc2V0SW5jcnMxID0gLyoxIGJpdHMgcGVyIHZhbHVlICovIFtcbiAgICBuZXcgTG9uZygweDNlMClcbl07XG4vLyA0IHZlY3RvcnM7IDEzIHN0YXRlcyBwZXIgdmVjdG9yOyBhcnJheSBsZW5ndGggPSA1MlxuY29uc3QgbGV2MnRfcGFyYW1ldHJpY19kZXNjcmlwdGlvbl90b1N0YXRlczIgPSAvKjQgYml0cyBwZXIgdmFsdWUgKi8gW1xuICAgIG5ldyBMb25nKDB4NTIwMGI1MDQsIDB4NjBkYmIwYjApLCBuZXcgTG9uZygweDI3MDYyMjI3LCAweDUyMzMyMTc2KSwgbmV3IExvbmcoMHgxNDMyMzIzNSwgMHgyMzU1NTQzMiksIG5ldyBMb25nKDB4NDM1NClcbl07XG5jb25zdCBsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX29mZnNldEluY3JzMiA9IC8qMiBiaXRzIHBlciB2YWx1ZSAqLyBbXG4gICAgbmV3IExvbmcoMHgwMDAwMjAwMCwgMHg1NTUwODBhOCksIG5ldyBMb25nKDB4NTU1NTU1NTUsIDB4NTUpXG5dO1xuLy8gOCB2ZWN0b3JzOyAyOCBzdGF0ZXMgcGVyIHZlY3RvcjsgYXJyYXkgbGVuZ3RoID0gMjI0XG5jb25zdCBsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX3RvU3RhdGVzMyA9IC8qNSBiaXRzIHBlciB2YWx1ZSAqLyBbXG4gICAgbmV3IExvbmcoMHg0MDA1OTQwNCwgMHhlNzAxYzAyOSksIG5ldyBMb25nKDB4MDBhNTAwMDAsIDB4YTAxMDE2MjApLCBuZXcgTG9uZygweGExNDE2Mjg4LCAweGIwMmM4YzQwKSwgbmV3IExvbmcoMHgzMTA4NThjMCwgMHhhODIxMDMyKSxcbiAgICBuZXcgTG9uZygweDBkMjhiMjAxLCAweDMxNDQyMzk4KSwgbmV3IExvbmcoMHg4NDc3ODhlMCwgMHg1MjgxZTUyOCksIG5ldyBMb25nKDB4MDhjMjI4MGUsIDB4YTIzOTgwZDMpLCBuZXcgTG9uZygweGE5NjIyNzhjLCAweDFlMzI5NGIxKSxcbiAgICBuZXcgTG9uZygweDIyODhlNTI4LCAweDhjNDEzMDllKSwgbmV3IExvbmcoMHgwMjFhY2EyMSwgMHgxMTQ0NDQwOSksIG5ldyBMb25nKDB4ODZiMTA4NmIsIDB4MTFhNDYyNDgpLCBuZXcgTG9uZygweDFkNjI0MGM0LCAweDJhNjI1ODk0KSxcbiAgICBuZXcgTG9uZygweDQ4OTA3NGFkLCAweDUwMjRhNTBiKSwgbmV3IExvbmcoMHg1MjBjNDExYSwgMHgxNDgyMWFjYSksIG5ldyBMb25nKDB4MGI1OTRhNDQsIDB4NTg4OGI1ODkpLCBuZXcgTG9uZygweGM0MTFhNDY1LCAweDk0MWQ2NTIwKSxcbiAgICBuZXcgTG9uZygweGFkNmE2MmQ0LCAweDhiNTg5MDc1KSwgbmV3IExvbmcoMHgxYTUwNTVhNClcbl07XG5jb25zdCBsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX29mZnNldEluY3JzMyA9IC8qMiBiaXRzIHBlciB2YWx1ZSAqLyBbXG4gICAgbmV3IExvbmcoMHgwMDAwMjAwMCwgMHgzMGMzMDIpLCBuZXcgTG9uZygweGMzZmMzMzNjLCAweDJhMDAzMGYzKSwgbmV3IExvbmcoMHg4MjgyYTgyMCwgMHgyMzNhMDAzMiksIG5ldyBMb25nKDB4MzJiMjgzYTgsIDB4NTU1NTU1NTUpLFxuICAgIG5ldyBMb25nKDB4NTU1NTU1NTUsIDB4NTU1NTU1NTUpLCBuZXcgTG9uZygweDU1NTU1NTU1LCAweDU1NTU1NTU1KSwgbmV3IExvbmcoMHg1NTU1NTU1NSwgMHg1NTU1NTU1NSlcbl07XG4vLyAxNiB2ZWN0b3JzOyA0NSBzdGF0ZXMgcGVyIHZlY3RvcjsgYXJyYXkgbGVuZ3RoID0gNzIwXG5jb25zdCB0b1N0YXRlczQgPSAvKjYgYml0cyBwZXIgdmFsdWUgKi8gW1xuICAgIG5ldyBMb25nKDB4MDAyYzUwMDQsIDB4MzgwMTQ1MCksIG5ldyBMb25nKDB4MDAwMDBlMzgsIDB4YzUwMDAxNGIpLCBuZXcgTG9uZygweDUxNDAxNDAyLCAweDUxNCksIG5ldyBMb25nKDB4MCksXG4gICAgbmV3IExvbmcoMHgxNDAxMDAwMCwgMHg1MTgwMDBiKSwgbmV3IExvbmcoMHgyOGUyMDIzMCwgMHg5ZjFjMjA4KSwgbmV3IExvbmcoMHg4MzBhNzBjMiwgMHgyMTlmMGRmMCksIG5ldyBMb25nKDB4MDgyMDgyMDAsIDB4ODIwMDAwODIpLFxuICAgIG5ldyBMb25nKDB4NjA4MDA4MDAsIDB4ODA1MDUwMSksIG5ldyBMb25nKDB4MDI2MDI2NDMsIDB4MzA4MjA5ODYpLCBuZXcgTG9uZygweDUwNTA4MDY0LCAweDQ1NjQwMTQyKSwgbmV3IExvbmcoMHgyMDAwMDgzMSwgMHg4NTAwNTE0KSxcbiAgICBuZXcgTG9uZygweDg1MDAyMDgyLCAweDQxNDA1ODIwKSwgbmV3IExvbmcoMHgwOTkwYzIwMSwgMHg0NTYxODA5OCksIG5ldyBMb25nKDB4NTBhMDEwNTEsIDB4ODMxNmQwYyksIG5ldyBMb25nKDB4MDUwZGYwZTAsIDB4MjE0NTE0MjApLFxuICAgIG5ldyBMb25nKDB4MTQ1MDgyMTQsIDB4ZDE0MjE0MCksIG5ldyBMb25nKDB4NTA4MjFjNjAsIDB4M2MyMWMwMTgpLCBuZXcgTG9uZygweGNiMTQyMDg3LCAweDFjYjE0MDMpLCBuZXcgTG9uZygweDE4NTE4MjJjLCAweDgwMDgyMTQ1KSxcbiAgICBuZXcgTG9uZygweDIwODAwMDIwLCAweDIwMDIwOCksIG5ldyBMb25nKDB4ODcxODAzNDUsIDB4ZDAwNjE4MjApLCBuZXcgTG9uZygweDI0OTc2YjA5LCAweGNiMGE4MWNiKSwgbmV3IExvbmcoMHg2MjQ3MDlkMSwgMHg4YjFhNjBlKSxcbiAgICBuZXcgTG9uZygweDgyMjQ5MDg5LCAweDI0OTA4MjApLCBuZXcgTG9uZygweDAwZDJjMDI0LCAweGMzMTQyMWM2KSwgbmV3IExvbmcoMHgxNTQ1NDQyMywgMHgzYzMxNDUxNSksIG5ldyBMb25nKDB4YzIxY2IxNDAsIDB4MzE4NTNjMjIpLFxuICAgIG5ldyBMb25nKDB4MmMyMDgyMTQsIDB4NDUxNDUwMGIpLCBuZXcgTG9uZygweDUwOGIwMDUxLCAweDg3MTgwMzQpLCBuZXcgTG9uZygweDUxMDhmMGM1LCAweGIyY2I0NTUxKSwgbmV3IExvbmcoMHgxY2IwYTgxMCwgMHhlODI0NzE1ZCksXG4gICAgbmV3IExvbmcoMHg5MDhiMGU2MCwgMHgxNDIyY2IxNCksIG5ldyBMb25nKDB4YzAyY2IxNDUsIDB4MzA4MTJjMjIpLCBuZXcgTG9uZygweDBjYjE0MjBjLCAweDg0MjAyMjAyKSwgbmV3IExvbmcoMHgyMGNlMDg1MCwgMHg1YzIwY2UwOCksXG4gICAgbmV3IExvbmcoMHg4YjBkNzBjMiwgMHgyMDgyMDgyMCksIG5ldyBMb25nKDB4MTQyMTQyMDgsIDB4NDIwODUwODIpLCBuZXcgTG9uZygweDUwODMwYzIwLCAweDkyMDgzNDApLCBuZXcgTG9uZygweDEzNjUzNTkyLCAweGM2MTM0ZGM2KSxcbiAgICBuZXcgTG9uZygweDZkYzRkYjRkLCAweGQzMDkzNDFjKSwgbmV3IExvbmcoMHg1NGQzNGQzNCwgMHg2NDI0ZDkwOCksIG5ldyBMb25nKDB4MDMwODE0YzIsIDB4OTIwNzJjMjIpLCBuZXcgTG9uZygweDI0YTMwOTMwLCAweDQyMjA3MjRiKSxcbiAgICBuZXcgTG9uZygweDI1YzkyMGUyLCAweDI0NzBkNzIwKSwgbmV3IExvbmcoMHg5NzVjOTA4MiwgMHg5MmM5MmQ3MCksIG5ldyBMb25nKDB4MDQ5MjRlMDgsIDB4Y2IwODgwYzIpLCBuZXcgTG9uZygweGMyNGMyNDgxLCAweDQ1NzM5NzI4KSxcbiAgICBuZXcgTG9uZygweGRhNjE3NGRhLCAweGM2ZGE0ZGI1KSwgbmV3IExvbmcoMHg1ZDMwOTcxZCwgMHg0YjVkMzVkNyksIG5ldyBMb25nKDB4OTM4MjVjZTIsIDB4MTAzMDgxNWMpLCBuZXcgTG9uZygweDAyMGNiMTQ1LCAweDUxNDQyMDUxKSxcbiAgICBuZXcgTG9uZygweDJjMjIwZTJjLCAweGM1MzgyMTBlKSwgbmV3IExvbmcoMHg1MmNiMGQ3MCwgMHg4NTE0MjE0KSwgbmV3IExvbmcoMHg4NTE0NTE0MiwgMHgyMDRiMDg1MCksIG5ldyBMb25nKDB4NDA1MTQ0MGMsIDB4OTIxNTYwODMpLFxuICAgIG5ldyBMb25nKDB4YTYwZTY1OTUsIDB4NGQ2NjBlNGQpLCBuZXcgTG9uZygweDFjNmRjNjU4LCAweDk0ZDkxNGU0KSwgbmV3IExvbmcoMHgxNDU0ZDM2NSwgMHg4MjY0MjY1OSksIG5ldyBMb25nKDB4NTEwMzA4MTMsIDB4Mjg5MjA3MmMpLFxuICAgIG5ldyBMb25nKDB4Y2IyY2EzMGIsIDB4ZTJjMjIwNzIpLCBuZXcgTG9uZygweDIwNTM4OTEwLCAweDQ1MmM3MGQ3KSwgbmV3IExvbmcoMHg3MDhlMzg5MSwgMHg4YjJjYjJkKSwgbmV3IExvbmcoMHhjMjA0YjI0ZSwgMHg4MWNiMTQ0MCksXG4gICAgbmV3IExvbmcoMHgyOGMyY2EyNCwgMHhkYTQ0ZTM4ZSksIG5ldyBMb25nKDB4ODVkNjYwZTQsIDB4MWRjNmRhNjUpLCBuZXcgTG9uZygweDhlNWQ5MTRlLCAweGUyY2I1ZDMzKSwgbmV3IExvbmcoMHgzODkzODIzOClcbl07XG5jb25zdCBvZmZzZXRJbmNyczQgPSAvKjMgYml0cyBwZXIgdmFsdWUgKi8gW1xuICAgIG5ldyBMb25nKDB4MDAwODAwMDAsIDB4MzAwMjAwMDApLCBuZXcgTG9uZygweDIwYzA2MCksIG5ldyBMb25nKDB4MDQwMDAwMDAsIDB4ODE0OTAwMDApLCBuZXcgTG9uZygweDEwODI0ODI0LCAweDQwMjQ5MjQxKSxcbiAgICBuZXcgTG9uZygweDYwMDAyMDgyLCAweGRiNjAzMGMzKSwgbmV3IExvbmcoMHgzMDFiMGQ4MCwgMHg2YzM2YzA2YyksIG5ldyBMb25nKDB4MDAwZGIwZGIsIDB4YjAxODYxYjApLCBuZXcgTG9uZygweDkxODhlMDZkLCAweDFiNzAzNjIwKSxcbiAgICBuZXcgTG9uZygweDA2ZDg2ZGI3LCAweDgwMDkyMDApLCBuZXcgTG9uZygweDAyNDAyNDkwLCAweDQ5MjBjMjQpLCBuZXcgTG9uZygweDA4MjQ5MDA5LCAweDQ5MDAwMiksIG5ldyBMb25nKDB4MjgxMjQ4MDQsIDB4NDkwODEyODEpLFxuICAgIG5ldyBMb25nKDB4MTI0YTQ0YTIsIDB4MzQ4MDAxMDQpLCBuZXcgTG9uZygweDBkMjQwMjBjLCAweGMzMDkzMDkwKSwgbmV3IExvbmcoMHgyNGMyNGQyNCwgMHg0MDAwOWEwOSksIG5ldyBMb25nKDB4OTIwMTA2MWEsIDB4NDk4NGEwNiksXG4gICAgbmV3IExvbmcoMHg3MTI2OTI2MiwgMHg0OTRkMDQ5MiksIG5ldyBMb25nKDB4OTI0OTI0OTIsIDB4MjQ5MjQ5MjQpLCBuZXcgTG9uZygweDQ5MjQ5MjQ5LCAweDkyNDkyNDkyKSwgbmV3IExvbmcoMHgyNDkyNDkyNCwgMHg0OTI0OTI0OSksXG4gICAgbmV3IExvbmcoMHg5MjQ5MjQ5MiwgMHgyNDkyNDkyNCksIG5ldyBMb25nKDB4NDkyNDkyNDksIDB4OTI0OTI0OTIpLCBuZXcgTG9uZygweDI0OTI0OTI0LCAweDQ5MjQ5MjQ5KSwgbmV3IExvbmcoMHg5MjQ5MjQ5MiwgMHgyNDkyNDkyNCksXG4gICAgbmV3IExvbmcoMHg0OTI0OTI0OSwgMHg5MjQ5MjQ5MiksIG5ldyBMb25nKDB4MjQ5MjQ5MjQsIDB4NDkyNDkyNDkpLCBuZXcgTG9uZygweDkyNDkyNDkyLCAweDI0OTI0OTI0KSwgbmV3IExvbmcoMHg0OTI0OTI0OSwgMHg5MjQ5MjQ5MiksXG4gICAgbmV3IExvbmcoMHgyNDkyNDkyNCwgMHg0OTI0OTI0OSksIG5ldyBMb25nKDB4OTI0OTI0OTIsIDB4MjQ5MjQ5MjQpLCBuZXcgTG9uZygweDQ5MjQ5MjQ5LCAweDkyNDkyNDkyKSwgbmV3IExvbmcoMHgyNDkyNDkyNCwgMHg0OTI0OTI0OSksXG4gICAgbmV3IExvbmcoMHg5MjQ5MjQ5MiwgMHgyNDkyNDkyNCksIG5ldyBMb25nKDB4NDkyNDkyNDksIDB4MjQ5Milcbl07XG4vLyAzMiB2ZWN0b3JzOyA0NSBzdGF0ZXMgcGVyIHZlY3RvcjsgYXJyYXkgbGVuZ3RoID0gMTQ0MFxuY29uc3QgdG9TdGF0ZXM1ID0gLyo2IGJpdHMgcGVyIHZhbHVlICovIFtcbiAgICBuZXcgTG9uZygweDAwMmM1MDA0LCAweDM4MDE0NTApLCBuZXcgTG9uZygweDAwMDAwZTM4LCAweGM1MDAwMTRiKSwgbmV3IExvbmcoMHg1MTQwMTQwMiwgMHg1MTQpLCBuZXcgTG9uZygweDApLFxuICAgIG5ldyBMb25nKDB4MTQwMTAwMDAsIDB4NTE0MDAwYiksIG5ldyBMb25nKDB4MDM4ZTAwZTAsIDB4NTUwMDAwKSwgbmV3IExvbmcoMHgwNjAwYjE4MCwgMHgyNjQ1MTg1MCksIG5ldyBMb25nKDB4MDgyMDgyMDgsIDB4ODIwODIwODIpLFxuICAgIG5ldyBMb25nKDB4NDA4MjA4MjAsIDB4MmM1MDApLCBuZXcgTG9uZygweDgwOGMwMTQ2LCAweDcwODIwYTM4KSwgbmV3IExvbmcoMHg5YzMwODI3YywgMHhjMzdjMjBjMiksIG5ldyBMb25nKDB4MjA4MDA4NjcsIDB4MjA4MjA4KSxcbiAgICBuZXcgTG9uZygweDAyMDAyMDgwLCAweGIxNDAxMDIwKSwgbmV3IExvbmcoMHgwMDUxODAwMCwgMHg4MjhlMjAyMyksIG5ldyBMb25nKDB4MjA5ZjFjMjAsIDB4ODMwYTcwYyksIG5ldyBMb25nKDB4ODUzZGYwZGYsIDB4NTE0NTE0NTApLFxuICAgIG5ldyBMb25nKDB4MTQ1MDgyMTQsIDB4MTYxNDIxNDIpLCBuZXcgTG9uZygweDMwODA1MDUwLCAweDYwMjYwMjY0KSwgbmV3IExvbmcoMHg0MzA4MjA5OCwgMHgyNTA1MDgwNiksIG5ldyBMb25nKDB4MTQ1NjQwMTQsIDB4NDIwMDAwODMpLFxuICAgIG5ldyBMb25nKDB4MjA4NTAwNTEsIDB4ODUwMDIwOCksIG5ldyBMb25nKDB4MTQxNDA1ODIsIDB4ODA5OTBjMjApLCBuZXcgTG9uZygweDA4MjYxODA5LCAweDgyMDE5MjAyKSwgbmV3IExvbmcoMHg5MDA2MDk0MSwgMHg4OTIwNTE5KSxcbiAgICBuZXcgTG9uZygweGMyMmNiMjQyLCAweDIyNDkyNDkyKSwgbmV3IExvbmcoMHgwMTYyNDkyYywgMHg0MzA4MDUwNSksIG5ldyBMb25nKDB4ODYwMjYwMjYsIDB4ODA0MTQ1MTUpLCBuZXcgTG9uZygweGM1YjQzMTQyLCAweDM3YzM4MDIwKSxcbiAgICBuZXcgTG9uZygweDE0NTA4MDE0LCAweDQyMDg1MDg1KSwgbmV3IExvbmcoMHg1MDg1MDA1MSwgMHgxNDE0MDU4KSwgbmV3IExvbmcoMHg5ODA5OTBjMiwgMHg1MTQ1NjE4MCksIG5ldyBMb25nKDB4MGM1MGEwMTAsIDB4ZTAwODMxNmQpLFxuICAgIG5ldyBMb25nKDB4NTA4YjIxZjAsIDB4MmM1MmNiMmMpLCBuZXcgTG9uZygweGMyMmNiMjQ5LCAweDYwMGQyYzkyKSwgbmV3IExvbmcoMHgxODUwODIxYywgMHg4NzNjMjFjMCksIG5ldyBMb25nKDB4MDNjYjE0MjAsIDB4MmMwMWNiMTQpLFxuICAgIG5ldyBMb25nKDB4NDUxODUxODIsIDB4MjA4MDA4MjEpLCBuZXcgTG9uZygweDA4MjA4MDAwLCAweDQ1MDAyMDAyKSwgbmV3IExvbmcoMHgyMDg3MTgwMywgMHg4NzAwNjE0KSwgbmV3IExvbmcoMHgwNTA4MjFjZiwgMHg3NDA1MDBmNSksXG4gICAgbmV3IExvbmcoMHgxODYwOTAwMCwgMHg5MzRkOTY0NiksIG5ldyBMb25nKDB4MzA4MjRkMzAsIDB4NGMyNGQzNGQpLCBuZXcgTG9uZygweGM2MDBkNjQyLCAweDE4NjA4MjEpLCBuZXcgTG9uZygweDI1ZGFjMjc0LCAweGMyYTA3MmM5KSxcbiAgICBuZXcgTG9uZygweDkxYzI3NDcyLCAweDJjNjk4Mzk4KSwgbmV3IExvbmcoMHg4OTI0MjI0MiwgMHg5MjQyMDgyMCksIG5ldyBMb25nKDB4MzRiMDA5MDAsIDB4ODIwODcxODApLCBuZXcgTG9uZygweGIwOWQwMDYxLCAweDFjYjI0OTc2KSxcbiAgICBuZXcgTG9uZygweDlkMWNiMGE4LCAweDYwZTYyNDcwKSwgbmV3IExvbmcoMHgxNTc0Y2UzZSwgMHhkMzE0NTVkNyksIG5ldyBMb25nKDB4MjVjMjVkNzQsIDB4MWM2MDBkMzgpLCBuZXcgTG9uZygweDQyM2MzMTQyLCAweDUxNTE1NDU0KSxcbiAgICBuZXcgTG9uZygweDE0MDNjMzE0LCAweGMyMmMyMWNiKSwgbmV3IExvbmcoMHgyMTQzMTg1MywgMHhiMmMyMDgpLCBuZXcgTG9uZygweDA1MTQ1MTQ1LCAweDM0NTA4YjApLCBuZXcgTG9uZygweDBjNTA4NzE4LCAweDU1MTUxMDhmKSxcbiAgICBuZXcgTG9uZygweGYyMDUxNDU0LCAweDg3NDA1MDApLCBuZXcgTG9uZygweDA2MThmMDkwLCAweGUyNTM0ZDkyKSwgbmV3IExvbmcoMHg2NTkyYzIzOCwgMHg0OTM4MjY1OSksIG5ldyBMb25nKDB4MjFjNjAwZDYsIDB4NDQyM2MzMTQpLFxuICAgIG5ldyBMb25nKDB4Y2IyZDE1NDUsIDB4NzJjMmEwNDIpLCBuZXcgTG9uZygweGEwOTFjNTc0LCAweDQyMmMzOTgzKSwgbmV3IExvbmcoMHg1MDhiMmM1MiwgMHhiMmM1MTQpLCBuZXcgTG9uZygweDgwMzRiMDhiLCAweGYwYzUwODcxKSxcbiAgICBuZXcgTG9uZygweDQ1NTE1MTA4LCAweGE4MTBiMmNiKSwgbmV3IExvbmcoMHg3MTVkMWNiMCwgMHgyMjYwZTgyNCksIG5ldyBMb25nKDB4OGUyZDc0Y2UsIDB4ZTY1OTJjNTMpLCBuZXcgTG9uZygweDM4OTM4MjM4LCAweDQyMGMzMDgxKSxcbiAgICBuZXcgTG9uZygweDIyMDIwY2IxLCAweDg1MDg0MjApLCBuZXcgTG9uZygweGNlMDgyMGNlLCAweDcwYzI1YzIwKSwgbmV3IExvbmcoMHgwODIwOGIwZCwgMHg0MjA4MjA4MiksIG5ldyBMb25nKDB4NTA4MjE0MjEsIDB4YzIwNDIwOCksXG4gICAgbmV3IExvbmcoMHg4MzJjNTA4MywgMHgyMTA4MDg4MCksIG5ldyBMb25nKDB4MDgzOGMyMTQsIDB4YTUwODM4ODIpLCBuZXcgTG9uZygweGE5YzM5NDMwLCAweGFhYWFhYWFhKSwgbmV3IExvbmcoMHg5ZmE5ZmFhYSwgMHgxYWFhN2VhYSksXG4gICAgbmV3IExvbmcoMHgxNDIwYzMwOCwgMHg4MjQ4MjBkMCksIG5ldyBMb25nKDB4ODRkOTRkNjQsIDB4NzE4NGQzNzEpLCBuZXcgTG9uZygweDFiNzEzNmQzLCAweDM0YzI0ZDA3KSwgbmV3IExvbmcoMHgxNTM0ZDM0ZCwgMHg5OTA5MzY0MiksXG4gICAgbmV3IExvbmcoMHgzMGMyMDUzMCwgMHg4MzQwNTA4KSwgbmV3IExvbmcoMHg1MzU5MjA5MiwgMHgzNGRjNjEzNiksIG5ldyBMb25nKDB4NGRiNGRjNjEsIDB4YTQ3OWM2ZGMpLCBuZXcgTG9uZygweDQ5MjQ5MjRhLCAweDkyMGE5ZjkyKSxcbiAgICBuZXcgTG9uZygweDgxOTJhODJhLCAweDcyYzIyMDMwKSwgbmV3IExvbmcoMHgzMDkzMDkyMCwgMHg3MjRiMjRhKSwgbmV3IExvbmcoMHg5MjBlMjQyMiwgMHhkNzIwMjVjKSwgbmV3IExvbmcoMHhjOTA4MjI0NywgMHg5MmQ3MDk3NSksXG4gICAgbmV3IExvbmcoMHgyNGUwODkyYywgMHg4ODBjMjA0OSksIG5ldyBMb25nKDB4YzI0ODFjYjAsIDB4MmM5MjhjMjQpLCBuZXcgTG9uZygweDg5MDg4NzQ5LCAweDgwYTUyNDg4KSwgbmV3IExvbmcoMHhhYWM3NDM5NCwgMHg2YTg2MWIyYSksXG4gICAgbmV3IExvbmcoMHhhYjI3YjI3OCwgMHg4MWIyY2E2KSwgbmV3IExvbmcoMHgwNzJjMjIwMywgMHhhMzA5MzA5MiksIG5ldyBMb25nKDB4NjkxNWNlNWMsIDB4ZDc2OTg1ZDMpLCBuZXcgTG9uZygweDc3MWI2OTM2LCAweDVkNzRjMjVjKSxcbiAgICBuZXcgTG9uZygweDg5MmQ3NGQ3LCAweDcyNGUwOTczKSwgbmV3IExvbmcoMHgwODgwYzIwNSwgMHg0YzI0ODFjYiksIG5ldyBMb25nKDB4NzM5NzI4YzIsIDB4NjE3NGRhNDUpLCBuZXcgTG9uZygweGRhNGRiNWRhLCAweDRhYTE3NWM2KSxcbiAgICBuZXcgTG9uZygweDg2NDg2MTg2LCAweDZhODY5YjI3KSwgbmV3IExvbmcoMHgzMDgxODZjYSwgMHhjYjE0NTEwKSwgbmV3IExvbmcoMHg0NDIwNTEwMiwgMHgyMjBlMmM1MSksIG5ldyBMb25nKDB4MzgyMTBlMmMsIDB4Y2IwZDcwYzUpLFxuICAgIG5ldyBMb25nKDB4NTE0MjE0NTIsIDB4MTQ1MTQyMDgpLCBuZXcgTG9uZygweDRiMDg1MDg1LCAweDUxNDQwYzIwKSwgbmV3IExvbmcoMHgxNDQwODMyYywgMHhjYjE0NTEwOCksIG5ldyBMb25nKDB4NDg4YjA4ODgsIDB4OTQzMTYyMDgpLFxuICAgIG5ldyBMb25nKDB4OWY3ZTc5YzMsIDB4ZmFhYTdkZmEpLCBuZXcgTG9uZygweDdlYTdkZjdkLCAweDMwODE5ZWEpLCBuZXcgTG9uZygweDIwZDAxNDUxLCAweDY1NjQ4NTU4KSwgbmV3IExvbmcoMHg5MzY5ODM5OSwgMHg5NjEzNTk4MyksXG4gICAgbmV3IExvbmcoMHgzOTA3MWI3MSwgMHhkOTY1MzY0NSksIG5ldyBMb25nKDB4OTY0NTE1MzQsIDB4NGUwOTkwOSksIG5ldyBMb25nKDB4MDUxNDQwYzIsIDB4MjE1NjA4MzQpLCBuZXcgTG9uZygweDYwZTY1OTU5LCAweGQ2NjBlNGRhKSxcbiAgICBuZXcgTG9uZygweGM2ZGM2NTg0LCAweDkyMDdlOTc5KSwgbmV3IExvbmcoMHhkZjkyNDgyMCwgMHhhODJhODIwNyksIG5ldyBMb25nKDB4MTAzMDgxYTYsIDB4ODkyMDcyYzUpLCBuZXcgTG9uZygweGIyY2EzMGIyLCAweDJjMjIwNzJjKSxcbiAgICBuZXcgTG9uZygweDA1Mzg5MTBlLCAweDUyYzcwZDcyKSwgbmV3IExvbmcoMHgwOGUzODkxNCwgMHg4YjJjYjJkNyksIG5ldyBMb25nKDB4MjA0YjI0ZTAsIDB4MWNiMTQ0MGMpLCBuZXcgTG9uZygweDhjMmNhMjQ4LCAweDg3NGIyY2IyKSxcbiAgICBuZXcgTG9uZygweDI0NDg4YjA4LCAweDQzOTQ4MTYyKSwgbmV3IExvbmcoMHg5YjFmN2U3NywgMHg5ZTc4NmFhNiksIG5ldyBMb25nKDB4ZWNhNmE5ZTcsIDB4NTEwMzA4MTkpLCBuZXcgTG9uZygweDI4OTIwNzJjLCAweDhlMzhhMzBiKSxcbiAgICBuZXcgTG9uZygweDgzOTM2OTEzLCAweDY5OTYxNzU5KSwgbmV3IExvbmcoMHg0NTM4NzcxYiwgMHg3NGNlMzk3NiksIG5ldyBMb25nKDB4MDhlMzhiMmQsIDB4YzIwNGUyNGUpLCBuZXcgTG9uZygweDgxY2IxNDQwLCAweDI4YzJjYTI0KSxcbiAgICBuZXcgTG9uZygweGRhNDRlMzhlLCAweDg1ZDY2MGU0KSwgbmV3IExvbmcoMHg3NWM2ZGE2NSwgMHg2OTg2MDdlOSksIG5ldyBMb25nKDB4OTllNzg2NGEsIDB4YTZjYTZhYTYpXG5dO1xuY29uc3Qgb2Zmc2V0SW5jcnM1ID0gLyozIGJpdHMgcGVyIHZhbHVlICovIFtcbiAgICBuZXcgTG9uZygweDAwMDgwMDAwLCAweDMwMDIwMDAwKSwgbmV3IExvbmcoMHgyMGMwNjApLCBuZXcgTG9uZygweDA0MDAwMDAwLCAweDEwMDAwMDApLCBuZXcgTG9uZygweDUwNjAzMDE4LCAweGRiNmRiNmRiKSxcbiAgICBuZXcgTG9uZygweDAwMDAyZGI2LCAweGE0ODAwMDAyKSwgbmV3IExvbmcoMHg0MTI0MTI0MCwgMHgxMjQ5MjA4OCksIG5ldyBMb25nKDB4MDAxMDQxMjAsIDB4NDAwMDAxMDApLCBuZXcgTG9uZygweDkyMDkyMDUyLCAweDI0OTJjNDIwKSxcbiAgICBuZXcgTG9uZygweDA5NjU5MmQ5LCAweGMzMGQ4MDApLCBuZXcgTG9uZygweGMzNjAzNmQ4LCAweGIwMWIwYzA2KSwgbmV3IExvbmcoMHg2YzM2ZGIwZCwgMHgxODZjMDAwMyksIG5ldyBMb25nKDB4YjAxYjZjMDYsIDB4YWQ4NjAzNjEpLFxuICAgIG5ldyBMb25nKDB4NWI2ZGQ2ZGQsIDB4MzYwMDAxYjcpLCBuZXcgTG9uZygweDBkYjYwMzBjLCAweGM0MTIzMTFjKSwgbmV3IExvbmcoMHhiNmUzNmUwNiwgMHhkYjBkKSwgbmV3IExvbmcoMHhkYjAxODYxYiwgMHg5MTg4ZTA2KSxcbiAgICBuZXcgTG9uZygweDcxYjcyYjYyLCAweDZkZDZkYiksIG5ldyBMb25nKDB4MDA4MDA5MjAsIDB4NDAyNDAyNDkpLCBuZXcgTG9uZygweDkwNDkyMGMyLCAweDIwODI0OTAwKSwgbmV3IExvbmcoMHg0MDA0OTAwMCwgMHgxMjAxMjQ4MCksXG4gICAgbmV3IExvbmcoMHhhNDkwNjEyMCwgMHg1NTI0YWQ0YSksIG5ldyBMb25nKDB4MDI0ODAwMTUsIDB4NDA5MjQwMjApLCBuZXcgTG9uZygweDQ4NDA5NDA5LCAweDkyNTIyNTEyKSwgbmV3IExvbmcoMHgyNDAwMDgyMCwgMHg0OTIwMTAwMSksXG4gICAgbmV3IExvbmcoMHgyMDRhMDRhMCwgMHgyOTEyODkyNCksIG5ldyBMb25nKDB4MDAwNTU1NDksIDB4OTAwODMwZDIpLCBuZXcgTG9uZygweDI0YzI0MDM0LCAweDkzNDkzMGMpLCBuZXcgTG9uZygweDAyNjgyNDkzLCAweDQxODY5MDApLFxuICAgIG5ldyBMb25nKDB4NjEyMDFhNDgsIDB4OWE0OTg2MTIpLCBuZXcgTG9uZygweDM1NTI0OWQ0LCAweGMzNDgwMDEpLCBuZXcgTG9uZygweDk0MGQyNDAyLCAweDI0YzQwOTMwKSwgbmV3IExvbmcoMHgwOTI0ZTI0ZCwgMHgxYTQwMDA5YSksXG4gICAgbmV3IExvbmcoMHgwNjkyMDEwNiwgMHg2MjA0OTg0YSksIG5ldyBMb25nKDB4OTI3MTI2OTIsIDB4OTI0OTRkNTQpLCBuZXcgTG9uZygweDI0OTI0OTI0LCAweDQ5MjQ5MjQ5KSwgbmV3IExvbmcoMHg5MjQ5MjQ5MiwgMHgyNDkyNDkyNCksXG4gICAgbmV3IExvbmcoMHg0OTI0OTI0OSwgMHg5MjQ5MjQ5MiksIG5ldyBMb25nKDB4MjQ5MjQ5MjQsIDB4NDkyNDkyNDkpLCBuZXcgTG9uZygweDkyNDkyNDkyLCAweDI0OTI0OTI0KSwgbmV3IExvbmcoMHg0OTI0OTI0OSwgMHg5MjQ5MjQ5MiksXG4gICAgbmV3IExvbmcoMHgyNDkyNDkyNCwgMHg0OTI0OTI0OSksIG5ldyBMb25nKDB4OTI0OTI0OTIsIDB4MjQ5MjQ5MjQpLCBuZXcgTG9uZygweDQ5MjQ5MjQ5LCAweDkyNDkyNDkyKSwgbmV3IExvbmcoMHgyNDkyNDkyNCwgMHg0OTI0OTI0OSksXG4gICAgbmV3IExvbmcoMHg5MjQ5MjQ5MiwgMHgyNDkyNDkyNCksIG5ldyBMb25nKDB4NDkyNDkyNDksIDB4OTI0OTI0OTIpLCBuZXcgTG9uZygweDI0OTI0OTI0LCAweDQ5MjQ5MjQ5KSwgbmV3IExvbmcoMHg5MjQ5MjQ5MiwgMHgyNDkyNDkyNCksXG4gICAgbmV3IExvbmcoMHg0OTI0OTI0OSwgMHg5MjQ5MjQ5MiksIG5ldyBMb25nKDB4MjQ5MjQ5MjQsIDB4NDkyNDkyNDkpLCBuZXcgTG9uZygweDkyNDkyNDkyLCAweDI0OTI0OTI0KSwgbmV3IExvbmcoMHg0OTI0OTI0OSwgMHg5MjQ5MjQ5MiksXG4gICAgbmV3IExvbmcoMHgyNDkyNDkyNCwgMHg0OTI0OTI0OSksIG5ldyBMb25nKDB4OTI0OTI0OTIsIDB4MjQ5MjQ5MjQpLCBuZXcgTG9uZygweDQ5MjQ5MjQ5LCAweDkyNDkyNDkyKSwgbmV3IExvbmcoMHgyNDkyNDkyNCwgMHg0OTI0OTI0OSksXG4gICAgbmV3IExvbmcoMHg5MjQ5MjQ5MiwgMHgyNDkyNDkyNCksIG5ldyBMb25nKDB4NDkyNDkyNDksIDB4OTI0OTI0OTIpLCBuZXcgTG9uZygweDI0OTI0OTI0LCAweDQ5MjQ5MjQ5KSwgbmV3IExvbmcoMHg5MjQ5MjQ5MiwgMHgyNDkyNDkyNCksXG4gICAgbmV3IExvbmcoMHg0OTI0OTI0OSwgMHg5MjQ5MjQ5MiksIG5ldyBMb25nKDB4MjQ5MjQ5MjQsIDB4NDkyNDkyNDkpLCBuZXcgTG9uZygweDkyNDkyNDkyLCAweDI0OTI0OTI0KSwgbmV3IExvbmcoMHg0OTI0OTI0OSwgMHg5MjQ5MjQ5MiksXG4gICAgbmV3IExvbmcoMHgyNDkyNDkyNCwgMHg0OTI0OTI0OSksIG5ldyBMb25nKDB4OTI0OTI0OTIsIDB4MjQ5MjQ5MjQpLCBuZXcgTG9uZygweDQ5MjQ5MjQ5LCAweDkyNDkyNDkyKSwgbmV3IExvbmcoMHgyNDkyNDkyNClcbl07XG4vLyBzdGF0ZSBtYXBcbi8vICAgMCAtPiBbKDAsIDApXVxuLy8gICAxIC0+IFsoMCwgMildXG4vLyAgIDIgLT4gWygwLCAxKV1cbi8vICAgMyAtPiBbKDAsIDEpLCAoMSwgMSldXG4vLyAgIDQgLT4gWygwLCAyKSwgKDEsIDIpXVxuLy8gICA1IC0+IFt0KDAsIDIpLCAoMCwgMiksICgxLCAyKSwgKDIsIDIpXVxuLy8gICA2IC0+IFsoMCwgMiksICgyLCAxKV1cbi8vICAgNyAtPiBbKDAsIDEpLCAoMiwgMildXG4vLyAgIDggLT4gWygwLCAyKSwgKDIsIDIpXVxuLy8gICA5IC0+IFsoMCwgMSksICgxLCAxKSwgKDIsIDEpXVxuLy8gICAxMCAtPiBbKDAsIDIpLCAoMSwgMiksICgyLCAyKV1cbi8vICAgMTEgLT4gWygwLCAxKSwgKDIsIDEpXVxuLy8gICAxMiAtPiBbdCgwLCAxKSwgKDAsIDEpLCAoMSwgMSksICgyLCAxKV1cbi8vICAgMTMgLT4gWygwLCAyKSwgKDEsIDIpLCAoMiwgMiksICgzLCAyKV1cbi8vICAgMTQgLT4gW3QoMCwgMiksICgwLCAyKSwgKDEsIDIpLCAoMiwgMiksICgzLCAyKV1cbi8vICAgMTUgLT4gWygwLCAyKSwgdCgxLCAyKSwgKDEsIDIpLCAoMiwgMiksICgzLCAyKV1cbi8vICAgMTYgLT4gWygwLCAyKSwgKDIsIDEpLCAoMywgMSldXG4vLyAgIDE3IC0+IFsoMCwgMSksIHQoMSwgMiksICgyLCAyKSwgKDMsIDIpXVxuLy8gICAxOCAtPiBbKDAsIDIpLCAoMywgMildXG4vLyAgIDE5IC0+IFsoMCwgMiksICgxLCAyKSwgdCgxLCAyKSwgKDIsIDIpLCAoMywgMildXG4vLyAgIDIwIC0+IFt0KDAsIDIpLCAoMCwgMiksICgxLCAyKSwgKDMsIDEpXVxuLy8gICAyMSAtPiBbKDAsIDEpLCAoMSwgMSksICgzLCAyKV1cbi8vICAgMjIgLT4gWygwLCAyKSwgKDIsIDIpLCAoMywgMildXG4vLyAgIDIzIC0+IFsoMCwgMiksICgxLCAyKSwgKDMsIDEpXVxuLy8gICAyNCAtPiBbKDAsIDIpLCAoMSwgMiksICgzLCAyKV1cbi8vICAgMjUgLT4gWygwLCAxKSwgKDIsIDIpLCAoMywgMildXG4vLyAgIDI2IC0+IFsoMCwgMiksICgzLCAxKV1cbi8vICAgMjcgLT4gWygwLCAxKSwgKDMsIDIpXVxuLy8gICAyOCAtPiBbKDAsIDIpLCAoMiwgMSksICg0LCAyKV1cbi8vICAgMjkgLT4gWygwLCAyKSwgdCgxLCAyKSwgKDEsIDIpLCAoMiwgMiksICgzLCAyKSwgKDQsIDIpXVxuLy8gICAzMCAtPiBbKDAsIDIpLCAoMSwgMiksICg0LCAyKV1cbi8vICAgMzEgLT4gWygwLCAyKSwgKDEsIDIpLCAoMywgMiksICg0LCAyKV1cbi8vICAgMzIgLT4gWygwLCAyKSwgKDIsIDIpLCAoMywgMiksICg0LCAyKV1cbi8vICAgMzMgLT4gWygwLCAyKSwgKDEsIDIpLCB0KDIsIDIpLCAoMiwgMiksICgzLCAyKSwgKDQsIDIpXVxuLy8gICAzNCAtPiBbKDAsIDIpLCAoMSwgMiksICgyLCAyKSwgdCgyLCAyKSwgKDMsIDIpLCAoNCwgMildXG4vLyAgIDM1IC0+IFsoMCwgMiksICgzLCAyKSwgKDQsIDIpXVxuLy8gICAzNiAtPiBbKDAsIDIpLCB0KDIsIDIpLCAoMiwgMiksICgzLCAyKSwgKDQsIDIpXVxuLy8gICAzNyAtPiBbdCgwLCAyKSwgKDAsIDIpLCAoMSwgMiksICgyLCAyKSwgKDQsIDIpXVxuLy8gICAzOCAtPiBbKDAsIDIpLCAoMSwgMiksICgyLCAyKSwgKDQsIDIpXVxuLy8gICAzOSAtPiBbdCgwLCAyKSwgKDAsIDIpLCAoMSwgMiksICgyLCAyKSwgKDMsIDIpLCAoNCwgMildXG4vLyAgIDQwIC0+IFsoMCwgMiksICgxLCAyKSwgKDIsIDIpLCAoMywgMiksICg0LCAyKV1cbi8vICAgNDEgLT4gWygwLCAyKSwgKDQsIDIpXVxuLy8gICA0MiAtPiBbdCgwLCAyKSwgKDAsIDIpLCAoMSwgMiksICgyLCAyKSwgdCgyLCAyKSwgKDMsIDIpLCAoNCwgMildXG4vLyAgIDQzIC0+IFsoMCwgMiksICgyLCAyKSwgKDQsIDIpXVxuLy8gICA0NCAtPiBbKDAsIDIpLCAoMSwgMiksIHQoMSwgMiksICgyLCAyKSwgKDMsIDIpLCAoNCwgMildXG4vKipcbiAqIEZyb20gb3JnL2FwYWNoZS9sdWNlbmUvdXRpbC9hdXRvbWF0b24vTGV2MlRQYXJhbWV0cmljRGVzY3JpcHRpb24uamF2YVxuICogQGhpZGRlblxuICovXG5jbGFzcyBsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX0xldjJUUGFyYW1ldHJpY0Rlc2NyaXB0aW9uIGV4dGVuZHMgUGFyYW1ldHJpY0Rlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih3KSB7XG4gICAgICAgIHN1cGVyKHcsIDIsIFswLCAyLCAxLCAwLCAxLCAwLCAtMSwgMCwgMCwgLTEsIDAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTIsIC0xLCAtMSwgLTEsIC0yLCAtMSwgLTEsIC0yLCAtMSwgLTEsIC0yLCAtMSwgLTIsIC0yLCAtMiwgLTIsIC0yLCAtMiwgLTIsIC0yLCAtMiwgLTIsIC0yLCAtMiwgLTIsIC0yLCAtMiwgLTIsIC0yXSk7XG4gICAgfVxuICAgIHRyYW5zaXRpb24oYWJzU3RhdGUsIHBvc2l0aW9uLCB2ZWN0b3IpIHtcbiAgICAgICAgLy8gbnVsbCBhYnNTdGF0ZSBzaG91bGQgbmV2ZXIgYmUgcGFzc2VkIGluXG4gICAgICAgIC8vIGFzc2VydCBhYnNTdGF0ZSAhPSAtMTtcbiAgICAgICAgLy8gZGVjb2RlIGFic1N0YXRlIC0+IHN0YXRlLCBvZmZzZXRcbiAgICAgICAgbGV0IHN0YXRlID0gTWF0aC5mbG9vcihhYnNTdGF0ZSAvICh0aGlzLl93ICsgMSkpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gYWJzU3RhdGUgJSAodGhpcy5fdyArIDEpO1xuICAgICAgICAvLyBhc3NlcnQgb2Zmc2V0ID49IDA7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdGhpcy5fdykge1xuICAgICAgICAgICAgaWYgKHN0YXRlIDwgMykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IHZlY3RvciAqIDMgKyBzdGF0ZTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gUGFyYW1ldHJpY0Rlc2NyaXB0aW9uLnVucGFjayhsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX29mZnNldEluY3JzMCwgbG9jLCAxKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFBhcmFtZXRyaWNEZXNjcmlwdGlvbi51bnBhY2sobGV2MnRfcGFyYW1ldHJpY19kZXNjcmlwdGlvbl90b1N0YXRlczAsIGxvYywgMikgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSB0aGlzLl93IC0gMSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlIDwgNSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IHZlY3RvciAqIDUgKyBzdGF0ZTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gUGFyYW1ldHJpY0Rlc2NyaXB0aW9uLnVucGFjayhsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX29mZnNldEluY3JzMSwgbG9jLCAxKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFBhcmFtZXRyaWNEZXNjcmlwdGlvbi51bnBhY2sobGV2MnRfcGFyYW1ldHJpY19kZXNjcmlwdGlvbl90b1N0YXRlczEsIGxvYywgMykgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSB0aGlzLl93IC0gMikge1xuICAgICAgICAgICAgaWYgKHN0YXRlIDwgMTMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2MgPSB2ZWN0b3IgKiAxMyArIHN0YXRlO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBQYXJhbWV0cmljRGVzY3JpcHRpb24udW5wYWNrKGxldjJ0X3BhcmFtZXRyaWNfZGVzY3JpcHRpb25fb2Zmc2V0SW5jcnMyLCBsb2MsIDIpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gUGFyYW1ldHJpY0Rlc2NyaXB0aW9uLnVucGFjayhsZXYydF9wYXJhbWV0cmljX2Rlc2NyaXB0aW9uX3RvU3RhdGVzMiwgbG9jLCA0KSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPT09IHRoaXMuX3cgLSAzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPCAyOCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IHZlY3RvciAqIDI4ICsgc3RhdGU7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IFBhcmFtZXRyaWNEZXNjcmlwdGlvbi51bnBhY2sobGV2MnRfcGFyYW1ldHJpY19kZXNjcmlwdGlvbl9vZmZzZXRJbmNyczMsIGxvYywgMik7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBQYXJhbWV0cmljRGVzY3JpcHRpb24udW5wYWNrKGxldjJ0X3BhcmFtZXRyaWNfZGVzY3JpcHRpb25fdG9TdGF0ZXMzLCBsb2MsIDUpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA9PT0gdGhpcy5fdyAtIDQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA8IDQ1KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jID0gdmVjdG9yICogNDUgKyBzdGF0ZTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gUGFyYW1ldHJpY0Rlc2NyaXB0aW9uLnVucGFjayhvZmZzZXRJbmNyczQsIGxvYywgMyk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBQYXJhbWV0cmljRGVzY3JpcHRpb24udW5wYWNrKHRvU3RhdGVzNCwgbG9jLCA2KSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPCA0NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IHZlY3RvciAqIDQ1ICsgc3RhdGU7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IFBhcmFtZXRyaWNEZXNjcmlwdGlvbi51bnBhY2sob2Zmc2V0SW5jcnM1LCBsb2MsIDMpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gUGFyYW1ldHJpY0Rlc2NyaXB0aW9uLnVucGFjayh0b1N0YXRlczUsIGxvYywgNikgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIG51bGwgc3RhdGVcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBiYWNrIHRvIGFic1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlICogKHRoaXMuX3cgKyAxKSArIG9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9mdWxsLXRleHQtc2VhcmNoL3NyYy9mdXp6eS9sZXZlbnNodGVpbl9hdXRvbWF0YS50c1xuXG5cblxuLyoqXG4gKiBGcm9tIG9yZy9hcGFjaGUvbHVjZW5lL3V0aWwvYXV0b21hdG9uL0xldmVuc2h0ZWluQXV0b21hdGEuamF2YVxuICogQGhpZGRlblxuICovXG5jbGFzcyBsZXZlbnNodGVpbl9hdXRvbWF0YV9MZXZlbnNodGVpbkF1dG9tYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCwgZWRpdERpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX3dvcmQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fZWRpdERpc3RhbmNlID0gZWRpdERpc3RhbmNlO1xuICAgICAgICB0aGlzLl9hbHBoYWJldCA9IFsuLi5uZXcgU2V0KHRoaXMuX3dvcmQpXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIHRoaXMuX251bVJhbmdlcyA9IDA7XG4gICAgICAgIHRoaXMuX3JhbmdlTG93ZXIgPSBuZXcgQXJyYXkodGhpcy5fYWxwaGFiZXQubGVuZ3RoICsgMik7XG4gICAgICAgIHRoaXMuX3JhbmdlVXBwZXIgPSBuZXcgQXJyYXkodGhpcy5fYWxwaGFiZXQubGVuZ3RoICsgMik7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdW5pY29kZSByYW5nZSBpbnRlcnZhbHMgdGhhdCBleGNsdWRlIHRoZSBhbHBoYWJldFxuICAgICAgICAvLyB0aGVzZSBhcmUgdGhlIHJhbmdlcyBmb3IgYWxsIHVuaWNvZGUgY2hhcmFjdGVycyBub3QgaW4gdGhlIGFscGhhYmV0XG4gICAgICAgIGxldCBsb3dlciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hlciA9IHRoaXMuX2FscGhhYmV0W2ldO1xuICAgICAgICAgICAgaWYgKGhpZ2hlciA+IGxvd2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VMb3dlclt0aGlzLl9udW1SYW5nZXNdID0gbG93ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VVcHBlclt0aGlzLl9udW1SYW5nZXNdID0gaGlnaGVyIC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1SYW5nZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvd2VyID0gaGlnaGVyICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvKiBhZGQgdGhlIGZpbmFsIGVuZHBvaW50ICovXG4gICAgICAgIGlmIChsb3dlciA8PSBNQVhfQ09ERV9QT0lOVCkge1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2VMb3dlclt0aGlzLl9udW1SYW5nZXNdID0gbG93ZXI7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZVVwcGVyW3RoaXMuX251bVJhbmdlc10gPSBNQVhfQ09ERV9QT0lOVDtcbiAgICAgICAgICAgIHRoaXMuX251bVJhbmdlcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGl0RGlzdGFuY2UgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gbmV3IGxldjF0X3BhcmFtZXRyaWNfZGVzY3JpcHRpb25fTGV2MVRQYXJhbWV0cmljRGVzY3JpcHRpb24oaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gbmV3IGxldjJ0X3BhcmFtZXRyaWNfZGVzY3JpcHRpb25fTGV2MlRQYXJhbWV0cmljRGVzY3JpcHRpb24oaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBOREZBIHRvIGEgREZBLlxuICAgICAqIEByZXR1cm5zIHtBdXRvbWF0b259XG4gICAgICovXG4gICAgdG9BdXRvbWF0b24oKSB7XG4gICAgICAgIGxldCBhdXRvbWF0ID0gbmV3IEF1dG9tYXRvbigpO1xuICAgICAgICBjb25zdCByYW5nZSA9IDIgKiB0aGlzLl9lZGl0RGlzdGFuY2UgKyAxO1xuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIHN0YXRlcyBpcyBiYXNlZCBvbiB0aGUgbGVuZ3RoIG9mIHRoZSB3b3JkIGFuZCB0aGUgZWRpdCBkaXN0YW5jZVxuICAgICAgICBjb25zdCBudW1TdGF0ZXMgPSB0aGlzLl9kZXNjcmlwdGlvbi5zaXplKCk7XG4gICAgICAgIC8vIFByZWZpeCBpcyBub3QgbmVlZGVkIHRvIGJlIGhhbmRsZWQgYnkgdGhlIGF1dG9tYXRvbi5cbiAgICAgICAgLy8gc3RhdGVPZmZzZXQgPSAwO1xuICAgICAgICBhdXRvbWF0LmNyZWF0ZVN0YXRlKCk7XG4gICAgICAgIC8vIGNyZWF0ZSBhbGwgc3RhdGVzLCBhbmQgbWFyayBhcyBhY2NlcHQgc3RhdGVzIGlmIGFwcHJvcHJpYXRlXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtU3RhdGVzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IGF1dG9tYXQuY3JlYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGF1dG9tYXQuc2V0QWNjZXB0KHN0YXRlLCB0aGlzLl9kZXNjcmlwdGlvbi5pc0FjY2VwdChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBudW1TdGF0ZXM7IGsrKykge1xuICAgICAgICAgICAgY29uc3QgeHBvcyA9IHRoaXMuX2Rlc2NyaXB0aW9uLmdldFBvc2l0aW9uKGspO1xuICAgICAgICAgICAgaWYgKHhwb3MgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB4cG9zICsgTWF0aC5taW4odGhpcy5fd29yZC5sZW5ndGggLSB4cG9zLCByYW5nZSk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuX2FscGhhYmV0Lmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSB0aGlzLl9hbHBoYWJldFt4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdmVjID0gdGhpcy5fZ2V0VmVjdG9yKGNoLCB4cG9zLCBlbmQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLl9kZXNjcmlwdGlvbi50cmFuc2l0aW9uKGssIHhwb3MsIGN2ZWMpO1xuICAgICAgICAgICAgICAgIGlmIChkZXN0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdC5hZGRUcmFuc2l0aW9uKGssIGRlc3QsIGNoLCBjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMuX2Rlc2NyaXB0aW9uLnRyYW5zaXRpb24oaywgeHBvcywgMCk7XG4gICAgICAgICAgICBpZiAoZGVzdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCB0aGlzLl9udW1SYW5nZXM7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0LmFkZFRyYW5zaXRpb24oaywgZGVzdCwgdGhpcy5fcmFuZ2VMb3dlcltyXSwgdGhpcy5fcmFuZ2VVcHBlcltyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2VydCBhdXRvbWF0LmRldGVybWluaXN0aWM7XG4gICAgICAgIGF1dG9tYXQuZmluaXNoU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGF1dG9tYXQ7XG4gICAgfVxuICAgIF9nZXRWZWN0b3IoeCwgcG9zLCBlbmQpIHtcbiAgICAgICAgbGV0IHZlY3RvciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmVjdG9yIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmRbaV0gPT09IHgpIHtcbiAgICAgICAgICAgICAgICB2ZWN0b3IgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9mdWxsLXRleHQtc2VhcmNoL3NyYy9pbmRleF9zZWFyY2hlci50c1xuXG5cblxuXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1pblNob3VsZE1hdGNoKG9wdGlvbmFsQ2xhdXNlQ291bnQsIHNwZWMpIHtcbiAgICBpZiAoc3BlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNwZWMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIChzcGVjIDwgMCkgPyBvcHRpb25hbENsYXVzZUNvdW50ICsgc3BlYyA6IHNwZWM7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBvcHRpb25hbENsYXVzZUNvdW50O1xuICAgIGlmIChzcGVjLmluY2x1ZGVzKFwiPFwiKSkge1xuICAgICAgICAvLyBQYXJzZSBjb25kaXRpb25hbCBtaW5pbXVtU2hvdWxkTWF0Y2guO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc3BlYy5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gcy5zcGxpdChcIjxcIik7XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gcGFyc2VJbnQocGFydHNbMF0pO1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsQ2xhdXNlQ291bnQgPD0gdXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjdWxhdGVNaW5TaG91bGRNYXRjaChvcHRpb25hbENsYXVzZUNvdW50LCBwYXJ0c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHNwZWMuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICAgIC8vIFBhcnNlIHBlcmNlbnRhZ2UuXG4gICAgICAgIGNvbnN0IHBlcmNlbnQgPSBwYXJzZUludChzcGVjLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgIGNvbnN0IGNhbGMgPSAocmVzdWx0ICogcGVyY2VudCkgKiAoMSAvIDEwMCk7XG4gICAgICAgIHJlc3VsdCA9IChjYWxjIDwgMCkgPyByZXN1bHQgKyBNYXRoLmNlaWwoY2FsYykgOiBNYXRoLmZsb29yKGNhbGMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FsYyA9IHBhcnNlSW50KHNwZWMpO1xuICAgICAgICByZXN1bHQgPSAoY2FsYyA8IDApID8gcmVzdWx0ICsgY2FsYyA6IGNhbGM7XG4gICAgfVxuICAgIHJldHVybiAocmVzdWx0IDwgMSkgPyAxIDogcmVzdWx0O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIGluZGV4X3NlYXJjaGVyX0luZGV4U2VhcmNoZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gaW5kZXggc2VhcmNoZXIuXG4gICAgICogQHBhcmFtIHtEaWN0PEludmVydGVkSW5kZXg+fSBpbnZJZHhzIC0gdGhlIGludmVydGVkIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge1NldDxudW1iZXI+fSBkb2NzIC0gdGhlIGlkcyBvZiB0aGUgZG9jdW1lbnRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW52SWR4cywgZG9jcykge1xuICAgICAgICB0aGlzLl9pbnZJZHhzID0gaW52SWR4cztcbiAgICAgICAgdGhpcy5fZG9jcyA9IGRvY3M7XG4gICAgICAgIHRoaXMuX3Njb3JlciA9IG5ldyBTY29yZXIodGhpcy5faW52SWR4cyk7XG4gICAgfVxuICAgIHNlYXJjaChxdWVyeSkge1xuICAgICAgICBsZXQgcXVlcnlSZXN1bHRzID0gdGhpcy5fcmVjdXJzaXZlKHF1ZXJ5LnF1ZXJ5LCB0cnVlKTtcbiAgICAgICAgLy8gRG8gZmluYWwgc2NvcmluZy5cbiAgICAgICAgaWYgKHF1ZXJ5LmNhbGN1bGF0ZV9zY29yaW5nICE9PSB1bmRlZmluZWQgPyBxdWVyeS5jYWxjdWxhdGVfc2NvcmluZyA6IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY29yZXIuZmluYWxTY29yZShxdWVyeSwgcXVlcnlSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcXVlcnlSZXN1bHRzLmtleXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB7IHNjb3JlOiAxIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2V0RGlydHkoKSB7XG4gICAgICAgIHRoaXMuX3Njb3Jlci5zZXREaXJ0eSgpO1xuICAgIH1cbiAgICBfcmVjdXJzaXZlKHF1ZXJ5LCBkb1Njb3JpbmcpIHtcbiAgICAgICAgbGV0IHF1ZXJ5UmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYm9vc3QgPSBxdWVyeS5ib29zdCAhPT0gdW5kZWZpbmVkID8gcXVlcnkuYm9vc3QgOiAxO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBxdWVyeS5maWVsZCAhPT0gdW5kZWZpbmVkID8gcXVlcnkuZmllbGQgOiBudWxsO1xuICAgICAgICBsZXQgcm9vdCA9IG51bGw7XG4gICAgICAgIGxldCBhbmFseXplciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9pbnZJZHhzW2ZpZWxkTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcm9vdCA9IHRoaXMuX2ludklkeHNbZmllbGROYW1lXS5yb290O1xuICAgICAgICAgICAgYW5hbHl6ZXIgPSB0aGlzLl9pbnZJZHhzW2ZpZWxkTmFtZV0uYW5hbHl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChxdWVyeS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOiB7XG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkubXVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cyA9IHRoaXMuX2dldFVuaXF1ZShxdWVyeS5tdXN0LCBkb1Njb3JpbmcsIHF1ZXJ5UmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5maWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdHMgPSB0aGlzLl9nZXRVbmlxdWUocXVlcnkuZmlsdGVyLCBudWxsLCBxdWVyeVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocXVlcnkuc2hvdWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkRG9jcyA9IHRoaXMuX2dldEFsbChxdWVyeS5zaG91bGQsIGRvU2NvcmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlSZXN1bHRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNtID0gTWF0aC5tYXgoMSwgY2FsY3VsYXRlTWluU2hvdWxkTWF0Y2gocXVlcnkuc2hvdWxkLmxlbmd0aCwgcXVlcnkubWluaW11bV9zaG91bGRfbWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5ICYmIG1zbSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFrZSBhbGwgZG9jdW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzID0gc2hvdWxkRG9jcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBkb2N1bWVudHMgd2l0aCBmZXdlciBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZG9jSWQsIHJlc10gb2Ygc2hvdWxkRG9jcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID49IG1zbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlSZXN1bHRzLmhhcyhkb2NJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cy5nZXQoZG9jSWQpLnB1c2goLi4ucmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzLnNldChkb2NJZCwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cy5kZWxldGUoZG9jSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGFsbCBkb2N1bWVudHMgaWYgbXVzdC9maWx0ZXIvc2hvdWxkIGlzIG5vdCBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIGlmIChxdWVyeVJlc3VsdHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzID0gdGhpcy5fcmVjdXJzaXZlKHsgdHlwZTogXCJtYXRjaF9hbGxcIiB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5ub3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90RG9jcyA9IHRoaXMuX2dldEFsbChxdWVyeS5ub3QsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoaW5nIGRvY3VtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkb2NJZCBvZiBub3REb2NzLmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5UmVzdWx0cy5oYXMoZG9jSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzLmRlbGV0ZShkb2NJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQm9vc3QgcXVlcnkgcmVzdWx0cyBhZnRlcndhcmRzLlxuICAgICAgICAgICAgICAgIGlmIChib29zdCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtfLCByZXN1bHRdIG9mIHF1ZXJ5UmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0uYm9vc3QgKj0gYm9vc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGVybVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3BzID0gdG9Db2RlUG9pbnRzKHF1ZXJ5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVybUlkeCA9IGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXguZ2V0VGVybUluZGV4KGNwcywgcm9vdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NvcmVyLnNjb3JlKGZpZWxkTmFtZSwgYm9vc3QsIHRlcm1JZHgsIGRvU2NvcmluZywgcXVlcnlSZXN1bHRzLCBjcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRlcm1zXCI6IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXJ5LnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNwcyA9IHRvQ29kZVBvaW50cyhxdWVyeS52YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtSWR4ID0gaW52ZXJ0ZWRfaW5kZXhfSW52ZXJ0ZWRJbmRleC5nZXRUZXJtSW5kZXgoY3BzLCByb290KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NvcmVyLnNjb3JlKGZpZWxkTmFtZSwgYm9vc3QsIHRlcm1JZHgsIGRvU2NvcmluZywgcXVlcnlSZXN1bHRzLCBjcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmdXp6eVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2YsIGlkZl0gPSBmdXp6eVNlYXJjaChxdWVyeSwgcm9vdCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njb3Jlci5zY29yZShmaWVsZE5hbWUsIGJvb3N0ICogZltpXS5ib29zdCwgZltpXS5pbmRleCwgZG9TY29yaW5nLCBxdWVyeVJlc3VsdHMsIGZbaV0udGVybSwgaWRmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwid2lsZGNhcmRcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuYWJsZVNjb3JpbmcgPSBxdWVyeS5lbmFibGVfc2NvcmluZyAhPT0gdW5kZWZpbmVkID8gcXVlcnkuZW5hYmxlX3Njb3JpbmcgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gd2lsZGNhcmRTZWFyY2gocXVlcnksIHJvb3QpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY29yZXIuc2NvcmUoZmllbGROYW1lLCBib29zdCwgd1tpXS5pbmRleCwgZG9TY29yaW5nICYmIGVuYWJsZVNjb3JpbmcsIHF1ZXJ5UmVzdWx0cywgd1tpXS50ZXJtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hfYWxsXCI6IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkb2NJZCBvZiB0aGlzLl9kb2NzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njb3Jlci5zY29yZUNvbnN0YW50KGJvb3N0LCBkb2NJZCwgcXVlcnlSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiY29uc3RhbnRfc2NvcmVcIjoge1xuICAgICAgICAgICAgICAgIGxldCB0bXBRdWVyeVJlc3VsdHMgPSB0aGlzLl9nZXRBbGwocXVlcnkuZmlsdGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGVhY2ggZG9jdW1lbnQgYSBjb25zdGFudCBzY29yZS5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRvY0lkIG9mIHRtcFF1ZXJ5UmVzdWx0cy5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NvcmVyLnNjb3JlQ29uc3RhbnQoYm9vc3QsIGRvY0lkLCBxdWVyeVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJwcmVmaXhcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuYWJsZVNjb3JpbmcgPSBxdWVyeS5lbmFibGVfc2NvcmluZyAhPT0gdW5kZWZpbmVkID8gcXVlcnkuZW5hYmxlX3Njb3JpbmcgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjcHMgPSB0b0NvZGVQb2ludHMocXVlcnkudmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1JZHggPSBpbnZlcnRlZF9pbmRleF9JbnZlcnRlZEluZGV4LmdldFRlcm1JbmRleChjcHMsIHJvb3QpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXJtSWR4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1JZHhzID0gaW52ZXJ0ZWRfaW5kZXhfSW52ZXJ0ZWRJbmRleC5leHRlbmRUZXJtSW5kZXgodGVybUlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVybUlkeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njb3Jlci5zY29yZShmaWVsZE5hbWUsIGJvb3N0LCB0ZXJtSWR4c1tpXS5pbmRleCwgZG9TY29yaW5nICYmIGVuYWJsZVNjb3JpbmcsIHF1ZXJ5UmVzdWx0cywgWy4uLmNwcywgLi4udGVybUlkeHNbaV0udGVybV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImV4aXN0c1wiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkb2NJZCBvZiB0aGlzLl9pbnZJZHhzW2ZpZWxkTmFtZV0uZG9jU3RvcmUua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY29yZXIuc2NvcmVDb25zdGFudChib29zdCwgZG9jSWQsIHF1ZXJ5UmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1zID0gYW5hbHl6ZShhbmFseXplciwgcXVlcnkudmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gcXVlcnkub3BlcmF0b3IgIT09IHVuZGVmaW5lZCA/IHF1ZXJ5Lm9wZXJhdG9yIDogXCJvclwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvb2xRdWVyeSA9IHsgdHlwZTogXCJib29sXCIgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJRdWVyaWVzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5Lm1pbmltdW1fc2hvdWxkX21hdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2xRdWVyeS5taW5pbXVtX3Nob3VsZF9tYXRjaCA9IHF1ZXJ5Lm1pbmltdW1fc2hvdWxkX21hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNob3VsZCBxdWVyeS5cbiAgICAgICAgICAgICAgICAgICAgYm9vbFF1ZXJ5LnNob3VsZCA9IHN1YlF1ZXJpZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBtdXN0IHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAgICBib29sUXVlcnkubXVzdCA9IHN1YlF1ZXJpZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvb2xRdWVyeS5ib29zdCA9IGJvb3N0O1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5mdXp6aW5lc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlZml4TGVuZ3RoID0gcXVlcnkucHJlZml4X2xlbmd0aCAhPT0gdW5kZWZpbmVkID8gcXVlcnkucHJlZml4X2xlbmd0aCA6IDI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBleHRlbmRlZCA9IHF1ZXJ5LmV4dGVuZGVkICE9PSB1bmRlZmluZWQgPyBxdWVyeS5leHRlbmRlZCA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZWFjaCBmdXp6eS5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViUXVlcmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1enp5XCIsIGZpZWxkOiBmaWVsZE5hbWUsIHZhbHVlOiB0ZXJtc1tpXSwgZnV6emluZXNzOiBxdWVyeS5mdXp6aW5lc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4X2xlbmd0aDogcHJlZml4TGVuZ3RoLCBleHRlbmRlZDogZXh0ZW5kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZWFjaCB0ZXJtLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJRdWVyaWVzLnB1c2goeyB0eXBlOiBcInRlcm1cIiwgZmllbGQ6IGZpZWxkTmFtZSwgdmFsdWU6IHRlcm1zW2ldIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0cyA9IHRoaXMuX3JlY3Vyc2l2ZShib29sUXVlcnksIGRvU2NvcmluZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeVJlc3VsdHM7XG4gICAgfVxuICAgIF9nZXRVbmlxdWUocXVlcmllcywgZG9TY29yaW5nLCBxdWVyeVJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHF1ZXJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJEb2NzID0gdGhpcy5fcmVjdXJzaXZlKHF1ZXJpZXNbaV0sIGRvU2NvcmluZyk7XG4gICAgICAgICAgICBpZiAocXVlcnlSZXN1bHRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzID0gdGhpcy5fcmVjdXJzaXZlKHF1ZXJpZXNbMF0sIGRvU2NvcmluZyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvY0lkIG9mIHF1ZXJ5UmVzdWx0cy5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJEb2NzLmhhcyhkb2NJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzLmRlbGV0ZShkb2NJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdHMuZ2V0KGRvY0lkKS5wdXNoKC4uLmN1cnJEb2NzLmdldChkb2NJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHRzO1xuICAgIH1cbiAgICBfZ2V0QWxsKHF1ZXJpZXMsIGRvU2NvcmluZywgcXVlcnlSZXN1bHRzID0gbmV3IE1hcCgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJEb2NzID0gdGhpcy5fcmVjdXJzaXZlKHF1ZXJpZXNbaV0sIGRvU2NvcmluZyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvY0lkIG9mIGN1cnJEb2NzLmtleXMoKSkge1xuICAgICAgICAgICAgICAgIGlmICghcXVlcnlSZXN1bHRzLmhhcyhkb2NJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzLnNldChkb2NJZCwgY3VyckRvY3MuZ2V0KGRvY0lkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVJlc3VsdHMuZ2V0KGRvY0lkKS5wdXNoKC4uLmN1cnJEb2NzLmdldChkb2NJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHRzO1xuICAgIH1cbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGV2ZW5zaHRlaW4gZGlzdGFuY2UuIFNwZWNpYWxpemVkIHZlcnNpb24uXG4gKiBDb3B5cmlnaHQgS2lnaXJpOiBodHRwczovL2dpdGh1Yi5jb20va2lnaXJpXG4gKiAgICAgICAgICAgTWlsb3QgTWlyZGl0YTogaHR0cHM6Ly9naXRodWIuY29tL21pbG90LW1pcmRpdGFcbiAqICAgICAgICAgICBUb25pIE5ldWJlcnQ6ICBodHRwczovL2dpdGh1Yi5jb20vVmlhdG9ydXMvXG4gKiBAcGFyYW0ge3N0cmluZ30gYSAtIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYiAtIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxldmVuc2h0ZWluRGlzdGFuY2UoYSwgYikge1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBwcmV2O1xuICAgIGxldCB2YWw7XG4gICAgY29uc3Qgcm93ID0gQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgICAvLyBpbml0IHRoZSByb3dcbiAgICBmb3IgKGkgPSAwOyBpIDw9IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93W2ldID0gaTtcbiAgICB9XG4gICAgLy8gZmlsbCBpbiB0aGUgcmVzdFxuICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmV2ID0gaTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoYltpIC0gMV0gPT09IGFbaiAtIDFdKSB7IC8vIG1hdGNoXG4gICAgICAgICAgICAgICAgdmFsID0gcm93W2ogLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbCA9IE1hdGgubWluKHJvd1tqIC0gMV0gKyAxLCAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICBNYXRoLm1pbihwcmV2ICsgMSwgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgcm93W2pdICsgMSkpOyAvLyBkZWxldGlvblxuICAgICAgICAgICAgICAgIC8vIHRyYW5zcG9zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDEgJiYgaiA+IDEgJiYgYltpIC0gMl0gPT09IGFbaiAtIDFdICYmIGFbaiAtIDJdID09PSBiW2kgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBNYXRoLm1pbih2YWwsIHJvd1tqIC0gMV0gLSAoYVtqIC0gMV0gPT09IGJbaSAtIDFdID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dbaiAtIDFdID0gcHJldjtcbiAgICAgICAgICAgIHByZXYgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcm93W2EubGVuZ3RoXSA9IHByZXY7XG4gICAgfVxuICAgIHJldHVybiByb3dbYS5sZW5ndGhdO1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGZ1enp5IHNlYXJjaC5cbiAqIEBwYXJhbSB7RnV6enlRdWVyeX0gcXVlcnkgLSB0aGUgZnV6enkgcXVlcnlcbiAqIEBwYXJhbSB7SW5kZXh9IHJvb3QgLSB0aGUgcm9vdCBpbmRleFxuICogQHJldHVybnMge1tGdXp6eVJlc3VsdCwgbnVtYmVyXX0gLSB0aGUgZnV6enkgcmVzdWx0cyBhbmQgdGhlIG1heGltdW0gZGZcbiAqL1xuZnVuY3Rpb24gZnV6enlTZWFyY2gocXVlcnksIHJvb3QpIHtcbiAgICBsZXQgdmFsdWUgPSB0b0NvZGVQb2ludHMocXVlcnkudmFsdWUpO1xuICAgIGxldCBmdXp6aW5lc3MgPSBxdWVyeS5mdXp6aW5lc3MgIT09IHVuZGVmaW5lZCA/IHF1ZXJ5LmZ1enppbmVzcyA6IFwiQVVUT1wiO1xuICAgIGlmIChmdXp6aW5lc3MgPT09IFwiQVVUT1wiKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgZnV6emluZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPD0gNSkge1xuICAgICAgICAgICAgZnV6emluZXNzID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1enppbmVzcyA9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHByZWZpeExlbmd0aCA9IHF1ZXJ5LnByZWZpeF9sZW5ndGggIT09IHVuZGVmaW5lZCA/IHF1ZXJ5LnByZWZpeF9sZW5ndGggOiAwO1xuICAgIGxldCBleHRlbmRlZCA9IHF1ZXJ5LmV4dGVuZGVkICE9PSB1bmRlZmluZWQgPyBxdWVyeS5leHRlbmRlZCA6IGZhbHNlO1xuICAgIC8vIERvIGp1c3QgYSBwcmVmaXggc2VhcmNoIGlmIHplcm8gZnV6emluZXNzLlxuICAgIGlmIChmdXp6aW5lc3MgPT09IDApIHtcbiAgICAgICAgcHJlZml4TGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbGV0IHN0YXJ0SWR4ID0gcm9vdDtcbiAgICBsZXQgcHJlZml4ID0gdmFsdWUuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKTtcbiAgICBsZXQgZnV6enkgPSB2YWx1ZTtcbiAgICBsZXQgZGYgPSAwO1xuICAgIC8vIFBlcmZvcm0gYSBwcmVmaXggc2VhcmNoLlxuICAgIGlmIChwcmVmaXhMZW5ndGggIT09IDApIHtcbiAgICAgICAgc3RhcnRJZHggPSBpbnZlcnRlZF9pbmRleF9JbnZlcnRlZEluZGV4LmdldFRlcm1JbmRleChwcmVmaXgsIHN0YXJ0SWR4KTtcbiAgICAgICAgZnV6enkgPSBmdXp6eS5zbGljZShwcmVmaXhMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBObyBzdGFydElkeCBmb3VuZC5cbiAgICBpZiAoc3RhcnRJZHggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtyZXN1bHQsIGRmXTtcbiAgICB9XG4gICAgLy8gRnV6enkgaXMgbm90IG5lY2Vzc2FyeSBhbnltb3JlLCBiZWNhdXNlIHByZWZpeCBzZWFyY2ggaW5jbHVkZXMgdGhlIHdob2xlIHF1ZXJ5IHZhbHVlLlxuICAgIGlmIChmdXp6eS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgICAgICAvLyBBZGQgYWxsIHRlcm1zIGRvd24gdGhlIGluZGV4LlxuICAgICAgICAgICAgY29uc3QgYWxsID0gaW52ZXJ0ZWRfaW5kZXhfSW52ZXJ0ZWRJbmRleC5leHRlbmRUZXJtSW5kZXgoc3RhcnRJZHgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGluZGV4OiBhbGxbaV0uaW5kZXgsIHRlcm06IGFsbFtpXS50ZXJtLCBib29zdDogMSB9KTtcbiAgICAgICAgICAgICAgICBkZiA9IE1hdGgubWF4KGRmLCBhbGxbaV0uaW5kZXguZGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0SWR4LmRjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEFkZCBwcmVmaXggc2VhcmNoIHJlc3VsdC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgaW5kZXg6IHN0YXJ0SWR4LCB0ZXJtOiB2YWx1ZSwgYm9vc3Q6IDEgfSk7XG4gICAgICAgICAgICBkZiA9IHN0YXJ0SWR4LmRmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmVzdWx0LCBkZl07XG4gICAgfVxuICAgIC8vIFRoZSBtYXRjaGluZyB0ZXJtLlxuICAgIGNvbnN0IHRlcm0gPSBbMF07XG4gICAgLy8gQ3JlYXRlIGFuIGF1dG9tYXRvbiBmcm9tIHRoZSBmdXp6eS5cbiAgICBjb25zdCBhdXRvbWF0b24gPSBuZXcgUnVuQXV0b21hdG9uKG5ldyBsZXZlbnNodGVpbl9hdXRvbWF0YV9MZXZlbnNodGVpbkF1dG9tYXRhKGZ1enp5LCBmdXp6aW5lc3MpLnRvQXV0b21hdG9uKCkpO1xuICAgIGZ1bmN0aW9uIGRldGVybWluZUVkaXREaXN0YW5jZShzdGF0ZSwgdGVybSwgZnV6enkpIHtcbiAgICAgICAgLy8gQ2hlY2sgaG93IG1hbnkgZWRpdHMgdGhpcyBmdXp6eSBjYW4gc3RpbGwgZG8uXG4gICAgICAgIGxldCBlZCA9IDA7XG4gICAgICAgIHN0YXRlID0gYXV0b21hdG9uLnN0ZXAoc3RhdGUsIDApO1xuICAgICAgICBpZiAoc3RhdGUgIT09IC0xICYmIGF1dG9tYXRvbi5pc0FjY2VwdChzdGF0ZSkpIHtcbiAgICAgICAgICAgIGVkKys7XG4gICAgICAgICAgICBzdGF0ZSA9IGF1dG9tYXRvbi5zdGVwKHN0YXRlLCAwKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gLTEgJiYgYXV0b21hdG9uLmlzQWNjZXB0KHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGVkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBzbWFsbGVyIHRlcm1zLlxuICAgICAgICAgICAgaWYgKHRlcm0ubGVuZ3RoIDwgZnV6enkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkICE9PSBmdXp6aW5lc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUxldmVuc2h0ZWluRGlzdGFuY2UodGVybSwgZnV6enkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHRoZSB0ZXJtIGFuZCBmdXp6eSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZWQgLT0gZnV6enkubGVuZ3RoIC0gdGVybS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1enppbmVzcyAtIGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmUoc3RhdGUsIGtleSwgaWR4KSB7XG4gICAgICAgIHRlcm1bdGVybS5sZW5ndGggLSAxXSA9IGtleTtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQga2V5IG9mIHRlcm0gd2l0aCB0aGUgYXV0b21hdG9uLlxuICAgICAgICBzdGF0ZSA9IGF1dG9tYXRvbi5zdGVwKHN0YXRlLCBrZXkpO1xuICAgICAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dG9tYXRvbi5pc0FjY2VwdChzdGF0ZSkpIHtcbiAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgdGVybXMgZG93biB0aGUgaW5kZXguXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsID0gaW52ZXJ0ZWRfaW5kZXhfSW52ZXJ0ZWRJbmRleC5leHRlbmRUZXJtSW5kZXgoaWR4KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGluZGV4OiBhbGxbaV0uaW5kZXgsIHRlcm06IGFsbFtpXS50ZXJtLCBib29zdDogMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGYgPSBNYXRoLm1heChkZiwgYWxsW2ldLmluZGV4LmRmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaWR4LmRmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgYm9vc3QuXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkZXRlcm1pbmVFZGl0RGlzdGFuY2Uoc3RhdGUsIHRlcm0sIGZ1enp5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBib29zdCA9IE1hdGgubWF4KDAsIDEgLSBkaXN0YW5jZSAvIE1hdGgubWluKHByZWZpeC5sZW5ndGggKyB0ZXJtLmxlbmd0aCwgdmFsdWUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBpbmRleDogaWR4LCB0ZXJtOiBbLi4ucHJlZml4LCAuLi50ZXJtXSwgYm9vc3QgfSk7XG4gICAgICAgICAgICAgICAgZGYgPSBNYXRoLm1heChkZiwgaWR4LmRmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXJtLnB1c2goMCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaWR4KSB7XG4gICAgICAgICAgICByZWN1cnNpdmUoc3RhdGUsIGNoaWxkWzBdLCBjaGlsZFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybS5wb3AoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBzdGFydElkeCkge1xuICAgICAgICByZWN1cnNpdmUoMCwgY2hpbGRbMF0sIGNoaWxkWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXN1bHQsIGRmXTtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSB3aWxkY2FyZCBzZWFyY2guXG4gKiBAcGFyYW0ge1dpbGRjYXJkUXVlcnl9IHF1ZXJ5IC0gdGhlIHdpbGRjYXJkIHF1ZXJ5XG4gKiBAcGFyYW0ge0luZGV4fSByb290IC0gdGhlIHJvb3QgaW5kZXhcbiAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgcmVzdWx0c1xuICovXG5mdW5jdGlvbiB3aWxkY2FyZFNlYXJjaChxdWVyeSwgcm9vdCkge1xuICAgIGxldCB3aWxkY2FyZCA9IHRvQ29kZVBvaW50cyhxdWVyeS52YWx1ZSk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZShpbmRleCwgaWR4ID0gMCwgdGVybSA9IFtdLCBlc2NhcGVkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkeCA9PT0gd2lsZGNhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXguZGYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgaW5kZXg6IGluZGV4LCB0ZXJtOiB0ZXJtLnNsaWNlKCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmICghZXNjYXBlZCAmJiB3aWxkY2FyZFtpZHhdID09PSA5MiAvKiBcXCAqLykge1xuICAgICAgICAgICAgcmVjdXJzaXZlKGluZGV4LCBpZHggKyAxLCB0ZXJtLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZXNjYXBlZCAmJiB3aWxkY2FyZFtpZHhdID09PSA2MyAvKiA/ICovKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlKGNoaWxkWzFdLCBpZHggKyAxLCBbLi4udGVybSwgY2hpbGRbMF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZXNjYXBlZCAmJiB3aWxkY2FyZFtpZHhdID09PSA0MiAvKiAqICovKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhc3RlcmlzayBpcyBsYXN0IHdpbGRjYXJkIGNoYXJhY3RlclxuICAgICAgICAgICAgaWYgKGlkeCArIDEgPT09IHdpbGRjYXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbCA9IGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXguZXh0ZW5kVGVybUluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZWN1cnNpdmUoYWxsW2ldLmluZGV4LCBpZHggKyAxLCBbLi4udGVybSwgLi4uYWxsW2ldLnRlcm1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHdob2xlIHRyZWUuXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlKGluZGV4LCBpZHggKyAxLCB0ZXJtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IFt7IGluZGV4OiBpbmRleCwgdGVybTogW10gfV07XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGluZGljZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaW5kZXguaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZShjaGlsZFsxXSwgaWR4ICsgMSwgWy4uLnRlcm0sIC4uLmluZGV4LnRlcm0sIGNoaWxkWzBdXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goeyBpbmRleDogY2hpbGRbMV0sIHRlcm06IFsuLi5pbmRleC50ZXJtLCBjaGlsZFswXV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpbmRpY2VzLmxlbmd0aCAhPT0gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWN1cnNpdmUoaW52ZXJ0ZWRfaW5kZXhfSW52ZXJ0ZWRJbmRleC5nZXRUZXJtSW5kZXgoW3dpbGRjYXJkW2lkeF1dLCBpbmRleCksIGlkeCArIDEsIFsuLi50ZXJtLCB3aWxkY2FyZFtpZHhdXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjdXJzaXZlKHJvb3QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9wYWNrYWdlcy9jb21tb24vcGx1Z2luLnRzXG52YXIgY29tbW9uX3BsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZnVsbC10ZXh0LXNlYXJjaC9zcmMvZnVsbF90ZXh0X3NlYXJjaC50c1xuXG5cblxuY2xhc3MgZnVsbF90ZXh0X3NlYXJjaF9GdWxsVGV4dFNlYXJjaCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgZnVsbC10ZXh0IHNlYXJjaCBmb3IgdGhlIGdpdmVuIGZpZWxkcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBmaWVsZE9wdGlvbnMgLSB0aGUgZmllbGQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9wdGlvbnMuZmllbGQgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZmllbGRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49dHJ1ZX0gZmllbGRPcHRpb25zLnN0b3JlIC0gZmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgZnVsbC10ZXh0IHNlYXJjaCBzaG91bGQgYmUgc3RvcmVkIG9uIHNlcmlhbGl6YXRpb24gb3JcbiAgICAgKiAgcmVidWlsZCBvbiBkZXNlcmlhbGl6YXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49dHJ1ZX0gZmllbGRPcHRpb25zLm9wdGltaXplQ2hhbmdlcyAtIGZsYWcgdG8gb3B0aW1pemUgdXBkYXRpbmcgYW5kIGRlbGV0aW5nIG9mIGRvY3VtZW50c1xuICAgICAqICAgIChyZXF1aXJlcyBtb3JlIG1lbW9yeSBidXQgcGVyZm9ybXMgZmFzdGVyKVxuICAgICAqIEBwYXJhbSB7QW5hbHl6ZXJ9IGZpZWxkT3B0aW9ucy5hbmFseXplciAtIGFuIGFuYWx5emVyIGZvciB0aGUgZmllbGRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2lkXSAtIHRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBkb2N1bWVudCBpbmRleFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkT3B0aW9ucyA9IFtdLCBpZCkge1xuICAgICAgICB0aGlzLl9pbnZJZHhzID0ge307XG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnZlcnRlZCBpbmRleCBmb3IgZWFjaCBmaWVsZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBmaWVsZE9wdGlvbiA9IGZpZWxkT3B0aW9uc1tpXTtcbiAgICAgICAgICAgIHRoaXMuX2ludklkeHNbZmllbGRPcHRpb24uZmllbGRdID0gbmV3IGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXgoZmllbGRPcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX2RvY3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2lkeFNlYXJjaGVyID0gbmV3IGluZGV4X3NlYXJjaGVyX0luZGV4U2VhcmNoZXIodGhpcy5faW52SWR4cywgdGhpcy5fZG9jcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZnVsbC10ZXh0IHNlYXJjaCBhcyBwbHVnaW4uXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyKCkge1xuICAgICAgICBjb21tb25fcGx1Z2luW1wiYVwiIC8qIFBMVUdJTlMgKi9dW1wiRnVsbFRleHRTZWFyY2hcIl0gPSBmdWxsX3RleHRfc2VhcmNoX0Z1bGxUZXh0U2VhcmNoO1xuICAgIH1cbiAgICBhZGREb2N1bWVudChkb2MsIGlkID0gZG9jW3RoaXMuX2lkXSkge1xuICAgICAgICBsZXQgZmllbGROYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuX2ludklkeHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZmllbGROYW1lOyBpIDwgZmllbGROYW1lcy5sZW5ndGgsIGZpZWxkTmFtZSA9IGZpZWxkTmFtZXNbaV07IGkrKykge1xuICAgICAgICAgICAgbGV0IGZpZWxkID0gZG9jW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAvLyBTa2lwIG51bGwgYW5kIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBudW1iZXIgdG8gc3RyaW5nLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBmaWVsZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgZmllbGQgdHlwZSBmb3IgZnVsbCB0ZXh0IHNlYXJjaC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW52SWR4c1tmaWVsZE5hbWVdLmluc2VydChmaWVsZCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RvY3MuYWRkKGlkKTtcbiAgICAgICAgdGhpcy5faWR4U2VhcmNoZXIuc2V0RGlydHkoKTtcbiAgICB9XG4gICAgcmVtb3ZlRG9jdW1lbnQoZG9jLCBpZCA9IGRvY1t0aGlzLl9pZF0pIHtcbiAgICAgICAgbGV0IGZpZWxkTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9pbnZJZHhzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZJZHhzW2ZpZWxkTmFtZXNbaV1dLnJlbW92ZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZG9jcy5kZWxldGUoaWQpO1xuICAgICAgICB0aGlzLl9pZHhTZWFyY2hlci5zZXREaXJ0eSgpO1xuICAgIH1cbiAgICB1cGRhdGVEb2N1bWVudChkb2MsIGlkID0gZG9jW3RoaXMuX2lkXSkge1xuICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50KGRvYywgaWQpO1xuICAgICAgICB0aGlzLmFkZERvY3VtZW50KGRvYywgaWQpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgZm9yIChsZXQgaWQgb2YgdGhpcy5fZG9jcykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudChudWxsLCBpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHhTZWFyY2hlci5zZWFyY2gocXVlcnkpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkID0geyBpZDogdGhpcy5faWQsIGlpOiB7fSB9O1xuICAgICAgICBsZXQgZmllbGROYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuX2ludklkeHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkTmFtZXNbaV07XG4gICAgICAgICAgICBzZXJpYWxpemVkLmlpW2ZpZWxkTmFtZV0gPSB0aGlzLl9pbnZJZHhzW2ZpZWxkTmFtZV0udG9KU09OKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTk9iamVjdChzZXJpYWxpemVkLCBhbmFseXplcnMgPSB7fSkge1xuICAgICAgICBsZXQgZnRzID0gbmV3IGZ1bGxfdGV4dF9zZWFyY2hfRnVsbFRleHRTZWFyY2goW10sIHNlcmlhbGl6ZWQuaWQpO1xuICAgICAgICBsZXQgZmllbGROYW1lcyA9IE9iamVjdC5rZXlzKHNlcmlhbGl6ZWQuaWkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkTmFtZXNbaV07XG4gICAgICAgICAgICBmdHMuX2ludklkeHNbZmllbGROYW1lXSA9IGludmVydGVkX2luZGV4X0ludmVydGVkSW5kZXguZnJvbUpTT05PYmplY3Qoc2VyaWFsaXplZC5paVtmaWVsZE5hbWVdLCBhbmFseXplcnNbZmllbGROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ0cztcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZnVsbC10ZXh0LXNlYXJjaC9zcmMvaW5kZXgudHNcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJGdWxsVGV4dFNlYXJjaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bGxfdGV4dF9zZWFyY2hfRnVsbFRleHRTZWFyY2g7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFuYWx5emVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhbmFseXplOyB9KTtcbi8qIGNvbmNhdGVkIGhhcm1vbnkgcmVleHBvcnQgKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTdGFuZGFyZEFuYWx5emVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYW5hbHl6ZXJfU3RhbmRhcmRBbmFseXplcjsgfSk7XG4vKiBjb25jYXRlZCBoYXJtb255IHJlZXhwb3J0ICovX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwid2hpdGVzcGFjZVRva2VuaXplclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdoaXRlc3BhY2VUb2tlbml6ZXI7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxvd2VyY2FzZVRva2VuRmlsdGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG93ZXJjYXNlVG9rZW5GaWx0ZXI7IH0pO1xuLyogY29uY2F0ZWQgaGFybW9ueSByZWV4cG9ydCAqL19fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInVwcGVyY2FzZVRva2VuRmlsdGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBwZXJjYXNlVG9rZW5GaWx0ZXI7IH0pO1xuXG5cblxuXG5mdWxsX3RleHRfc2VhcmNoX0Z1bGxUZXh0U2VhcmNoW1wiQW5hbHl6ZXJcIl0gPSB7fTtcbmZ1bGxfdGV4dF9zZWFyY2hfRnVsbFRleHRTZWFyY2hbXCJBbmFseXplclwiXVtcImFuYWx5emVcIl0gPSBhbmFseXplO1xuZnVsbF90ZXh0X3NlYXJjaF9GdWxsVGV4dFNlYXJjaFtcIkFuYWx5emVyXCJdW1wiU3RhbmRhcmRBbmFseXplclwiXSA9IGFuYWx5emVyX1N0YW5kYXJkQW5hbHl6ZXI7XG5mdWxsX3RleHRfc2VhcmNoX0Z1bGxUZXh0U2VhcmNoW1wiVG9rZW5pemVyXCJdID0ge307XG5mdWxsX3RleHRfc2VhcmNoX0Z1bGxUZXh0U2VhcmNoW1wiVG9rZW5pemVyXCJdW1wid2hpdGVzcGFjZVRva2VuaXplclwiXSA9IHdoaXRlc3BhY2VUb2tlbml6ZXI7XG5mdWxsX3RleHRfc2VhcmNoX0Z1bGxUZXh0U2VhcmNoW1wiVG9rZW5GaWx0ZXJcIl0gPSB7fTtcbmZ1bGxfdGV4dF9zZWFyY2hfRnVsbFRleHRTZWFyY2hbXCJUb2tlbkZpbHRlclwiXVtcImxvd2VyY2FzZVRva2VuRmlsdGVyXCJdID0gbG93ZXJjYXNlVG9rZW5GaWx0ZXI7XG5mdWxsX3RleHRfc2VhcmNoX0Z1bGxUZXh0U2VhcmNoW1wiVG9rZW5GaWx0ZXJcIl1bXCJ1cHBlcmNhc2VUb2tlbkZpbHRlclwiXSA9IHVwcGVyY2FzZVRva2VuRmlsdGVyO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmMgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdWxsX3RleHRfc2VhcmNoX0Z1bGxUZXh0U2VhcmNoKTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxva2lkYi5mdWxsLXRleHQtc2VhcmNoLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///458\n')},460:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);\n/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var core_js_modules_es_array_from_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);\n/* harmony import */ var core_js_modules_es_array_from_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_from_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);\n/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25);\n/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56);\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(78);\n/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var core_js_modules_es_array_find_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(71);\n/* harmony import */ var core_js_modules_es_array_find_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(177);\n/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(65);\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _query_builder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(453);\n/* harmony import */ var _query_builder__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_query_builder__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _lokidb_loki__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(457);\n/* harmony import */ var _lokidb_loki__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_lokidb_loki__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _lokidb_full_text_search__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(458);\n/* harmony import */ var _lokidb_full_text_search__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_lokidb_full_text_search__WEBPACK_IMPORTED_MODULE_12__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n_lokidb_full_text_search__WEBPACK_IMPORTED_MODULE_12___default.a.register();\nvar dirs = ["/", "/en", "/pl", "/en/hello", "/en/i18n", "/pl/hello", "/pl/i18n", "/en/hello/test", "/en/hello/world", "/pl/hello/test", "/pl/hello/test2", "/pl/hello/world", "/en/hello/world/test", "/pl/hello/world/test"];\nvar db, items;\n\nvar $content = function $content() {\n  var options = {};\n  var paths = [];\n  Array.from(arguments).forEach(function (argument) {\n    if (typeof argument === \'string\') {\n      paths.push(argument);\n    } else if (Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(argument) === \'object\') {\n      options = argument;\n    }\n  });\n  var _options = options,\n      _options$text = _options.text,\n      text = _options$text === void 0 ? false : _options$text,\n      _options$deep = _options.deep,\n      deep = _options$deep === void 0 ? false : _options$deep;\n  var path = "/".concat(paths.join(\'/\').replace(/\\/+/g, \'/\'));\n  var isDir = !path || !!dirs.find(function (dir) {\n    return dir === path;\n  }); // Look for dir or path\n\n  var query = isDir ? {\n    dir: deep ? {\n      $regex: new RegExp("^".concat(path))\n    } : path\n  } : {\n    path: path\n  }; // Postprocess to get only first result (findOne)\n\n  var postprocess = isDir ? [] : [function (data) {\n    return data[0];\n  }];\n  return new _query_builder__WEBPACK_IMPORTED_MODULE_10___default.a({\n    query: items.chain().find(query, !isDir),\n    path: path,\n    postprocess: postprocess,\n    text: text\n  }, {\n    fullTextSearchFields: ["title", "description", "slug", "text"]\n  });\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (function (database) {\n  db = new _lokidb_loki__WEBPACK_IMPORTED_MODULE_11___default.a(\'content.db\');\n  db.loadJSONObject(database);\n  items = db.getCollection(\'items\');\n  return $content;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLmNhY2hlL251eHQvY29udGVudC9wbHVnaW4uY2xpZW50LmxhenkuanM/YzdiYSJdLCJuYW1lcyI6WyJMb2tpRnVsbFRleHRTZWFyY2giLCJyZWdpc3RlciIsImRpcnMiLCJkYiIsIml0ZW1zIiwiJGNvbnRlbnQiLCJvcHRpb25zIiwicGF0aHMiLCJBcnJheSIsImZyb20iLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiYXJndW1lbnQiLCJwdXNoIiwidGV4dCIsImRlZXAiLCJwYXRoIiwiam9pbiIsInJlcGxhY2UiLCJpc0RpciIsImZpbmQiLCJkaXIiLCJxdWVyeSIsIiRyZWdleCIsIlJlZ0V4cCIsInBvc3Rwcm9jZXNzIiwiZGF0YSIsIlF1ZXJ5QnVpbGRlciIsImNoYWluIiwiZnVsbFRleHRTZWFyY2hGaWVsZHMiLCJkYXRhYmFzZSIsIkxva2kiLCJsb2FkSlNPTk9iamVjdCIsImdldENvbGxlY3Rpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBQSxnRUFBa0IsQ0FBQ0MsUUFBbkI7QUFFQSxJQUFNQyxJQUFJLEdBQUcsQ0FBQyxHQUFELEVBQUssS0FBTCxFQUFXLEtBQVgsRUFBaUIsV0FBakIsRUFBNkIsVUFBN0IsRUFBd0MsV0FBeEMsRUFBb0QsVUFBcEQsRUFBK0QsZ0JBQS9ELEVBQWdGLGlCQUFoRixFQUFrRyxnQkFBbEcsRUFBbUgsaUJBQW5ILEVBQXFJLGlCQUFySSxFQUF1SixzQkFBdkosRUFBOEssc0JBQTlLLENBQWI7QUFDRSxJQUFJQyxFQUFKLEVBQVFDLEtBQVI7O0FBRUYsSUFBTUMsUUFBUSxHQUFHLFNBQVhBLFFBQVcsR0FBWTtBQUMzQixNQUFJQyxPQUFPLEdBQUcsRUFBZDtBQUNBLE1BQU1DLEtBQUssR0FBRyxFQUFkO0FBQ0FDLE9BQUssQ0FBQ0MsSUFBTixDQUFXQyxTQUFYLEVBQXNCQyxPQUF0QixDQUE4QixVQUFDQyxRQUFELEVBQWM7QUFDMUMsUUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDTCxXQUFLLENBQUNNLElBQU4sQ0FBV0QsUUFBWDtBQUNELEtBRkQsTUFFTyxJQUFJLDBGQUFPQSxRQUFQLE1BQW9CLFFBQXhCLEVBQWtDO0FBQ3ZDTixhQUFPLEdBQUdNLFFBQVY7QUFDRDtBQUNGLEdBTkQ7QUFRQSxpQkFBdUNOLE9BQXZDO0FBQUEsK0JBQVFRLElBQVI7QUFBQSxNQUFRQSxJQUFSLDhCQUFlLEtBQWY7QUFBQSwrQkFBc0JDLElBQXRCO0FBQUEsTUFBc0JBLElBQXRCLDhCQUE2QixLQUE3QjtBQUVBLE1BQU1DLElBQUksY0FBT1QsS0FBSyxDQUFDVSxJQUFOLENBQVcsR0FBWCxFQUFnQkMsT0FBaEIsQ0FBd0IsTUFBeEIsRUFBZ0MsR0FBaEMsQ0FBUCxDQUFWO0FBQ0EsTUFBTUMsS0FBSyxHQUFHLENBQUNILElBQUQsSUFBUyxDQUFDLENBQUNkLElBQUksQ0FBQ2tCLElBQUwsQ0FBVSxVQUFBQyxHQUFHO0FBQUEsV0FBSUEsR0FBRyxLQUFLTCxJQUFaO0FBQUEsR0FBYixDQUF6QixDQWQyQixDQWUzQjs7QUFDQSxNQUFNTSxLQUFLLEdBQUdILEtBQUssR0FBRztBQUFFRSxPQUFHLEVBQUVOLElBQUksR0FBRztBQUFFUSxZQUFNLEVBQUUsSUFBSUMsTUFBSixZQUFlUixJQUFmO0FBQVYsS0FBSCxHQUF3Q0E7QUFBbkQsR0FBSCxHQUErRDtBQUFFQSxRQUFJLEVBQUpBO0FBQUYsR0FBbEYsQ0FoQjJCLENBaUIzQjs7QUFDQSxNQUFNUyxXQUFXLEdBQUdOLEtBQUssR0FBRyxFQUFILEdBQVEsQ0FBQyxVQUFBTyxJQUFJO0FBQUEsV0FBSUEsSUFBSSxDQUFDLENBQUQsQ0FBUjtBQUFBLEdBQUwsQ0FBakM7QUFFQSxTQUFPLElBQUlDLHNEQUFKLENBQWlCO0FBQ3RCTCxTQUFLLEVBQUVsQixLQUFLLENBQUN3QixLQUFOLEdBQWNSLElBQWQsQ0FBbUJFLEtBQW5CLEVBQTBCLENBQUNILEtBQTNCLENBRGU7QUFFdEJILFFBQUksRUFBSkEsSUFGc0I7QUFHdEJTLGVBQVcsRUFBWEEsV0FIc0I7QUFJdEJYLFFBQUksRUFBSkE7QUFKc0IsR0FBakIsRUFLSjtBQUNEZSx3QkFBb0IsRUFBRSxDQUFDLE9BQUQsRUFBUyxhQUFULEVBQXVCLE1BQXZCLEVBQThCLE1BQTlCO0FBRHJCLEdBTEksQ0FBUDtBQVFELENBNUJEOztBQThCZSx5RUFBQ0MsUUFBRCxFQUFjO0FBQzNCM0IsSUFBRSxHQUFHLElBQUk0QixvREFBSixDQUFTLFlBQVQsQ0FBTDtBQUNBNUIsSUFBRSxDQUFDNkIsY0FBSCxDQUFrQkYsUUFBbEI7QUFDQTFCLE9BQUssR0FBR0QsRUFBRSxDQUFDOEIsYUFBSCxDQUFpQixPQUFqQixDQUFSO0FBRUEsU0FBTzVCLFFBQVA7QUFDRCxDQU5EIiwiZmlsZSI6IjQ2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBRdWVyeUJ1aWxkZXIgZnJvbSAnLi9xdWVyeS1idWlsZGVyJ1xuaW1wb3J0IExva2kgZnJvbSAnQGxva2lkYi9sb2tpJ1xuaW1wb3J0IExva2lGdWxsVGV4dFNlYXJjaCBmcm9tICdAbG9raWRiL2Z1bGwtdGV4dC1zZWFyY2gnXG5cbkxva2lGdWxsVGV4dFNlYXJjaC5yZWdpc3RlcigpXG5cbmNvbnN0IGRpcnMgPSBbXCIvXCIsXCIvZW5cIixcIi9wbFwiLFwiL2VuL2hlbGxvXCIsXCIvZW4vaTE4blwiLFwiL3BsL2hlbGxvXCIsXCIvcGwvaTE4blwiLFwiL2VuL2hlbGxvL3Rlc3RcIixcIi9lbi9oZWxsby93b3JsZFwiLFwiL3BsL2hlbGxvL3Rlc3RcIixcIi9wbC9oZWxsby90ZXN0MlwiLFwiL3BsL2hlbGxvL3dvcmxkXCIsXCIvZW4vaGVsbG8vd29ybGQvdGVzdFwiLFwiL3BsL2hlbGxvL3dvcmxkL3Rlc3RcIl1cbiAgbGV0IGRiLCBpdGVtc1xuXG5jb25zdCAkY29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG9wdGlvbnMgPSB7fVxuICBjb25zdCBwYXRocyA9IFtdXG4gIEFycmF5LmZyb20oYXJndW1lbnRzKS5mb3JFYWNoKChhcmd1bWVudCkgPT4ge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXRocy5wdXNoKGFyZ3VtZW50KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50XG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHsgdGV4dCA9IGZhbHNlLCBkZWVwID0gZmFsc2UgfSA9IG9wdGlvbnNcblxuICBjb25zdCBwYXRoID0gYC8ke3BhdGhzLmpvaW4oJy8nKS5yZXBsYWNlKC9cXC8rL2csICcvJyl9YFxuICBjb25zdCBpc0RpciA9ICFwYXRoIHx8ICEhZGlycy5maW5kKGRpciA9PiBkaXIgPT09IHBhdGgpXG4gIC8vIExvb2sgZm9yIGRpciBvciBwYXRoXG4gIGNvbnN0IHF1ZXJ5ID0gaXNEaXIgPyB7IGRpcjogZGVlcCA/IHsgJHJlZ2V4OiBuZXcgUmVnRXhwKGBeJHtwYXRofWApIH0gOiBwYXRoIH0gOiB7IHBhdGggfVxuICAvLyBQb3N0cHJvY2VzcyB0byBnZXQgb25seSBmaXJzdCByZXN1bHQgKGZpbmRPbmUpXG4gIGNvbnN0IHBvc3Rwcm9jZXNzID0gaXNEaXIgPyBbXSA6IFtkYXRhID0+IGRhdGFbMF1dXG5cbiAgcmV0dXJuIG5ldyBRdWVyeUJ1aWxkZXIoe1xuICAgIHF1ZXJ5OiBpdGVtcy5jaGFpbigpLmZpbmQocXVlcnksICFpc0RpciksXG4gICAgcGF0aCxcbiAgICBwb3N0cHJvY2VzcyxcbiAgICB0ZXh0XG4gIH0sIHtcbiAgICBmdWxsVGV4dFNlYXJjaEZpZWxkczogW1widGl0bGVcIixcImRlc2NyaXB0aW9uXCIsXCJzbHVnXCIsXCJ0ZXh0XCJdXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IChkYXRhYmFzZSkgPT4ge1xuICBkYiA9IG5ldyBMb2tpKCdjb250ZW50LmRiJylcbiAgZGIubG9hZEpTT05PYmplY3QoZGF0YWJhc2UpXG4gIGl0ZW1zID0gZGIuZ2V0Q29sbGVjdGlvbignaXRlbXMnKVxuXG4gIHJldHVybiAkY29udGVudFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///460\n')}}]);